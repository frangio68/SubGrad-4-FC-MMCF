<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>CNDSM: NDOSolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CNDSM
   &#160;<span id="projectnumber">1.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classNDOSolver.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classNDOSolver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">NDOSolver Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The class <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> provides a general interface between convex (NonDifferentiable) optimization solvers and the applications that may need to use them.  
 <a href="classNDOSolver.html#details">More...</a></p>

<p><code>#include &lt;NDOSlver.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for NDOSolver:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classNDOSolver.png" usemap="#NDOSolver_map" alt=""/>
  <map id="NDOSolver_map" name="NDOSolver_map">
<area href="classSubGrad.html" title="The SubGrad class implements the NDOSolver interface for NonDifferentiable Optimization Solvers [see ..." alt="SubGrad" shape="rect" coords="0,56,77,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Types</div></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac7dbf4642c4b4f22bff6dcf5e8d67264"><td class="memItemLeft" align="right" valign="top">virtual cLMRow&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#ac7dbf4642c4b4f22bff6dcf5e8d67264">ReadSol</a> (cIndex_Set &amp;I, Index &amp;D)=0</td></tr>
<tr class="memdesc:ac7dbf4642c4b4f22bff6dcf5e8d67264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only pointer to the "current point" of the NDO algorithm, which is usually the "best estimate" found so far of an optimal point in some algorithmic-specific sense.  <a href="#ac7dbf4642c4b4f22bff6dcf5e8d67264">More...</a><br /></td></tr>
<tr class="separator:ac7dbf4642c4b4f22bff6dcf5e8d67264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257e10d1ab48238456040b025d55f3ea"><td class="memItemLeft" align="right" valign="top">virtual cLMRow&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a257e10d1ab48238456040b025d55f3ea">ReadBestSol</a> (cIndex_Set &amp;I, Index &amp;D)</td></tr>
<tr class="memdesc:a257e10d1ab48238456040b025d55f3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only pointer to the point having the lowest Fi-value found so far.  <a href="#a257e10d1ab48238456040b025d55f3ea">More...</a><br /></td></tr>
<tr class="separator:a257e10d1ab48238456040b025d55f3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807604e08d2cca70bb175206e1c5b6e9"><td class="memItemLeft" align="right" valign="top">virtual HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a807604e08d2cca70bb175206e1c5b6e9">ReadFiVal</a> (cIndex wFi=Inf&lt; Index &gt;())=0</td></tr>
<tr class="memdesc:a807604e08d2cca70bb175206e1c5b6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Fi-value(s) of the point returned by <a class="el" href="classNDOSolver.html#ac7dbf4642c4b4f22bff6dcf5e8d67264" title="Returns a read-only pointer to the &quot;current point&quot; of the NDO algorithm, which is usually the &quot;best e...">ReadSol()</a> [see above].  <a href="#a807604e08d2cca70bb175206e1c5b6e9">More...</a><br /></td></tr>
<tr class="separator:a807604e08d2cca70bb175206e1c5b6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2671fd0e3b342ab772548065e7a0e467"><td class="memItemLeft" align="right" valign="top">virtual HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a2671fd0e3b342ab772548065e7a0e467">ReadBestFiVal</a> (cIndex wFi=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:a2671fd0e3b342ab772548065e7a0e467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the best Fi-value() found so far, i.e., those of the point returned by <a class="el" href="classNDOSolver.html#a257e10d1ab48238456040b025d55f3ea" title="Returns a read-only pointer to the point having the lowest Fi-value found so far. ...">ReadBestSol()</a>.  <a href="#a2671fd0e3b342ab772548065e7a0e467">More...</a><br /></td></tr>
<tr class="separator:a2671fd0e3b342ab772548065e7a0e467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c93e6fbfe2940568ce6e4a70f1f7a9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#ac6c93e6fbfe2940568ce6e4a70f1f7a9">IsOptimal</a> (HpNum eps=0) const </td></tr>
<tr class="memdesc:ac6c93e6fbfe2940568ce6e4a70f1f7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method should return true if the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> believes that the current solution [see <a class="el" href="classNDOSolver.html#ac7dbf4642c4b4f22bff6dcf5e8d67264" title="Returns a read-only pointer to the &quot;current point&quot; of the NDO algorithm, which is usually the &quot;best e...">ReadSol()</a> above] is eps-optimal (relative).  <a href="#ac6c93e6fbfe2940568ce6e4a70f1f7a9">More...</a><br /></td></tr>
<tr class="separator:ac6c93e6fbfe2940568ce6e4a70f1f7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e8b0f60eafce85916506ecf35a79c2"><td class="memItemLeft" align="right" valign="top">virtual cHpRow&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#af8e8b0f60eafce85916506ecf35a79c2">ReadMult</a> (cIndex_Set &amp;I, Index &amp;D, cIndex wFi=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:af8e8b0f60eafce85916506ecf35a79c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convex minimization problems have a "dual" viewpoint (which is also briefly described in the general notes section of <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>).  <a href="#af8e8b0f60eafce85916506ecf35a79c2">More...</a><br /></td></tr>
<tr class="separator:af8e8b0f60eafce85916506ecf35a79c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714a2e303c980ce367572e5a53296928"><td class="memItemLeft" align="right" valign="top">virtual HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a714a2e303c980ce367572e5a53296928">ReadLBMult</a> (cIndex wFi=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:a714a2e303c980ce367572e5a53296928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some NDO algorithms may exploit the knowledge of Lower Bounds on the optimal value of the function [see GetLowerBound() in <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>] as a whole, or of its components.  <a href="#a714a2e303c980ce367572e5a53296928">More...</a><br /></td></tr>
<tr class="separator:a714a2e303c980ce367572e5a53296928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c23b71f41deb617a84474d4265ab25"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a94c23b71f41deb617a84474d4265ab25">FiEval</a> (void) const </td></tr>
<tr class="memdesc:a94c23b71f41deb617a84474d4265ab25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of times that Fi() has been called; if called from within Fi(), the present call should be excluded.  <a href="#a94c23b71f41deb617a84474d4265ab25">More...</a><br /></td></tr>
<tr class="separator:a94c23b71f41deb617a84474d4265ab25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f41276807360c8498840a654b08f09"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a90f41276807360c8498840a654b08f09">GiEval</a> (void) const </td></tr>
<tr class="memdesc:a90f41276807360c8498840a654b08f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of times that NewGi() has been called; if called from within NewGi(), the present call should be excluded.  <a href="#a90f41276807360c8498840a654b08f09">More...</a><br /></td></tr>
<tr class="separator:a90f41276807360c8498840a654b08f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819a706181b0260f915fe1a3b1a842e7"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a819a706181b0260f915fe1a3b1a842e7">NrCalls</a> (void) const </td></tr>
<tr class="memdesc:a819a706181b0260f915fe1a3b1a842e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of times that <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a> has been called; if called from within <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a>, the present call should be included.  <a href="#a819a706181b0260f915fe1a3b1a842e7">More...</a><br /></td></tr>
<tr class="separator:a819a706181b0260f915fe1a3b1a842e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41b23a17bbf7618a8675e89804b12cd"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#aa41b23a17bbf7618a8675e89804b12cd">NrIter</a> (void) const </td></tr>
<tr class="memdesc:aa41b23a17bbf7618a8675e89804b12cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of iterations.  <a href="#aa41b23a17bbf7618a8675e89804b12cd">More...</a><br /></td></tr>
<tr class="separator:aa41b23a17bbf7618a8675e89804b12cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd18260065df78d013735d5c9a520225"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#afd18260065df78d013735d5c9a520225">NDOTime</a> (double &amp;t_us, double &amp;t_ss)</td></tr>
<tr class="memdesc:afd18260065df78d013735d5c9a520225"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this method is called within any of the methods of the class that are "actively timed" (this depends on the subclasses), it returns the user and sistem time (in seconds) since the start of that method.  <a href="#afd18260065df78d013735d5c9a520225">More...</a><br /></td></tr>
<tr class="separator:afd18260065df78d013735d5c9a520225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ce9c84ab221296e0fd52b68e052153"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a77ce9c84ab221296e0fd52b68e052153">NDOTime</a> (void)</td></tr>
<tr class="memdesc:a77ce9c84ab221296e0fd52b68e052153"><td class="mdescLeft">&#160;</td><td class="mdescRight">As <a class="el" href="classNDOSolver.html#afd18260065df78d013735d5c9a520225" title="If this method is called within any of the methods of the class that are &quot;actively timed&quot; (this depen...">NDOTime( double &amp; , double &amp; )</a> [see above], except that returns the total (system + user ) time.  <a href="#a77ce9c84ab221296e0fd52b68e052153">More...</a><br /></td></tr>
<tr class="separator:a77ce9c84ab221296e0fd52b68e052153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructor</div></td></tr>
<tr class="memitem:a121fd9711d1724922d62153c7ead5231"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a121fd9711d1724922d62153c7ead5231">NDOSolver</a> (istream *iStrm=0)</td></tr>
<tr class="memdesc:a121fd9711d1724922d62153c7ead5231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the class.  <a href="#a121fd9711d1724922d62153c7ead5231">More...</a><br /></td></tr>
<tr class="separator:a121fd9711d1724922d62153c7ead5231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Other initializations</div></td></tr>
<tr class="memitem:aef118d44fbf65cff089a2a7a513ea73f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#aef118d44fbf65cff089a2a7a513ea73f">SetFiOracle</a> (<a class="el" href="classFiOracle.html">FiOracle</a> *Fi=0)</td></tr>
<tr class="memdesc:aef118d44fbf65cff089a2a7a513ea73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passes the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> object to the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> class.  <a href="#aef118d44fbf65cff089a2a7a513ea73f">More...</a><br /></td></tr>
<tr class="separator:aef118d44fbf65cff089a2a7a513ea73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292fa8c1a5c72bd8c1de8172c63fcf14"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a292fa8c1a5c72bd8c1de8172c63fcf14">SetLambda</a> (cLMRow tLambda=0)=0</td></tr>
<tr class="memdesc:a292fa8c1a5c72bd8c1de8172c63fcf14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the starting point of the NDO algorithm; if 0 is given, or if the method is <em>not</em> called, some starting point is chosen by the solver (the all-0 vectore being one of the prime candidates).  <a href="#a292fa8c1a5c72bd8c1de8172c63fcf14">More...</a><br /></td></tr>
<tr class="separator:a292fa8c1a5c72bd8c1de8172c63fcf14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6918947fbffeb0b82f6c65550fc900f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6918947fbffeb0b82f6c65550fc900f9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>KeepBestLambda</b> (const bool KBL=true)</td></tr>
<tr class="separator:a6918947fbffeb0b82f6c65550fc900f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23766f6f13e9580b2ec69f429788a1a6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a23766f6f13e9580b2ec69f429788a1a6">SetPar</a> (const int wp, const int value)</td></tr>
<tr class="memdesc:a23766f6f13e9580b2ec69f429788a1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some NDO algorithms are not descent, i.e., the point where the algorithm stops need not be the point which provides the best Fi-value found so far.  <a href="#a23766f6f13e9580b2ec69f429788a1a6">More...</a><br /></td></tr>
<tr class="separator:a23766f6f13e9580b2ec69f429788a1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7952ff5bfa959618fbb24cfe598b889a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a7952ff5bfa959618fbb24cfe598b889a">SetPar</a> (const int wp, cHpNum value)</td></tr>
<tr class="memdesc:a7952ff5bfa959618fbb24cfe598b889a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change "float" algorithmic parameters of the NDO solver.  <a href="#a7952ff5bfa959618fbb24cfe598b889a">More...</a><br /></td></tr>
<tr class="separator:a7952ff5bfa959618fbb24cfe598b889a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4834ac19cd934272935fccc6cebc207"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#aa4834ac19cd934272935fccc6cebc207">SetNDOLog</a> (ostream *outs=0, const char lvl=0)</td></tr>
<tr class="memdesc:aa4834ac19cd934272935fccc6cebc207"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class ouputs "log" information onto the ostream pointed by outs.  <a href="#aa4834ac19cd934272935fccc6cebc207">More...</a><br /></td></tr>
<tr class="separator:aa4834ac19cd934272935fccc6cebc207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b7996bf9fb1013f70df1d82d1b735c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a24b7996bf9fb1013f70df1d82d1b735c">SetNDOTime</a> (const bool TimeIt=true)</td></tr>
<tr class="memdesc:a24b7996bf9fb1013f70df1d82d1b735c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classNDOSolver.html#a24b7996bf9fb1013f70df1d82d1b735c" title="SetNDOTime() allocates an OPTtimers object [see OPTUtils.h] that should be used for timing the calls ...">SetNDOTime()</a> allocates an OPTtimers object [see OPTUtils.h] that should be used for timing the calls to relevant methods of the class.  <a href="#a24b7996bf9fb1013f70df1d82d1b735c">More...</a><br /></td></tr>
<tr class="separator:a24b7996bf9fb1013f70df1d82d1b735c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Solving the problem</div></td></tr>
<tr class="memitem:a9739939325d67b1833dea468308451ff"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classNDOSolver.html#a3028873c2d546da98905c33628e01442">NDOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff">Solve</a> (void)=0</td></tr>
<tr class="memdesc:a9739939325d67b1833dea468308451ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to minimize the function provided by the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>.  <a href="#a9739939325d67b1833dea468308451ff">More...</a><br /></td></tr>
<tr class="separator:a9739939325d67b1833dea468308451ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabda99af5786f0d0784342fa8b358bcb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#aabda99af5786f0d0784342fa8b358bcb">ReSetAlg</a> (unsigned char RstLvl=0)</td></tr>
<tr class="memdesc:aabda99af5786f0d0784342fa8b358bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">NDO algorithms typically have some parameters (stepsizes, multipliers ...) that are updated during the run according to factors such as the elapsed number of iterations, the outcome of the optimization process and so on.  <a href="#aabda99af5786f0d0784342fa8b358bcb">More...</a><br /></td></tr>
<tr class="separator:aabda99af5786f0d0784342fa8b358bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading the data of the problem</div></td></tr>
<tr class="memitem:a1b0e2f538b282f9fc50403bb6a66efb9"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a1b0e2f538b282f9fc50403bb6a66efb9">GetNumVar</a> (void) const </td></tr>
<tr class="memdesc:a1b0e2f538b282f9fc50403bb6a66efb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of variables of the function; a protected field is offered by the base class to keep this information.  <a href="#a1b0e2f538b282f9fc50403bb6a66efb9">More...</a><br /></td></tr>
<tr class="separator:a1b0e2f538b282f9fc50403bb6a66efb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e19d31ccc41dfa45cc83b9bc765e17"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a62e19d31ccc41dfa45cc83b9bc765e17">GetPar</a> (const int wp, int &amp;value)</td></tr>
<tr class="memdesc:a62e19d31ccc41dfa45cc83b9bc765e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the current value of the "int" algorithmic parameters of the NDO solver [see <a class="el" href="classNDOSolver.html#a23766f6f13e9580b2ec69f429788a1a6" title="Some NDO algorithms are not descent, i.e., the point where the algorithm stops need not be the point ...">SetPar()</a> above].  <a href="#a62e19d31ccc41dfa45cc83b9bc765e17">More...</a><br /></td></tr>
<tr class="separator:a62e19d31ccc41dfa45cc83b9bc765e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bd71859182dbc717132696636014e4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#ab5bd71859182dbc717132696636014e4">GetPar</a> (const int wp, HpNum &amp;value)</td></tr>
<tr class="memdesc:ab5bd71859182dbc717132696636014e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the current value of the "float" algorithmic parameters of the NDO solver [see <a class="el" href="classNDOSolver.html#a23766f6f13e9580b2ec69f429788a1a6" title="Some NDO algorithms are not descent, i.e., the point where the algorithm stops need not be the point ...">SetPar()</a> above].  <a href="#ab5bd71859182dbc717132696636014e4">More...</a><br /></td></tr>
<tr class="separator:ab5bd71859182dbc717132696636014e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Adding / removing / changing data</div></td></tr>
<tr class="memitem:a894710935ee4075fd6de9e610fc15187"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a894710935ee4075fd6de9e610fc15187">AddVariables</a> (Index NNwVrs, cLMRow IVs=0)</td></tr>
<tr class="memdesc:a894710935ee4075fd6de9e610fc15187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds `NNwVrs' new variables to the NDO problem.  <a href="#a894710935ee4075fd6de9e610fc15187">More...</a><br /></td></tr>
<tr class="separator:a894710935ee4075fd6de9e610fc15187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f6c9a4ff1c50fd8332784c42c8205a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a31f6c9a4ff1c50fd8332784c42c8205a">RemoveVariables</a> (cIndex_Set whch=0, Index hwmny=0)</td></tr>
<tr class="memdesc:a31f6c9a4ff1c50fd8332784c42c8205a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the variable whose "names" are contained in the vector `whch', that should contain `hwnmy' distinct values in the range 0 ...  <a href="#a31f6c9a4ff1c50fd8332784c42c8205a">More...</a><br /></td></tr>
<tr class="separator:a31f6c9a4ff1c50fd8332784c42c8205a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fb249f52783b4e8ab29434c66d0538"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#ae9fb249f52783b4e8ab29434c66d0538">ChgFiV</a> (cIndex wFi=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:ae9fb249f52783b4e8ab29434c66d0538"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method signals to the NDO solver that there have been changes in the function Fi.  <a href="#ae9fb249f52783b4e8ab29434c66d0538">More...</a><br /></td></tr>
<tr class="separator:ae9fb249f52783b4e8ab29434c66d0538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3f358432d029da286fd3546a03f29f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#afb3f358432d029da286fd3546a03f29f">ChgSbG</a> (cIndex strt=0, Index stp=Inf&lt; Index &gt;(), cIndex wFi=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:afb3f358432d029da286fd3546a03f29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method signals to the NDO solver that there have been changes in the function Fi.  <a href="#afb3f358432d029da286fd3546a03f29f">More...</a><br /></td></tr>
<tr class="separator:afb3f358432d029da286fd3546a03f29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destructor</div></td></tr>
<tr class="memitem:a43cfef60a0c4d08e63b5315236253b59"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a43cfef60a0c4d08e63b5315236253b59">~NDOSolver</a> ()</td></tr>
<tr class="memdesc:a43cfef60a0c4d08e63b5315236253b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of the class.  <a href="#a43cfef60a0c4d08e63b5315236253b59">More...</a><br /></td></tr>
<tr class="separator:a43cfef60a0c4d08e63b5315236253b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Standard fields</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Although <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> is an abstract base class, it contains some protected fields for holding some information that is always going to be there in all implementations, so that several (simple) methods of the public interface can be given a "standard" implementation that is going to work in most cases. </p>
</div></td></tr>
<tr class="memitem:a7351bcdcd41c5758e4298658a78b444f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7351bcdcd41c5758e4298658a78b444f"></a>
<a class="el" href="classFiOracle.html">FiOracle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a7351bcdcd41c5758e4298658a78b444f">Oracle</a></td></tr>
<tr class="memdesc:a7351bcdcd41c5758e4298658a78b444f"><td class="mdescLeft">&#160;</td><td class="mdescRight">(pointer to) the oracle for Fi <br /></td></tr>
<tr class="separator:a7351bcdcd41c5758e4298658a78b444f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036194ebd68cb26950274df64cd45628"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a036194ebd68cb26950274df64cd45628"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a036194ebd68cb26950274df64cd45628">MaxIter</a></td></tr>
<tr class="memdesc:a036194ebd68cb26950274df64cd45628"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of iterations <br /></td></tr>
<tr class="separator:a036194ebd68cb26950274df64cd45628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac907ffee42fdc8aaf6b31784ecc5a3e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac907ffee42fdc8aaf6b31784ecc5a3e7"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#ac907ffee42fdc8aaf6b31784ecc5a3e7">MaxTime</a></td></tr>
<tr class="memdesc:ac907ffee42fdc8aaf6b31784ecc5a3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum time (in seconds) for each call to <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a> <br /></td></tr>
<tr class="separator:ac907ffee42fdc8aaf6b31784ecc5a3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4fd0fd9cda5b9f4570d098b146dd11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf4fd0fd9cda5b9f4570d098b146dd11"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#aaf4fd0fd9cda5b9f4570d098b146dd11">tStar</a></td></tr>
<tr class="memdesc:aaf4fd0fd9cda5b9f4570d098b146dd11"><td class="mdescLeft">&#160;</td><td class="mdescRight">optimality related parameter: "scaling" of Fi <br /></td></tr>
<tr class="separator:aaf4fd0fd9cda5b9f4570d098b146dd11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6602ddb4e1219bc0ea9816ff87138e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b6602ddb4e1219bc0ea9816ff87138e"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a8b6602ddb4e1219bc0ea9816ff87138e">EpsLin</a></td></tr>
<tr class="memdesc:a8b6602ddb4e1219bc0ea9816ff87138e"><td class="mdescLeft">&#160;</td><td class="mdescRight">optimality related parameter: relative precision <br /></td></tr>
<tr class="separator:a8b6602ddb4e1219bc0ea9816ff87138e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885fdb020437994e0cc2a7681bcafe95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a885fdb020437994e0cc2a7681bcafe95"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a885fdb020437994e0cc2a7681bcafe95">EInit</a></td></tr>
<tr class="memdesc:a885fdb020437994e0cc2a7681bcafe95"><td class="mdescLeft">&#160;</td><td class="mdescRight">precision-related parameter: initial precision <br /></td></tr>
<tr class="separator:a885fdb020437994e0cc2a7681bcafe95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc932a683e4b168be22383a2f04f68e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacc932a683e4b168be22383a2f04f68e"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#aacc932a683e4b168be22383a2f04f68e">EFnal</a></td></tr>
<tr class="memdesc:aacc932a683e4b168be22383a2f04f68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">precision-related parameter: final precision <br /></td></tr>
<tr class="separator:aacc932a683e4b168be22383a2f04f68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7209661fab2496b25571dffb49253edc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7209661fab2496b25571dffb49253edc"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a7209661fab2496b25571dffb49253edc">EDcrs</a></td></tr>
<tr class="memdesc:a7209661fab2496b25571dffb49253edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">precision-related parameter: rate of decrease <br /></td></tr>
<tr class="separator:a7209661fab2496b25571dffb49253edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40380e77353e860fde1eaf0061053d46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40380e77353e860fde1eaf0061053d46"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a40380e77353e860fde1eaf0061053d46">EStps</a></td></tr>
<tr class="memdesc:a40380e77353e860fde1eaf0061053d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">precision-related parameter: number of steps <br /></td></tr>
<tr class="separator:a40380e77353e860fde1eaf0061053d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefea06e4a67c014c2f107bec27479021"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefea06e4a67c014c2f107bec27479021"></a>
<a class="el" href="classNDOSolver.html#a3028873c2d546da98905c33628e01442">NDOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#aefea06e4a67c014c2f107bec27479021">Result</a></td></tr>
<tr class="memdesc:aefea06e4a67c014c2f107bec27479021"><td class="mdescLeft">&#160;</td><td class="mdescRight">result of the latest call to <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a> <br /></td></tr>
<tr class="separator:aefea06e4a67c014c2f107bec27479021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8543193099c64b041d5ad1cc2ace45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa8543193099c64b041d5ad1cc2ace45"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#afa8543193099c64b041d5ad1cc2ace45">NumVar</a></td></tr>
<tr class="memdesc:afa8543193099c64b041d5ad1cc2ace45"><td class="mdescLeft">&#160;</td><td class="mdescRight">(current) number of variables <br /></td></tr>
<tr class="separator:afa8543193099c64b041d5ad1cc2ace45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec8d60a9d34695b3b410f3aeb37ff22"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ec8d60a9d34695b3b410f3aeb37ff22"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a2ec8d60a9d34695b3b410f3aeb37ff22">NrFi</a></td></tr>
<tr class="memdesc:a2ec8d60a9d34695b3b410f3aeb37ff22"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of components of Fi() <br /></td></tr>
<tr class="separator:a2ec8d60a9d34695b3b410f3aeb37ff22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55215bb952726160569746ad047260c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55215bb952726160569746ad047260c2"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a55215bb952726160569746ad047260c2">SCalls</a></td></tr>
<tr class="memdesc:a55215bb952726160569746ad047260c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">nuber of calls to <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a> (the current included) <br /></td></tr>
<tr class="separator:a55215bb952726160569746ad047260c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9716eb40fc916cad7d66d31cb22be80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9716eb40fc916cad7d66d31cb22be80"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#ac9716eb40fc916cad7d66d31cb22be80">ParIter</a></td></tr>
<tr class="memdesc:ac9716eb40fc916cad7d66d31cb22be80"><td class="mdescLeft">&#160;</td><td class="mdescRight">nuber of iterations in this run <br /></td></tr>
<tr class="separator:ac9716eb40fc916cad7d66d31cb22be80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668f46932f6eff896863aa0adeb69e63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a668f46932f6eff896863aa0adeb69e63"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a668f46932f6eff896863aa0adeb69e63">FiEvaltns</a></td></tr>
<tr class="memdesc:a668f46932f6eff896863aa0adeb69e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of Fi() calls <br /></td></tr>
<tr class="separator:a668f46932f6eff896863aa0adeb69e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7550cf091be6c4eb82484037ea3d3cd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7550cf091be6c4eb82484037ea3d3cd6"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a7550cf091be6c4eb82484037ea3d3cd6">GiEvaltns</a></td></tr>
<tr class="memdesc:a7550cf091be6c4eb82484037ea3d3cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of Gi() calls <br /></td></tr>
<tr class="separator:a7550cf091be6c4eb82484037ea3d3cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51cd6e17405ebbcefa509e43584d04a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad51cd6e17405ebbcefa509e43584d04a"></a>
ostream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#ad51cd6e17405ebbcefa509e43584d04a">NDOLog</a></td></tr>
<tr class="memdesc:ad51cd6e17405ebbcefa509e43584d04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">the output stream object for log purposes <br /></td></tr>
<tr class="separator:ad51cd6e17405ebbcefa509e43584d04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe5747970ad355d24d3b732b3d962ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fe5747970ad355d24d3b732b3d962ae"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a6fe5747970ad355d24d3b732b3d962ae">NDOLLvl</a></td></tr>
<tr class="memdesc:a6fe5747970ad355d24d3b732b3d962ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">the "level of verbosity" of the log <br /></td></tr>
<tr class="separator:a6fe5747970ad355d24d3b732b3d962ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccb3e3e5514571e76e8bf5d87b104a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adccb3e3e5514571e76e8bf5d87b104a4"></a>
OPTtimers *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#adccb3e3e5514571e76e8bf5d87b104a4">NDOt</a></td></tr>
<tr class="memdesc:adccb3e3e5514571e76e8bf5d87b104a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">OPTtimer for timing purposes. <br /></td></tr>
<tr class="separator:adccb3e3e5514571e76e8bf5d87b104a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The class <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> provides a general interface between convex (NonDifferentiable) optimization solvers and the applications that may need to use them. </p>
<p>Also, it provides an interface for the interaction between the NDO solvers and the FiOracles within more complex optimization schemes, such as those suggested in the general notes for the class <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> [see <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>].</p>
<p>The user is assumed to be familiar with the interface of the class <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> and with the relative algorithmic issues as described in <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a3e2b890b8fa2e3dcf9cff9b973b81108"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classNDOSolver.html#a3e2b890b8fa2e3dcf9cff9b973b81108">NDOParam</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public enum which is used in (the two overloaded versions of) <a class="el" href="classNDOSolver.html#a23766f6f13e9580b2ec69f429788a1a6" title="Some NDO algorithms are not descent, i.e., the point where the algorithm stops need not be the point ...">SetPar()</a> [see below]. </p>
<p>for selecting the algorithmic parameter to be set. kLastNDOParam is provided for allowing derived classes to extend the set of parameters they can handle while keeping the same signature for <a class="el" href="classNDOSolver.html#a23766f6f13e9580b2ec69f429788a1a6" title="Some NDO algorithms are not descent, i.e., the point where the algorithm stops need not be the point ...">SetPar()</a>: by setting kDerivedClassFirstParam = kLastNDOParam, one is guaranteed that the two sets of parameters will not collide. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a121fd9711d1724922d62153c7ead5231"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNDOSolver.html">NDOSolver</a> </td>
          <td>(</td>
          <td class="paramtype">istream *&#160;</td>
          <td class="paramname"><em>iStrm</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor of the class. </p>
<p>The parameter `iStrm', if provided, istaken as a pointer to a istream from which the algorithmic parameters for the NDO algorithm are sequentially read in the following order. Each parameter must be placed at the beginning of a separate line, max 255 carachters long, with all the rest of the line up to the first newline carachter '<br />
' (apart from a separating whitespace) being available for comments. Any line whose first carachter is '#' and any blank line is ignored. If 0 is passed, the file ends before reaching a given parameter, or some parameter is in the wrong format, each non-specified parameter is given a default value, shown in [] below.</p>
<p>Only a few parameters are deemed to be general enough to be put in the basic <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> class; however, the same stream can be used for passing the (possibly many more) algorithmic parameters to the derived classes. Since the constructor of <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> is executed before the ones of the derived classes, the specific parameters for the derived classes have just to be found in the stream after those of the base class.</p>
<p>Index MaxIter [0] Maximum number of iterations for each call to <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a> [see below]; if more iterations are required, <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a> should stop returning kStpIter. 0 (the default) means that the check is not done.</p>
<p>HpNum MaxTime [0] Maximum running time (in seconds) for each call to <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a> [see below]; if more time required, <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a> should stop returning kStpTime. 0 (the default) means that the check is not done. Note that this check can only be performed if timing of the code is activated [see <a class="el" href="classNDOSolver.html#a77ce9c84ab221296e0fd52b68e052153" title="As NDOTime( double &amp; , double &amp; ) [see above], except that returns the total (system + user ) time...">NDOTime()</a> below].</p>
<p>HpNum tStar [1e+2] Optimality related parameters. Proving that some HpNum EpsLin [1e-6] point Lambda is optimal for a NonDifferentiable Optimization problem involves finding an all-0 subgradient of the function at Lambda. If an all-0 vector is found in the epsilon-subdifferential of Lambda, then the point is epsilon-optimal. Note that if the minimization problem is subject to constraints, i.e., Fi() has to be minimized only on the points Lambda  L, the latter being a convex set, then the above is referred to a subgradient of the "actual function" ( Fi + I_L )( Lambda ), where I_L is the indicator function of L (evaluating to 0 inside L and to +INF otherwise). In other words, one has to show that there exists a( enspilon-)subgradient of Fi() at Lambda that, <em>after projection on the frontier of L</em>, is all-0. A general stopping condition requires that, if EpsLin is the <em>relative</em> precision required, a solver can stop if it finds an epsilon-subgradient g at Lambda such that tStar * || g || + epsilon &lt;= EpsLin * | MaxFi | where MaxFi is an estimate of the optimal solution value of the NDO problem, tStar is an estimate of the longest step that can be performed and || || is a norm-like function. tStar is related to the "scaling" of Fi(), and it can be seen as an estimate of the actual decrease that can be obtained by moving of an unitary step in the direction of any subgradient. Alternatively, the above condition can be seen as a weaker form of epsilon &lt;= EpsLin * | MaxFi | / 2 || g || &lt;= EpsLin * | MaxFi | / ( 2 * tStar ) which says that the solver stops when both epsilon and || g || are "small", with tStar dictating what "small" means for || g ||. Note that each derived class can use different norm-like functions to evaluate one or the other of the above conditions. Also, different estimates can be used for MaxFi, although using the bast Fi-value found so far is pretty common.</p>
<p>HpNum EInit [1e-2] The evaluation of function to be minimized may be a HpNum EFnal [1e-6] costly task: in many cases, it requires the solution HpNum EDcrs [.95] of a - possibly hard - optimization problem. Often, Index EStps [0] time can be saved if the function is only approximately computed at the beginning of the optimization process; of course, the computation should become more and more "exact" as the optimization proceeds. The relative precision required to the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> [see SetPrecision() in <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>] is initially set to EInit, and decreased down to EFnal by multiplying it by EDcrs every EStps iterations. If the NDO algorithm allows it, EStps can be set to 0 meaning that the precision is decreased only if necessary, i.e., when it is impossible to proceed otherwise (the algorithm must have some way to detect this). The precision is kept fixed if EInit == EFnal. A NDO solver which is <em>not</em> capable of handling approximate computation of the function can ignore the values of these parameters.</p>
<p>The parameters can be changed (and read) during the normal lifetime of the object, see <a class="el" href="classNDOSolver.html#a23766f6f13e9580b2ec69f429788a1a6" title="Some NDO algorithms are not descent, i.e., the point where the algorithm stops need not be the point ...">SetPar()</a> (<a class="el" href="classNDOSolver.html#a62e19d31ccc41dfa45cc83b9bc765e17" title="Read the current value of the &quot;int&quot; algorithmic parameters of the NDO solver [see SetPar() above]...">GetPar()</a>) below. </p>

</div>
</div>
<a class="anchor" id="a43cfef60a0c4d08e63b5315236253b59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="classNDOSolver.html">NDOSolver</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor of the class. </p>
<p>Since this is an abstract base class (i.e., derived classes <em>must</em> be defined), the destructor must be virtual in oder to ensure that "delete p;", where p is a NDOSolver* actually pointing to an object of a derived class, works. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aef118d44fbf65cff089a2a7a513ea73f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetFiOracle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFiOracle.html">FiOracle</a> *&#160;</td>
          <td class="paramname"><em>Fi</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Passes the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> object to the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> class. </p>
<p>This MUST be done PRIOR to ANY CALL to ANY OTHER method of the class!</p>
<p>This is not done in the constructor in order to allow the user to change the function to be minimized during the lifetime of one <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> object. Of course, this method must not be called within any other method of the class, as it (presumably) causes a complete reset of most internal data structures (e.g. the starting point, see below). Note that extensive support [see [Add/Remove]Variables() and Chg[FiV/SbG]() below] is given for cases where the function changes but the new function is "related" to the old one, so that "warm starts" can be attempted; of course, nothing of this kind can be expected when the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> is changed with <a class="el" href="classNDOSolver.html#aef118d44fbf65cff089a2a7a513ea73f" title="Passes the FiOracle object to the NDOSolver class. ">SetFiOracle()</a>.</p>
<p>Passing 0 as the pointer is intended signal the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> to release as much memory as possible and to sit down quietly in its corner, waiting for a new <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> to become available. After a SetFiOracle( 0 ) call, NO OTHER method of the class (apart from the destructor) should be called before <a class="el" href="classNDOSolver.html#aef118d44fbf65cff089a2a7a513ea73f" title="Passes the FiOracle object to the NDOSolver class. ">SetFiOracle()</a> is called again with a non-0 argument. However, specific NDO solvers may allow exceptions to this rule. </p>

</div>
</div>
<a class="anchor" id="a292fa8c1a5c72bd8c1de8172c63fcf14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetLambda </td>
          <td>(</td>
          <td class="paramtype">cLMRow&#160;</td>
          <td class="paramname"><em>tLambda</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the starting point of the NDO algorithm; if 0 is given, or if the method is <em>not</em> called, some starting point is chosen by the solver (the all-0 vectore being one of the prime candidates). </p>
<p>Note that <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a> [see below] is expected to repotimize somehow using the results of the previous calls, if any, and using the latest "curent point" as the starting point is one very typical way of doing it; <a class="el" href="classNDOSolver.html#a292fa8c1a5c72bd8c1de8172c63fcf14" title="Sets the starting point of the NDO algorithm; if 0 is given, or if the method is not called...">SetLambda()</a> can be used to reset the starting point.</p>
<p>No calls to <a class="el" href="classNDOSolver.html#a292fa8c1a5c72bd8c1de8172c63fcf14" title="Sets the starting point of the NDO algorithm; if 0 is given, or if the method is not called...">SetLambda()</a> are allowed while <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a> is running; the starting point can only be changed between two calls to <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a>, and this possibly has a nontrivial computational cost.</p>
<p>Note that tLambda <em>must</em> be feasible at least with respect to the non-negativity and upper bound constraints on the variables [see GetUC() and GetUB() in <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>]. Since one needs the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> to check it, this method must not be called before <a class="el" href="classNDOSolver.html#aef118d44fbf65cff089a2a7a513ea73f" title="Passes the FiOracle object to the NDOSolver class. ">SetFiOracle()</a> [see above]. </p>

</div>
</div>
<a class="anchor" id="a23766f6f13e9580b2ec69f429788a1a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetPar </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>wp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Some NDO algorithms are not descent, i.e., the point where the algorithm stops need not be the point which provides the best Fi-value found so far. </p>
<p>If KeepBestLambda() is called, the best point found so far is kept, otherwise (or if KeepBestLambda( false ) is called afterwards), it is not. In any case, the best <em>Fi-value</em> found so far is kept [see <a class="el" href="classNDOSolver.html#a2671fd0e3b342ab772548065e7a0e467" title="Returns the best Fi-value() found so far, i.e., those of the point returned by ReadBestSol(). ">ReadBestFiVal()</a> below]. The default implementation does nothing; this is appropriate for a NDO algorithm which <em>is</em> of descent. Change "int" algorithmic parameters of the NDO solver. This method is virtual because the derived classes may need to react to the changes of the parameters, and/or they may (and should) extend this method to allow setting the algorithmic-specific parameters.</p>
<p>The enum NDOParam [see above] is used (in the obvious way) for selecting the parameter to be set. Note that the type of `wp' is int rather than NDOParam, which is not a problem as enums can always be used where ints are required (i.e., SetPar( NDOSolver::kMaxItr , ... ) is a valid call). This is done in order to allow derived classes to extend the set of parameters they can handle while keeping the same signature for <a class="el" href="classNDOSolver.html#a23766f6f13e9580b2ec69f429788a1a6" title="Some NDO algorithms are not descent, i.e., the point where the algorithm stops need not be the point ...">SetPar()</a>. </p>

<p>Reimplemented in <a class="el" href="classSubGrad.html#a23766f6f13e9580b2ec69f429788a1a6">SubGrad</a>.</p>

</div>
</div>
<a class="anchor" id="a7952ff5bfa959618fbb24cfe598b889a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetPar </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>wp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cHpNum&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change "float" algorithmic parameters of the NDO solver. </p>
<p>This method is virtual because the derived classes may need to react to the changes of the parameters, and/or they may (and should) extend this method to allow setting the algorithmic-specific parameters.</p>
<p>The enum NDOParam [see above] is used (in the obvious way) for selecting the parameter to be set. Note that the type of `wp' is int rather than NDOParam, which is not a problem as enums can always be used where ints are required (i.e., SetPar( NDOSolver::kMaxItr , ... ) is a valid call). This is done in order to allow derived classes to extend the set of parameters they can handle while keeping the same signature for <a class="el" href="classNDOSolver.html#a23766f6f13e9580b2ec69f429788a1a6" title="Some NDO algorithms are not descent, i.e., the point where the algorithm stops need not be the point ...">SetPar()</a>. </p>

<p>Reimplemented in <a class="el" href="classSubGrad.html#a7952ff5bfa959618fbb24cfe598b889a">SubGrad</a>.</p>

</div>
</div>
<a class="anchor" id="aa4834ac19cd934272935fccc6cebc207"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetNDOLog </td>
          <td>(</td>
          <td class="paramtype">ostream *&#160;</td>
          <td class="paramname"><em>outs</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>lvl</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The class ouputs "log" information onto the ostream pointed by outs. </p>
<p>lvl controls the "level of verbosity" of the code; lvl == 0 means that nothing at all is printed, and values larger than 0 mean increasing amounts of information, the specific effect of each value being derived- class-dependent. outs == 0 implies lvl == 0. </p>

<p>Reimplemented in <a class="el" href="classSubGrad.html#abe58ac2f9c5ebae521b801c95beb8a3b">SubGrad</a>.</p>

</div>
</div>
<a class="anchor" id="a24b7996bf9fb1013f70df1d82d1b735c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetNDOTime </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>TimeIt</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classNDOSolver.html#a24b7996bf9fb1013f70df1d82d1b735c" title="SetNDOTime() allocates an OPTtimers object [see OPTUtils.h] that should be used for timing the calls ...">SetNDOTime()</a> allocates an OPTtimers object [see OPTUtils.h] that should be used for timing the calls to relevant methods of the class. </p>
<p>The time can be read with <a class="el" href="classNDOSolver.html#a77ce9c84ab221296e0fd52b68e052153" title="As NDOTime( double &amp; , double &amp; ) [see above], except that returns the total (system + user ) time...">NDOTime()</a> [see below]. By default, or if SetNDOTime( false ) is called, no timing is done. Note that, since all the relevant methods of the class are pure virtual, <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> can only manage the OPTtimers object, but it is due to derived classes to actually implement the timing.</p>
<p>Note that time accumulates over the calls; calling <a class="el" href="classNDOSolver.html#a24b7996bf9fb1013f70df1d82d1b735c" title="SetNDOTime() allocates an OPTtimers object [see OPTUtils.h] that should be used for timing the calls ...">SetNDOTime()</a>, however, resets the counters, allowing to time specific groups of calls. </p>

</div>
</div>
<a class="anchor" id="a9739939325d67b1833dea468308451ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classNDOSolver.html#a3028873c2d546da98905c33628e01442">NDOStatus</a> Solve </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to minimize the function provided by the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>. </p>
<p>Note that, in principle, a call to <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a> is intended to restart the algorithm from the exact state that it reached at the end of the previous call to <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a>, if any, unless <a class="el" href="classNDOSolver.html#aabda99af5786f0d0784342fa8b358bcb" title="NDO algorithms typically have some parameters (stepsizes, multipliers ...) that are updated during th...">ReSetAlg()</a> is called [see below]. This allows the user to interrupt the optimization process at any time and to resume it seamlessly at a later stage.</p>
<p>Returns if</p>
<p>kOK Optimization has been succesfull: a solution that is "optimal" (w.r.t. the current parameters settings) has been found.</p>
<p>kUnbndd Fi() is identically equal to - Infinity (or there has been an error in the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>), i.e., Fi() has returned - INF, or it is unbounded below; the latter case can be detected only if a lower bound on the min. value of Fi is available [see <a class="el" href="classFiOracle.html#a5deec7bb1a3f6dd38e937b1d10e302df" title="The function Fi to be minimized may be unbounded below, i.e., its infimum may be - INF...">FiOracle::GetMinusInfinity()</a>].</p>
<p>kUnfsbl The domain of Fi is empty.</p>
<p>kStopped <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a> has been stopped for some reason, typically because <a class="el" href="classFiOracle.html#aad5c05cf616d9205ee6d83ecbc9fafc5" title="GetFiStatus() returns the internal status of the FiOracle object. ">FiOracle::GetFiStatus()</a> returned FiOracle::kFiStop [see <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>]; this is possibly not an error, just maybe a request for a pause in the optimization process that might be restored in a later moment.</p>
<p>kLwPrcsn The NDO algorithm cannot proceed because the function cannot be computed with enough precision [see <a class="el" href="classFiOracle.html#a83893a59c6e60b15233ad9e368198015" title="The computation of the function Fi may be a costly task, e.g. ">FiOracle::SetPrecision()</a>]; this usually means that the function has been minimized up to the maximum extent that is possible due to the limited precision that the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> can provide;</p>
<p>kStpIter The max. number of iterations has been exhausted.</p>
<p>kStpTime The max. allowed running time has been spent.</p>
<p>kError There was a (typically numerical) error of some sort in <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a> or in the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> that forced the algorithm to quit.</p>
<p>Note that, whatever the exit condition be, some "current point" is usually available by calling <a class="el" href="classNDOSolver.html#ac7dbf4642c4b4f22bff6dcf5e8d67264" title="Returns a read-only pointer to the &quot;current point&quot; of the NDO algorithm, which is usually the &quot;best e...">ReadSol()</a>, and its Fi-value by calling <a class="el" href="classNDOSolver.html#a807604e08d2cca70bb175206e1c5b6e9" title="Returns the Fi-value(s) of the point returned by ReadSol() [see above]. ">ReadFiVal()</a> [see below]. </p>

<p>Implemented in <a class="el" href="classSubGrad.html#a4abf45f1d94e4e30cdad148af0d69e71">SubGrad</a>.</p>

</div>
</div>
<a class="anchor" id="aabda99af5786f0d0784342fa8b358bcb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ReSetAlg </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>RstLvl</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>NDO algorithms typically have some parameters (stepsizes, multipliers ...) that are updated during the run according to factors such as the elapsed number of iterations, the outcome of the optimization process and so on. </p>
<p>Also, they keep some information (previous subgradients and/or directions and/or constraints ...) that they use to drive the subsequent optimization.</p>
<p>When <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a> is called more than once, the "standard interpretation" is that the previous optimization had not been really succesfull, so that further processing is needed; this situation covers the case when "slight
  changes" in the function require a reoptimization [see [Add/Remove]Variables() and Chg[FiV/SbG]() below].</p>
<p>However, there are times when a "reset" of the internal state of the NDO algorithm is required. For instance, different functions defined on the variable space may have to be minimized consecutively; of course, this requires a complete reset of the internal state of the algorithm (which could be obtained with <a class="el" href="classNDOSolver.html#aef118d44fbf65cff089a2a7a513ea73f" title="Passes the FiOracle object to the NDOSolver class. ">SetFiOracle()</a> [see above], but possibly at a higher cost). Alternatively, the "slight" changes in Fi signalled by [Add/Remove]Variables() and Chg[FiV/SbG]() could not be slight at all, suggesting to restart the optimization basically from scratch. Finally, the NDO algorithm may "get stuck" because of some bad decision and not be able to terminate the optimization; sometimes, resetting some of the algorithmic parameters (stepsizes etc) may help it to recover.</p>
<p><a class="el" href="classNDOSolver.html#aabda99af5786f0d0784342fa8b358bcb" title="NDO algorithms typically have some parameters (stepsizes, multipliers ...) that are updated during th...">ReSetAlg()</a> tells the NDO solver to reset the internal state of the NDO algorithm. What exactly such a "reset" means is algorithm-specific (the standard implementation in the base class does nothing). Indeed, the parameter `RstLvl' is provided to allow the caller to specify different "levels of reset". The exact meaning of the value of the parameter shall be algorithm-specific, but it is intended that larger values mean "more
  conservative" resets (i.e., resetting less things) than smaller values, and that 0 means "a complete reset". </p>

<p>Reimplemented in <a class="el" href="classSubGrad.html#a1ad42200b126f5251c20490db5b6e06a">SubGrad</a>.</p>

</div>
</div>
<a class="anchor" id="ac7dbf4642c4b4f22bff6dcf5e8d67264"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual cLMRow ReadSol </td>
          <td>(</td>
          <td class="paramtype">cIndex_Set &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only pointer to the "current point" of the NDO algorithm, which is usually the "best estimate" found so far of an optimal point in some algorithmic-specific sense. </p>
<p>It may <em>not</em> be the point having the lowest Fi-value found so far, which is returned by <a class="el" href="classNDOSolver.html#a257e10d1ab48238456040b025d55f3ea" title="Returns a read-only pointer to the point having the lowest Fi-value found so far. ...">ReadBestSol()</a> [see below].</p>
<p>The "format" of the returned vector depends on what is returned in I and D; if I == 0 (=&gt; D == NumVar), then the pointer points to an array whose i-th entry is Lambda[ i ], otherwise the point has only (at most) D nonzero elements, and its i-th entry represents the value of Lambda[ I[ i ] ]. I[] must be ordered in increasing sense and Inf&lt;Index&gt;()-terminated. </p>

<p>Implemented in <a class="el" href="classSubGrad.html#ad0efcd2dbcac404c154a9a25c17cb2cb">SubGrad</a>.</p>

</div>
</div>
<a class="anchor" id="a257e10d1ab48238456040b025d55f3ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual cLMRow ReadBestSol </td>
          <td>(</td>
          <td class="paramtype">cIndex_Set &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only pointer to the point having the lowest Fi-value found so far. </p>
<p>Note that it is necessary to call KeepBestLambda() in order to be sure that the <a class="el" href="classNDOSolver.html#a257e10d1ab48238456040b025d55f3ea" title="Returns a read-only pointer to the point having the lowest Fi-value found so far. ...">ReadBestSol()</a> works; if not, it can return 0. If the NDO algorithm <em>is</em> of descent, the method returns the same point as <a class="el" href="classNDOSolver.html#ac7dbf4642c4b4f22bff6dcf5e8d67264" title="Returns a read-only pointer to the &quot;current point&quot; of the NDO algorithm, which is usually the &quot;best e...">ReadSol()</a> [see above]; the implementation of <a class="el" href="classNDOSolver.html#a257e10d1ab48238456040b025d55f3ea" title="Returns a read-only pointer to the point having the lowest Fi-value found so far. ...">ReadBestSol()</a> provided by the base class works for this case.</p>
<p>For "format" of the returned vector, also refer to <a class="el" href="classNDOSolver.html#ac7dbf4642c4b4f22bff6dcf5e8d67264" title="Returns a read-only pointer to the &quot;current point&quot; of the NDO algorithm, which is usually the &quot;best e...">ReadSol()</a>. </p>

<p>Reimplemented in <a class="el" href="classSubGrad.html#ad214f4b3502ca5dd35f513eec1cd6251">SubGrad</a>.</p>

</div>
</div>
<a class="anchor" id="a807604e08d2cca70bb175206e1c5b6e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HpNum ReadFiVal </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>wFi</em> = <code>Inf&lt;&#160;Index&#160;&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Fi-value(s) of the point returned by <a class="el" href="classNDOSolver.html#ac7dbf4642c4b4f22bff6dcf5e8d67264" title="Returns a read-only pointer to the &quot;current point&quot; of the NDO algorithm, which is usually the &quot;best e...">ReadSol()</a> [see above]. </p>
<p>wFi tells the value of which "component" of Fi is required [see GetNrFi() in <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>]:</p>
<ul>
<li>wFi == 0 requires the value of the linear 0-th component of Fi.</li>
<li>1 &lt;= wFi &lt;= NrFi requires the value of the wFi-th component of Fi.</li>
<li>Inf&lt;Index&gt;() &gt; wFi &gt; NrFi requires the value of the full function Fi except* the linear 0-th component.</li>
<li>wFi == Inf&lt;Index&gt;() requires the value of the full function Fi. </li>
</ul>

<p>Implemented in <a class="el" href="classSubGrad.html#a3551945ff40b2aea9cea17184b48dc0a">SubGrad</a>.</p>

</div>
</div>
<a class="anchor" id="a2671fd0e3b342ab772548065e7a0e467"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HpNum ReadBestFiVal </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>wFi</em> = <code>Inf&lt;Index&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the best Fi-value() found so far, i.e., those of the point returned by <a class="el" href="classNDOSolver.html#a257e10d1ab48238456040b025d55f3ea" title="Returns a read-only pointer to the point having the lowest Fi-value found so far. ...">ReadBestSol()</a>. </p>
<p>Unlike <a class="el" href="classNDOSolver.html#a257e10d1ab48238456040b025d55f3ea" title="Returns a read-only pointer to the point having the lowest Fi-value found so far. ...">ReadBestSol()</a>, however, this method is supposed to work even if KeepBestLambda() is <em>not</em> called (too little storage is required here not to do that). If the NDO algorithm <em>is</em> of descent, the method returns the same values as <a class="el" href="classNDOSolver.html#a807604e08d2cca70bb175206e1c5b6e9" title="Returns the Fi-value(s) of the point returned by ReadSol() [see above]. ">ReadFiVal()</a> [see above]; the implementation of <a class="el" href="classNDOSolver.html#a2671fd0e3b342ab772548065e7a0e467" title="Returns the best Fi-value() found so far, i.e., those of the point returned by ReadBestSol(). ">ReadBestFiVal()</a> provided by the base class works for this case.</p>
<p>For meaning of wFi, also refer to <a class="el" href="classNDOSolver.html#a807604e08d2cca70bb175206e1c5b6e9" title="Returns the Fi-value(s) of the point returned by ReadSol() [see above]. ">ReadFiVal()</a>. </p>

<p>Reimplemented in <a class="el" href="classSubGrad.html#a845913d16e9747aa92aff33076b22c15">SubGrad</a>.</p>

</div>
</div>
<a class="anchor" id="ac6c93e6fbfe2940568ce6e4a70f1f7a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IsOptimal </td>
          <td>(</td>
          <td class="paramtype">HpNum&#160;</td>
          <td class="paramname"><em>eps</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method should return true if the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> believes that the current solution [see <a class="el" href="classNDOSolver.html#ac7dbf4642c4b4f22bff6dcf5e8d67264" title="Returns a read-only pointer to the &quot;current point&quot; of the NDO algorithm, which is usually the &quot;best e...">ReadSol()</a> above] is eps-optimal (relative). </p>
<p>If eps == 0, then the optimality tolerances used by the solver to terminate are used.</p>
<p>This method may be called while <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a> is running, e.g. by the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>: if <a class="el" href="classNDOSolver.html#ac6c93e6fbfe2940568ce6e4a70f1f7a9" title="This method should return true if the NDOSolver believes that the current solution [see ReadSol() abo...">IsOptimal()</a>, then the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> is going to stop at this iteration, so the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> can react accordingly. </p>

</div>
</div>
<a class="anchor" id="af8e8b0f60eafce85916506ecf35a79c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual cHpRow ReadMult </td>
          <td>(</td>
          <td class="paramtype">cIndex_Set &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>wFi</em> = <code>Inf&lt;Index&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convex minimization problems have a "dual" viewpoint (which is also briefly described in the general notes section of <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>). </p>
<p>This method should return "dual" information about the problem, if the NDO algorithm is capable of computing it; as this is not always the case, a default implementation returning "no such information is available" is provided by the base class.</p>
<p>In general, the dual for the convex minimization problem </p><pre class="fragment">(P)   min{ Fi( Lambda ) }
</pre><p>is (D) inf{ Fi*( z ) : z = 0 }</p>
<p>where "*" indicates the Fenchel's conjugate operator; in fact, it is well-known that</p>
<p>inf{ Fi( Lambda ) } = - Fi*( 0 ),</p>
<p>so that the minimization of Fi is equivalent to problem of computing the conjugate of Fi in 0. The standard form in which Fi is available is that of a "black box" or "oracle" [see <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>]; from the dual viewpoint, an oracle is something that takes a point Lambda in the primal space and returns a point z in the dual space (essentially, the space of subgradients of Fi) such that Lambda is a <em>subgradient</em> of Fi* in z, together with the value Fi*( z ). This information is all that can be used from a "dual" NDO algorithm in order to solve the dual problem.</p>
<p>Since Fi* is a convex function, its epigraph is a convex set; each point (z, Fi*( z )) of the epigraph can be obtained as a convex combination of at most n + 1 other points of the epigraph. From the dual viewpoint, an NDO algorihm should produce a set of multipliers Theta[ z ] attached to all the subgradients/constraints (items) z generated by the oracle, such that</p>
<p>Sum{z} z * Theta[ z ] = 0 &amp;&amp; Sum{z} Fi*( z ) * Theta[ z ] = Fi*( 0 ).</p>
<p>A (read-only) pointer to these Theta[] must be returned by <a class="el" href="classNDOSolver.html#af8e8b0f60eafce85916506ecf35a79c2" title="Convex minimization problems have a &quot;dual&quot; viewpoint (which is also briefly described in the general ...">ReadMult()</a>, with 0 meaning that they are not available. The "format" of Theta[] depends on I: if I == 0, then Theta[] is a "dense" D-vector, i.e., the multiplier of item with "name" i is found in Theta[ i ] for i = 0, ..., D - 1, otherwise Theta[ i ] is the multiplier of the item with "name" I[ i ] for i = 0, ..., D - 1. I[] must be ordered in increasing sense and Inf&lt;Index&gt;()-terminated. The "names" of the items are those that are passed to the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> [see SetMaxName() and SetGiName() in <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>].</p>
<p>In the Lagrangian case, a dual object x[ i ] is attachedto the item z with name i; x[ i ]  X if z is a subgradient, while x[ i ] is an extreme ray for X if z is a constraint. Then,</p>
<p>x = Sum{i  D[]} Theta[ i ] * x[ i ]</p>
<p>is an optimal solution for the "convex relaxation" (D) of the original problem (OP) [see the general notes section in <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>], which can be constructed with this dual information and the help of the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>.</p>
<p>When Fi is decomposable, the dual information is naturally "splitted" among the components of Fi, since the subgradients are. If 1 &lt;= wFi &lt;= NrFi (the number of different components, see <a class="el" href="classNDOSolver.html#aef118d44fbf65cff089a2a7a513ea73f" title="Passes the FiOracle object to the NDOSolver class. ">SetFiOracle()</a> above) then only the dual information relative to that component will be returned, i.e., I[] will only contain "names" of items corresponding to component wFi; otherwise all the dual information will be returned. In the Lagrangian case, a decomposable Fi corresponds to a separable X [see <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>], so that the dual information is divided among the disjoint components of X.</p>
<dl class="section note"><dt>Note</dt><dd>For "easy" components of Fi() [see <a class="el" href="group__EasyComp.html#gad5a82019520f11aeeed9501d044e5ee3" title="Returns the number of variables of the &quot;easy&quot; linear problem which describes Fi[ wFi ]...">FiOracle::GetBNC()</a> ...], a different type of information naturally "takes the place" of the multipliers: the optimal solution x[ wFi ]* of the Lagrangian problem in the current point in terms of the "original variables" of the wFi-th component. Thus, calls to ReadMult( wFi ) with an "easy" wFi have the following different meaning: the vector returned by the method (that may be "dense" or "sparse" as in the standard case) represents x[ wFi ]*, and it is therefore a FiOracle::GetBNC( wFi )-vector. This information, however, can only* be accessed when calling ReadMult( wFi ) for wFi &lt;= NrFi: in "global" calls (wFi &gt; NrFi) only the multipliers corresponding to non-easy components are returned.</dd>
<dd>
The dual multipliers Theta[] corresponding to subgradients [of any given component] should be nonnegative and sum to 1&mdash;they are convex combinators&mdash;while the multipliers Theta[] corresponding to constraints [for any given component] need only be nonnegative. There is an exception to this rule, however, which happens if the NDO algorithms exploits the information provided by Lower Bounds on the optimal value of Fi and/or its components Fi[ i ]; these bounds have a dual meaning and therefore dual information attached to them, that is returned by the separate method GetLBMult() [see below]. If this happens, the "ordinary" dual multipliers returned by <a class="el" href="classNDOSolver.html#af8e8b0f60eafce85916506ecf35a79c2" title="Convex minimization problems have a &quot;dual&quot; viewpoint (which is also briefly described in the general ...">ReadMult()</a> and corresponding to subgradients may sum to a quantity <em>strictly smaller</em> than 1.</dd></dl>
<p>If <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a> returns kUnfeasible, the problem is unfeasible; this means that it is either <em>dual unbounded</em> or <em>dual empty</em>. In fact, the dual solution obtained as above is then a <em>feasible ascent extreme ray</em> for (D), that is c( x ) &gt; 0 , A( x ) [&lt;]= 0 and x' + beta * x  X for each x'  X and beta &gt; 0. Thus, if X is nonempty then (D) is unbounded, otherwise it is empty. </p>

</div>
</div>
<a class="anchor" id="a714a2e303c980ce367572e5a53296928"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HpNum ReadLBMult </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>wFi</em> = <code>Inf&lt;Index&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Some NDO algorithms may exploit the knowledge of Lower Bounds on the optimal value of the function [see GetLowerBound() in <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>] as a whole, or of its components. </p>
<p>These bound can be thought as all-0 subgradients, and therefore they have a dual multiplier associated; think to the case when the LB <em>is</em> the optimal value of the function, so that the dual multiplier of the (all-0 subgradient associated to the) LB is 1. This method returns the value of the optimal dual multiplier associated to the LB; if 1 &lt;= wFi &lt;= NrFi the LB is that on the wFi-th component of Fi, otherwise the LB is that on the whole function.</p>
<dl class="section note"><dt>Note</dt><dd>The multipliers returned by ReadMult( wFi ) [see above] should sum to 1 - ReadLBMult( wFi ) - <a class="el" href="classNDOSolver.html#a714a2e303c980ce367572e5a53296928" title="Some NDO algorithms may exploit the knowledge of Lower Bounds on the optimal value of the function [s...">ReadLBMult()</a>, except when wFi == 1 so that two multipliers are the same and the sum must be 1 - <a class="el" href="classNDOSolver.html#a714a2e303c980ce367572e5a53296928" title="Some NDO algorithms may exploit the knowledge of Lower Bounds on the optimal value of the function [s...">ReadLBMult()</a>.</dd>
<dd>
For "easy" components of Fi() [see <a class="el" href="group__EasyComp.html#gad5a82019520f11aeeed9501d044e5ee3" title="Returns the number of variables of the &quot;easy&quot; linear problem which describes Fi[ wFi ]...">FiOracle::GetBNC()</a> ...], it makes no sense to define lower bounds on the component because they (if any) are already implicit in the available complete description of the function; in fact, <a class="el" href="classFiOracle.html#acd48c1da81bbd115bd8e41e4abc8f936" title="In some cases, a Lower Bound on the minimal value of Fi is known; if Fi is a Lagrangian function...">FiOracle::GetLowerBound()</a> never produces anything for "easy" components.</dd></dl>
<p>If the NDO algorithm does not expolit the LBs, no dual multipliers are associated with them, and this method must return 0. </p>

</div>
</div>
<a class="anchor" id="a94c23b71f41deb617a84474d4265ab25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index FiEval </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of times that Fi() has been called; if called from within Fi(), the present call should be excluded. </p>
<p>Note that the class offers a protected field for this information, which must obviously be properly set by the derived classes. </p>

</div>
</div>
<a class="anchor" id="a90f41276807360c8498840a654b08f09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index GiEval </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of times that NewGi() has been called; if called from within NewGi(), the present call should be excluded. </p>
<p>Note that the class offers a protected field for this information, which must obviously be properly set by the derived classes. </p>

</div>
</div>
<a class="anchor" id="a819a706181b0260f915fe1a3b1a842e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index NrCalls </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of times that <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a> has been called; if called from within <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a>, the present call should be included. </p>
<p>Note that the class offers a protected field for this information, which must obviously be properly set by the derived classes. </p>

</div>
</div>
<a class="anchor" id="aa41b23a17bbf7618a8675e89804b12cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index NrIter </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current number of iterations. </p>
<p>Note that this counter is <em>not</em> necessarily reset each time <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a> is called, as multiple calls may actually be necessary to "solve the given problem". Thus, ideally this counter is only reset when "it is clear that an entirely new problem is
being solved", such as after a call to <a class="el" href="classNDOSolver.html#aabda99af5786f0d0784342fa8b358bcb" title="NDO algorithms typically have some parameters (stepsizes, multipliers ...) that are updated during th...">ReSetAlg()</a> or when an entirely different oracle is passed [see <a class="el" href="classNDOSolver.html#aef118d44fbf65cff089a2a7a513ea73f" title="Passes the FiOracle object to the NDOSolver class. ">SetFiOracle()</a>]. </p>

</div>
</div>
<a class="anchor" id="afd18260065df78d013735d5c9a520225"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NDOTime </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>t_us</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>t_ss</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If this method is called within any of the methods of the class that are "actively timed" (this depends on the subclasses), it returns the user and sistem time (in seconds) since the start of that method. </p>
<p>If methods that are actively timed call other methods that are actively timed, this method returns the (...) time since the beginning of the <em>outer</em> actively timed method. If this method is called outside of any actively timed method, it returns the (...) time spent in all the previous executions of all the actively timed methods of the class.</p>
<p>Implementing the proper calls to NDOt-&gt;Start() and NDOt-&gt;Stop() is due to derived classes; these should at least be placed at the beginning and at the end, respectively, of <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a> - that is, at least <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a> should be "actively timed". </p>

</div>
</div>
<a class="anchor" id="a77ce9c84ab221296e0fd52b68e052153"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double NDOTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>As <a class="el" href="classNDOSolver.html#afd18260065df78d013735d5c9a520225" title="If this method is called within any of the methods of the class that are &quot;actively timed&quot; (this depen...">NDOTime( double &amp; , double &amp; )</a> [see above], except that returns the total (system + user ) time. </p>

</div>
</div>
<a class="anchor" id="a1b0e2f538b282f9fc50403bb6a66efb9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index GetNumVar </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current number of variables of the function; a protected field is offered by the base class to keep this information. </p>

</div>
</div>
<a class="anchor" id="a62e19d31ccc41dfa45cc83b9bc765e17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GetPar </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>wp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the current value of the "int" algorithmic parameters of the NDO solver [see <a class="el" href="classNDOSolver.html#a23766f6f13e9580b2ec69f429788a1a6" title="Some NDO algorithms are not descent, i.e., the point where the algorithm stops need not be the point ...">SetPar()</a> above]. </p>

</div>
</div>
<a class="anchor" id="ab5bd71859182dbc717132696636014e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GetPar </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>wp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HpNum &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the current value of the "float" algorithmic parameters of the NDO solver [see <a class="el" href="classNDOSolver.html#a23766f6f13e9580b2ec69f429788a1a6" title="Some NDO algorithms are not descent, i.e., the point where the algorithm stops need not be the point ...">SetPar()</a> above]. </p>

</div>
</div>
<a class="anchor" id="a894710935ee4075fd6de9e610fc15187"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AddVariables </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>NNwVrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cLMRow&#160;</td>
          <td class="paramname"><em>IVs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds `NNwVrs' new variables to the NDO problem. </p>
<p>The new variables are added at the end of the current variable set, i.e., their "names" will be set to NumVar , ... , NumVar + NNwVrs - 1 (where `NumVar' means "the
number of variables *before* the call"). The total number of variables after the call will be &lt; NumVar + NNwVrs when NumVar + NNwVrs &gt; <a class="el" href="classFiOracle.html#a750898ca2374a3b61b4452034738a20d" title="This method provides the only explicit support – except for the return value `kFiChgd&#39; of GetFiStatu...">FiOracle::GetMaxNumVar()</a> [see <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>].</p>
<p>IVs is a NNwVrs-vector containing the initial values for the newly created variables; IVs == 0 means that all the initial values are 0.</p>
<p>After a call to this method, a different function, on a different variable space, has to be minimized. Of course, the two functions must not be unrelated to one another; more specifically, it is required that the new function Fi( Lambda , LambdaNew ) is identical to the old function Fi( Lambda ) when restricted to the old space, i.e. that</p>
<p>Fi( Lambda , 0 ) = Fi( Lambda ) for all Lambda.</p>
<p>This implies, for instance, that all the prevously collected subgradients are still subgradients for the restriction of the new Fi() to the subspace where all the new variables are zero. We also require that the every subgradient of the old Fi() can be extended to a subgradient of the new Fi() by just "filling in" the entries corresponding to the new variables with proper values (this is always possible e.g. for polyhedral functions). In other words, if the linear function</p>
<p>L( Lambda ) = G * Lambda + a</p>
<p>is known to minorize the old Fi(), then there must exist NewG such that</p>
<p>L( Lambda , LambdaNew ) = G * Lambda + NewG * LambdaNew + a</p>
<p>minorizes the new Fi(). Even better than that, the "linearization error" of L() at any point Lambda</p>
<p>Fi( Lambda ) - L( Lambda ) &gt;= 0</p>
<p>is identical to the linearization error of the new L() at [ Lambda , 0 ]</p>
<p>Fi( Lambda , 0 ) - L( Lambda , 0 ) &gt;= 0.</p>
<p>Then, the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> can use GetGi() [see <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>] to retrieve the new entries NewG for the newly created variables of the items "recorded" in the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>, if it needs so, while all the already fetched information remains valid. Note that, if IVs == 0, the value of the function in the new point [ Lambda , 0 ] is also known.</p>
<p>Therefore, a call to this method assumes that the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> already knows about the new set of variables to be created. In particular, the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> can use GetGi() as outlined above, and it can also use GetUB() and GetUC() [see <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>] to retrieve the lower and upper bounds on the variables; also, the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> can assume that, when the method is called, Oracle-&gt;<a class="el" href="classNDOSolver.html#a1b0e2f538b282f9fc50403bb6a66efb9" title="Returns the current number of variables of the function; a protected field is offered by the base cla...">GetNumVar()</a> [see <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>] already returns the number of variables <em>after</em> the addiction of the new NNwVrs ones. Note that the likely caller for <a class="el" href="classNDOSolver.html#a894710935ee4075fd6de9e610fc15187" title="Adds `NNwVrs&#39; new variables to the NDO problem. ">AddVariables()</a> is <em>the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> itself</em>; this is one of the reasons why the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> may need a pointer to the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> that is using it [see SetNDOSolver() in <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>]. If <a class="el" href="classNDOSolver.html#a894710935ee4075fd6de9e610fc15187" title="Adds `NNwVrs&#39; new variables to the NDO problem. ">AddVariables()</a> is not directly called by the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>, the caller must ensure that the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> has been properly updated <em>before</em> calling the method. Note that this requirement is, for obvious reasons, opposite to what is assumed for <a class="el" href="classNDOSolver.html#a31f6c9a4ff1c50fd8332784c42c8205a" title="Removes the variable whose &quot;names&quot; are contained in the vector `whch&#39;, that should contain `hwnmy&#39; di...">RemoveVariables()</a> [see below].</p>
<p>This operation is typically useful in the case of Lagrangian optimization where the set of relaxed constraints A( x ) [&lt;]= b is very large, leading to a very-large-scale NDO problem. Such a problem could be tackled with a row generation scheme, i.e., working with only an "active subset" of the full set of constraints and revising it as necessary. In this setting, adding variables corresponds to inserting new relaxed constraints in the current active set. </p>

</div>
</div>
<a class="anchor" id="a31f6c9a4ff1c50fd8332784c42c8205a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RemoveVariables </td>
          <td>(</td>
          <td class="paramtype">cIndex_Set&#160;</td>
          <td class="paramname"><em>whch</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>hwmny</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the variable whose "names" are contained in the vector `whch', that should contain `hwnmy' distinct values in the range 0 ... </p>
<p>NumVar - 1, be ordered in increasing sense and be Inf&lt;Index&gt;()-terminated, i.e., whch[ hwnmy ] must be == Inf&lt;Index&gt;().</p>
<p>If whch == 0, <em>all</em> the variables are eliminated; in this case, hwmny is ignored.</p>
<p>The set of variable "names" is kept contiguous, i.e., it is always the set 0 ... NumVar - 1 for the value of NumVar <em>after</em> the call to the method; hence, some of the variables that are not eliminated need to be "renamed". This is done as follows: when variable `i' is eliminated, all variables with names i + 1 ... NumVar - 1 take names i ... NumVar - 2, respectively (i.e., the names are shifted left by one to fill the gap). If multiple variables are eliminated, this is repeated for each variable, starting with the one with smaller name (the first one in whch) upwards. Note that if the last* variable is eliminated, no renaming has to be done.</p>
<p>After a call to this method, a different function, on a different variable space, has to be minimized. Of course, the two functions must not be unrelated to one another; more specifically, it is required that the new function Fi( Lambda ) is just the restriction of the old function Fi( Lambda , LambdaOld ) to the subspace where all the eliminated variables are zero, i.e. that</p>
<p>Fi( Lambda , 0 ) = Fi( Lambda ) for all Lambda.</p>
<p>This implies, for instance, that the projection of all the prevously collected subgradients on the new space (the elimination of the entries corresponding to the removed variables) are still subgradients for the new function in the new space. In other words, if the linear function</p>
<p>L( Lambda , LambdaOld ) = G * Lambda + OldG * LambdaOld + a</p>
<p>is known to minorize the old Fi(), then</p>
<p>L( Lambda ) = G * Lambda + a</p>
<p>minorizes the new Fi(). Even better than that, the "linearization error" of L() at any point with LambdaOld = 0</p>
<p>Fi( Lambda , 0 ) - L( Lambda , 0 ) &gt;= 0</p>
<p>is identical to the linearization error of L() at Lambda</p>
<p>Fi( Lambda ) - L( Lambda ) &gt;= 0.</p>
<p>Also, note that the value of the new function in all the previously tested points with LambdaOld = 0 (if any) is known.</p>
<p>When this method is called, the removed variables must <em>still be defined</em> in the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>, i.e., the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> is still allowed to query information about the variables being removed from the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>. Of course, after the termination of the call to RemovaVariables() the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> must be updated to reflect the change in the variables set. Note that the likely caller for <a class="el" href="classNDOSolver.html#a31f6c9a4ff1c50fd8332784c42c8205a" title="Removes the variable whose &quot;names&quot; are contained in the vector `whch&#39;, that should contain `hwnmy&#39; di...">RemoveVariables()</a> is <em>the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> itself</em>; this is one of the reasons why the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> may need a pointer to the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> that is using it [see SetNDOSolver() in <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>]. If ReomveVariables() is not directly called by the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>, the caller must ensure that the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> is also properly updated <em>after</em> that the method returns. Note that this requirement is, for obvious reasons, opposite to what is assumed for <a class="el" href="classNDOSolver.html#a894710935ee4075fd6de9e610fc15187" title="Adds `NNwVrs&#39; new variables to the NDO problem. ">AddVariables()</a> [see above].</p>
<p>This operation is typically useful in the case of Lagrangian optimization, where it corresponds to the deletion of some of the relaxed constraints A( x ) [&lt;]= b, hopefully because they have been detected to be redundant. </p>

</div>
</div>
<a class="anchor" id="ae9fb249f52783b4e8ab29434c66d0538"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgFiV </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>wFi</em> = <code>Inf&lt;Index&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method signals to the NDO solver that there have been changes in the function Fi. </p>
<p>These changes are such that the previously obtained information about the function is not completely useless, but it needs to be properly updated. If 0 &lt;= wFi &lt;= NrFi, the NDO solver is told that only the wFi-th component of Fi has changed; if Inf&lt;Index&gt;() &gt; wFi &gt; NrFi then all the components except the 0-th have changed, while if wFi == Inf&lt;Index&gt;() then all the components, comprised the 0-th, have changed.</p>
<p>The class of changes that are signalled by <a class="el" href="classNDOSolver.html#ae9fb249f52783b4e8ab29434c66d0538" title="This method signals to the NDO solver that there have been changes in the function Fi...">ChgFiV()</a> are those where only the Fi-values are affected, but not the first-order information. In the Lagrangian case, they correspond to = changes in the objective function c( x ) of the Lagrangian problem, or = changes in the feasible set X of the Lagrangian problem.</p>
<p>In both cases, the first-order information (subgradient/constraint) corresponding to a particular dual solution/dual extreme ray x that has been previously generated can be re-used. If c( x ) changes, the old information given by x is still meaningful for the new Fi provided that it is properly translated [see GetVal() in <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>]. For the linear 0-th component, this corresponds to a change of the constant `b0'. If X changes, x can either be feasible/an extreme ray or not; if it is, then the old item associated to x is still valid for Fi with no changes, otherwise it should probably be discarded, which is signalled by GetVal() returning - INF.</p>
<p>In both cases, the changes that are needed to update the information are given by just one number for each dual solution x, which can be queried by means of the method GetVal() of class <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>. Of course, this means that the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> already knows about the change. Indeed, the most likely caller for ChgFi() is <em>the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> itself</em>; this is one of the reasons why the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> may need a pointer to the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> that is using it [see SetNDOSolver() in <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>]. If <a class="el" href="classNDOSolver.html#ae9fb249f52783b4e8ab29434c66d0538" title="This method signals to the NDO solver that there have been changes in the function Fi...">ChgFiV()</a> is not directly called by the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>, the caller must ensure that the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> has been properly informed <em>before</em> calling the method. </p>

</div>
</div>
<a class="anchor" id="afb3f358432d029da286fd3546a03f29f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgSbG </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;Index&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>wFi</em> = <code>Inf&lt;Index&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method signals to the NDO solver that there have been changes in the function Fi. </p>
<p>These changes are such that the previously obtained information about the function is not completely useless, but it needs to be properly updated. If 0 &lt;= wFi &lt;= NrFi, the NDO solver is told that only the wFi-th component of Fi has changed; if Inf&lt;Index&gt;() &gt; wFi &gt; NrFi then all the components except the 0-th have changed, while if wFi == Inf&lt;Index&gt;() then all the components, comprised the 0-th, have changed.</p>
<p><a class="el" href="classNDOSolver.html#afb3f358432d029da286fd3546a03f29f" title="This method signals to the NDO solver that there have been changes in the function Fi...">ChgSbG()</a> signals that the first-order information relative to the variables with "names" comprised between strt and min( stp , NumVar ) - 1 for the specified components has changed. The changes are intended not to involve the Fi-values, i.e., if Fi-values change together with the first-order information then a separate call to <a class="el" href="classNDOSolver.html#ae9fb249f52783b4e8ab29434c66d0538" title="This method signals to the NDO solver that there have been changes in the function Fi...">ChgFiV()</a> [see above] is required. In the Lagrangian case, changes to the first-oredr information correspond to changes in the constranints `A[ h ]()'/ right hand side `b' (note that these changes <em>are</em> typically accompained by changes of the Fi-values).</p>
<p>A call to this method assumes that the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> already knows about the changes. In particular, the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> can use GetGi() [see <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>] to retrieve the new values for the changed entries of the items of the specified components of Fi, if it needs so. Indeed, the likely caller for <a class="el" href="classNDOSolver.html#afb3f358432d029da286fd3546a03f29f" title="This method signals to the NDO solver that there have been changes in the function Fi...">ChgSbG()</a> is <em>the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> itself</em>; this is one of the reasons why the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> may need a pointer to the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> that is using it [see SetNDOSolver() in <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>]. If <a class="el" href="classNDOSolver.html#afb3f358432d029da286fd3546a03f29f" title="This method signals to the NDO solver that there have been changes in the function Fi...">ChgSbG()</a> is not directly called by the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>, the caller must ensure that the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> has been properly updated <em>before</em> calling the method. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classNDOSolver.html">NDOSolver</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
