<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>CNDSM: MMCFClass Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CNDSM
   &#160;<span id="projectnumber">1.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classMMCFClass.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="classMMCFClass-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MMCFClass Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>This class defines a standard abstract interface for solvers of (generalized) Multicommodity Min-Cost Flow problems, i.e., problems of the form.  
 <a href="classMMCFClass.html#details">More...</a></p>

<p><code>#include &lt;MMCFClas.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MMCFClass:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classMMCFClass.png" usemap="#MMCFClass_map" alt=""/>
  <map id="MMCFClass_map" name="MMCFClass_map">
<area href="classKnpsFiOrcl.html" title="Instantiation of FiOracle for Knapsack Lagrangian relaxation of FC-MMFC. " alt="KnpsFiOrcl" shape="rect" coords="0,56,83,80"/>
<area href="classMMCFCplex.html" title="The class MMCFCplex implements the generic interface for Multicommodity Min-Cost Flow solvers defined..." alt="MMCFCplex" shape="rect" coords="93,56,176,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass_1_1MMCFException.html">MMCFException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Very small class to simplify extracting the "+ infinity" value for a basic type (FNumber, CNumber, Index); just use Inf&lt;type&gt;().  <a href="classMMCFClass_1_1MMCFException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Public types</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="el" href="classMMCFClass.html" title="This class defines a standard abstract interface for solvers of (generalized) Multicommodity Min-Cost...">MMCFClass</a> defines five main public types:</p>
<ul>
<li>Index, the type of arc and node indices;</li>
<li>FNumber, the type of flow variables, arc capacities, and node deficits;</li>
<li>CNumber, the type of flow costs, node potentials, and arc reduced costs;</li>
<li>FONumber, the type of objective function value;</li>
<li>MFNumber, the type a Multicommodity flow variable;</li>
<li>Number, the type an "extra" variable.</li>
</ul>
<p>By re-defining the types in this section, one MMCFSolver could be adapted to work with "smaller" data types than the obvioous ones (double for all but the indices, int for the latter). This may be relevant e.g. for cases where flow types are integer but multicommodity flows are not. However, it is the user's responsibility to ensure that these types are set to reasonable values*, since <em>not all solution algorithms will work with "restricted" data</em>. Hence, only the the experienced user may want to experiment with changing this, and only if memory footprint and/or speed is really a primary concern and it is likely that changing these will improve. </p>
</div></td></tr>
<tr class="memitem:ad53d6229d7ec28555a9c9c2fd9abf773"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad53d6229d7ec28555a9c9c2fd9abf773"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a></td></tr>
<tr class="memdesc:ad53d6229d7ec28555a9c9c2fd9abf773"><td class="mdescLeft">&#160;</td><td class="mdescRight">index of a node or arc ( &gt;= 0 ) <br /></td></tr>
<tr class="separator:ad53d6229d7ec28555a9c9c2fd9abf773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3388eb329ff0551a0b86b6c67e33d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace3388eb329ff0551a0b86b6c67e33d8"></a>
typedef <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a></td></tr>
<tr class="memdesc:ace3388eb329ff0551a0b86b6c67e33d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">set (array) of indices <br /></td></tr>
<tr class="separator:ace3388eb329ff0551a0b86b6c67e33d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76aaabb20535c51a2752b93f6c38fe54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76aaabb20535c51a2752b93f6c38fe54"></a>
typedef const <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a></td></tr>
<tr class="memdesc:a76aaabb20535c51a2752b93f6c38fe54"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only index <br /></td></tr>
<tr class="separator:a76aaabb20535c51a2752b93f6c38fe54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81575b2d4e4d5636b17170432150ae69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81575b2d4e4d5636b17170432150ae69"></a>
typedef <a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a></td></tr>
<tr class="memdesc:a81575b2d4e4d5636b17170432150ae69"><td class="mdescLeft">&#160;</td><td class="mdescRight">read-only index array <br /></td></tr>
<tr class="separator:a81575b2d4e4d5636b17170432150ae69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea3e5951d222b2a8e57de1b4246a909"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeea3e5951d222b2a8e57de1b4246a909"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a></td></tr>
<tr class="memdesc:aeea3e5951d222b2a8e57de1b4246a909"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of arc flow <br /></td></tr>
<tr class="separator:aeea3e5951d222b2a8e57de1b4246a909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dae1f1a39c208ce3c2b337cd5bb3d00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dae1f1a39c208ce3c2b337cd5bb3d00"></a>
typedef <a class="el" href="classMMCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a></td></tr>
<tr class="memdesc:a9dae1f1a39c208ce3c2b337cd5bb3d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of flows <br /></td></tr>
<tr class="separator:a9dae1f1a39c208ce3c2b337cd5bb3d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f747fbdff346237c8db4469d569994"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11f747fbdff346237c8db4469d569994"></a>
typedef const <a class="el" href="classMMCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a11f747fbdff346237c8db4469d569994">cFNumber</a></td></tr>
<tr class="memdesc:a11f747fbdff346237c8db4469d569994"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only flow <br /></td></tr>
<tr class="separator:a11f747fbdff346237c8db4469d569994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad325f3193dbba0ddef1da4e72d29eda6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad325f3193dbba0ddef1da4e72d29eda6"></a>
typedef <a class="el" href="classMMCFClass.html#a11f747fbdff346237c8db4469d569994">cFNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a></td></tr>
<tr class="memdesc:ad325f3193dbba0ddef1da4e72d29eda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">read-only flow array <br /></td></tr>
<tr class="separator:ad325f3193dbba0ddef1da4e72d29eda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d0627ba8213afe1ec4ebeb4508e8f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24d0627ba8213afe1ec4ebeb4508e8f1"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a></td></tr>
<tr class="memdesc:a24d0627ba8213afe1ec4ebeb4508e8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of arc flow cost <br /></td></tr>
<tr class="separator:a24d0627ba8213afe1ec4ebeb4508e8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62409402be4e4b301e1a568f99f877be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62409402be4e4b301e1a568f99f877be"></a>
typedef <a class="el" href="classMMCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a></td></tr>
<tr class="memdesc:a62409402be4e4b301e1a568f99f877be"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of costs <br /></td></tr>
<tr class="separator:a62409402be4e4b301e1a568f99f877be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07dbefeeb08c3f63073622411893eb76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07dbefeeb08c3f63073622411893eb76"></a>
typedef const <a class="el" href="classMMCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a07dbefeeb08c3f63073622411893eb76">cCNumber</a></td></tr>
<tr class="memdesc:a07dbefeeb08c3f63073622411893eb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only cost <br /></td></tr>
<tr class="separator:a07dbefeeb08c3f63073622411893eb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab700102e9ba8bb6015be6818d4e99097"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab700102e9ba8bb6015be6818d4e99097"></a>
typedef <a class="el" href="classMMCFClass.html#a07dbefeeb08c3f63073622411893eb76">cCNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a></td></tr>
<tr class="memdesc:ab700102e9ba8bb6015be6818d4e99097"><td class="mdescLeft">&#160;</td><td class="mdescRight">read-only cost array <br /></td></tr>
<tr class="separator:ab700102e9ba8bb6015be6818d4e99097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c938aa4034d3973dab2d49d58dad74"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3c938aa4034d3973dab2d49d58dad74"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#ab3c938aa4034d3973dab2d49d58dad74">MFNumber</a></td></tr>
<tr class="memdesc:ab3c938aa4034d3973dab2d49d58dad74"><td class="mdescLeft">&#160;</td><td class="mdescRight">a Multicommodity flow variable <br /></td></tr>
<tr class="separator:ab3c938aa4034d3973dab2d49d58dad74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f96d2e8b0aa2ace8d6b89ced5b6e3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75f96d2e8b0aa2ace8d6b89ced5b6e3c"></a>
typedef <a class="el" href="classMMCFClass.html#ab3c938aa4034d3973dab2d49d58dad74">MFNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a75f96d2e8b0aa2ace8d6b89ced5b6e3c">MFRow</a></td></tr>
<tr class="memdesc:a75f96d2e8b0aa2ace8d6b89ced5b6e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of Multicommodity flows <br /></td></tr>
<tr class="separator:a75f96d2e8b0aa2ace8d6b89ced5b6e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8788972602fd12e445ce5d56a9b85108"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8788972602fd12e445ce5d56a9b85108"></a>
typedef const <a class="el" href="classMMCFClass.html#ab3c938aa4034d3973dab2d49d58dad74">MFNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a8788972602fd12e445ce5d56a9b85108">cMFNumber</a></td></tr>
<tr class="memdesc:a8788972602fd12e445ce5d56a9b85108"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only Multicommodity flow <br /></td></tr>
<tr class="separator:a8788972602fd12e445ce5d56a9b85108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c0b711d035a5acc7fb1ca683ef2de9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08c0b711d035a5acc7fb1ca683ef2de9"></a>
typedef <a class="el" href="classMMCFClass.html#a8788972602fd12e445ce5d56a9b85108">cMFNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a08c0b711d035a5acc7fb1ca683ef2de9">cMFRow</a></td></tr>
<tr class="memdesc:a08c0b711d035a5acc7fb1ca683ef2de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">read-only Multicommodity array <br /></td></tr>
<tr class="separator:a08c0b711d035a5acc7fb1ca683ef2de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ee7b3099b0bc780a6a4b43629488fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5ee7b3099b0bc780a6a4b43629488fa"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a></td></tr>
<tr class="memdesc:af5ee7b3099b0bc780a6a4b43629488fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of the objective function: has to hold sums of products of MFNumber(s) by CNumber(s) <br /></td></tr>
<tr class="separator:af5ee7b3099b0bc780a6a4b43629488fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7942d00ff59c58e29834ecb27d8efe0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7942d00ff59c58e29834ecb27d8efe0"></a>
typedef const <a class="el" href="classMMCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#ac7942d00ff59c58e29834ecb27d8efe0">cFONumber</a></td></tr>
<tr class="memdesc:ac7942d00ff59c58e29834ecb27d8efe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only o.f. value <br /></td></tr>
<tr class="separator:ac7942d00ff59c58e29834ecb27d8efe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288a17d7858455cb06f6bce13912c92c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a288a17d7858455cb06f6bce13912c92c"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a288a17d7858455cb06f6bce13912c92c">Number</a></td></tr>
<tr class="memdesc:a288a17d7858455cb06f6bce13912c92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">an "extra" variable <br /></td></tr>
<tr class="separator:a288a17d7858455cb06f6bce13912c92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31dfeace09a5b1b6c386f4ff089c8c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab31dfeace09a5b1b6c386f4ff089c8c6"></a>
typedef <a class="el" href="classMMCFClass.html#a288a17d7858455cb06f6bce13912c92c">Number</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#ab31dfeace09a5b1b6c386f4ff089c8c6">Row</a></td></tr>
<tr class="memdesc:ab31dfeace09a5b1b6c386f4ff089c8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">an "extra" variable array <br /></td></tr>
<tr class="separator:ab31dfeace09a5b1b6c386f4ff089c8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be691f75cd3c189c345700afdf3d0a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5be691f75cd3c189c345700afdf3d0a7"></a>
typedef const <a class="el" href="classMMCFClass.html#a288a17d7858455cb06f6bce13912c92c">Number</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a5be691f75cd3c189c345700afdf3d0a7">cNumber</a></td></tr>
<tr class="memdesc:a5be691f75cd3c189c345700afdf3d0a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only Number <br /></td></tr>
<tr class="separator:a5be691f75cd3c189c345700afdf3d0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8960d4c24353408bc1a1da1153cd68e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8960d4c24353408bc1a1da1153cd68e"></a>
typedef <a class="el" href="classMMCFClass.html#a5be691f75cd3c189c345700afdf3d0a7">cNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#aa8960d4c24353408bc1a1da1153cd68e">cRow</a></td></tr>
<tr class="memdesc:aa8960d4c24353408bc1a1da1153cd68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">read-only Number array <br /></td></tr>
<tr class="separator:aa8960d4c24353408bc1a1da1153cd68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a845e36f8b03d595d20aed61ba2ff5c96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a845e36f8b03d595d20aed61ba2ff5c96"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MMCFClass</b> (void)</td></tr>
<tr class="separator:a845e36f8b03d595d20aed61ba2ff5c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Other initializations</div></td></tr>
<tr class="memitem:a2a495450fc4f5001d58cc86799027d62"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a2a495450fc4f5001d58cc86799027d62">SetMMCFLog</a> (ostream *outs=0, const char lvl=0)</td></tr>
<tr class="separator:a2a495450fc4f5001d58cc86799027d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08dba288656dca0fc2151a2c0e20d5fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a08dba288656dca0fc2151a2c0e20d5fe">SetMMCFTime</a> (bool TimeIt=true)</td></tr>
<tr class="separator:a08dba288656dca0fc2151a2c0e20d5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91731d8dbe8959d097ff4d159d1e395f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91731d8dbe8959d097ff4d159d1e395f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>SetOptEps</b> (const double OE=0)</td></tr>
<tr class="separator:a91731d8dbe8959d097ff4d159d1e395f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301adeb64435f686d29925b692234390"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a301adeb64435f686d29925b692234390">SetFsbEps</a> (const double FE=0)</td></tr>
<tr class="memdesc:a301adeb64435f686d29925b692234390"><td class="mdescLeft">&#160;</td><td class="mdescRight">In many cases, only an "approximate" solution of the problem is possible; alternatively, only an "approximate" solution may be required for the purposes of the caller (in order to save time).  <a href="#a301adeb64435f686d29925b692234390">More...</a><br /></td></tr>
<tr class="separator:a301adeb64435f686d29925b692234390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Solving the problem</div></td></tr>
<tr class="memitem:a461cba3e179b5acc85b7b6a036ac3ba7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a461cba3e179b5acc85b7b6a036ac3ba7"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>SetSubP</b> (<a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> ws=Inf&lt; <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())</td></tr>
<tr class="separator:a461cba3e179b5acc85b7b6a036ac3ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf904d59c12da1f3c30b92ab1c5971fb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMMCFClass.html#abb6773f431411c0d0d8b70566df738f3">MMCFStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#acf904d59c12da1f3c30b92ab1c5971fb">SolveMMCF</a> (void)=0</td></tr>
<tr class="memdesc:acf904d59c12da1f3c30b92ab1c5971fb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMMCFClass.html#acf904d59c12da1f3c30b92ab1c5971fb" title="SolveMMCF() try to solve the current instance of the MMCF-related problem. ">SolveMMCF()</a> try to solve the current instance of the MMCF-related problem.  <a href="#acf904d59c12da1f3c30b92ab1c5971fb">More...</a><br /></td></tr>
<tr class="separator:acf904d59c12da1f3c30b92ab1c5971fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading the solution solution</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>In principle, whatever problem is solved by the actual class which implements the interface can have two "kinds" of solutions, i.e., primal and dual ones.</p>
<p>If the problem is an LP (or, more in general, a problem with no duality gap), then the corresponding primal and dual objective function values will be the same, but in general this may not happen.</p>
<p>The solvers may be able to provide multiple (almost-)optimal primal and/or dual solutions.</p>
<p>If the problem is decomposable, then the set of (primal and dual) variables can be partitioned into disjoint subsets. Hence, each (primal and dual) solution can be seen as the composition of solutions for the subproblems, and the user can ask for each sub-solution separatedly. However, no assumption here is done on how the flow and extra variables are partitioned, so each solution for one subproblem is treated as a "full" primal/dual solution (although it will be a "very sparse" one). Obviously, querying solution information for the ws-th subproblem (after a call to SetSubP( ws )) can be done <em>only</em> after that <a class="el" href="classMMCFClass.html#acf904d59c12da1f3c30b92ab1c5971fb" title="SolveMMCF() try to solve the current instance of the MMCF-related problem. ">SolveMMCF()</a> has been called with that setting in effect, or with SetSubP( Inf&lt;Index&gt;() ) in effect.</p>
<p>Often, as a by-product of the solution of a MMCF-related problem, an Upper/Lower Bound on the value of the solution can be obtained. Typically, any primal/dual feasible solution provides such a bound: however, note that the idea here is that "feasible" means "for the whole problem", as opposed to the fact that the prima/dual solutions returned by the solvers can be feasible only for a relaxation of the "whole problem". For instance, when solving a flow decomposition of MMCF, the unfeasible flow solution might be heuristically turned into a feasible multicommodity flow, while when solving a Fixed Charge MMCF a feasible solution is easily obtained from a feasible flow by just rounding up the fractional design veriables). </p>
</div></td></tr>
<tr class="memitem:a5fc7648607074d2afbcc5dc827d6a0f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fc7648607074d2afbcc5dc827d6a0f1"></a>
virtual <a class="el" href="classMMCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetPVal</b> (void)=0</td></tr>
<tr class="separator:a5fc7648607074d2afbcc5dc827d6a0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43b4696f9396a82a76423603083050a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMMCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#ad43b4696f9396a82a76423603083050a">GetDVal</a> (void)=0</td></tr>
<tr class="memdesc:ad43b4696f9396a82a76423603083050a"><td class="mdescLeft">&#160;</td><td class="mdescRight">These methods must return the objective function value, respectively, of the primal and dual "optimal" (whatever this means for the actual solver) solutions returned by Get[P/D]Sol() [see below].  <a href="#ad43b4696f9396a82a76423603083050a">More...</a><br /></td></tr>
<tr class="separator:ad43b4696f9396a82a76423603083050a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d79a177b65fe235267b7d95d51c0dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5d79a177b65fe235267b7d95d51c0dd"></a>
virtual <a class="el" href="classMMCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetUpprBnd</b> (bool &amp;HvSol)</td></tr>
<tr class="separator:af5d79a177b65fe235267b7d95d51c0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a89c607fa04a6e153ca0a766cad33d3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMMCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a3a89c607fa04a6e153ca0a766cad33d3">GetLwrBnd</a> (bool &amp;HvSol)</td></tr>
<tr class="memdesc:a3a89c607fa04a6e153ca0a766cad33d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">These methods have to return any known Upper/Lower Bound on the optimal value of the "whole" problem (+/-INF are clearly always a possibility).  <a href="#a3a89c607fa04a6e153ca0a766cad33d3">More...</a><br /></td></tr>
<tr class="separator:a3a89c607fa04a6e153ca0a766cad33d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44aed2d5f175a0159ab324856dd99150"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44aed2d5f175a0159ab324856dd99150"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>SetFlwSol</b> (<a class="el" href="classMMCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a> Flw=0, <a class="el" href="classMMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> Bse=0, <a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> wf=Inf&lt; <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())</td></tr>
<tr class="separator:a44aed2d5f175a0159ab324856dd99150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8353eb3c154e09583fc4d552990667"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a8353eb3c154e09583fc4d552990667"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>SetMFlwSol</b> (<a class="el" href="classMMCFClass.html#a75f96d2e8b0aa2ace8d6b89ced5b6e3c">MFRow</a> Flw=0, <a class="el" href="classMMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> Bse=0, <a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> wf=Inf&lt; <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())</td></tr>
<tr class="separator:a4a8353eb3c154e09583fc4d552990667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa165f6569015fd4129d20fa0d5bba6b4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#aa165f6569015fd4129d20fa0d5bba6b4">SetXtrSol</a> (<a class="el" href="classMMCFClass.html#ab31dfeace09a5b1b6c386f4ff089c8c6">Row</a> Xtr=0, <a class="el" href="classMMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> Bse=0)</td></tr>
<tr class="memdesc:aa165f6569015fd4129d20fa0d5bba6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set[M]FlwSol() and <a class="el" href="classMMCFClass.html#aa165f6569015fd4129d20fa0d5bba6b4" title="Set[M]FlwSol() and SetXtrSol() are meant to pass to the object pointers to the memory where (respecti...">SetXtrSol()</a> are meant to pass to the object pointers to the memory where (respectively) a flow solution and an extra variables solution (the "primal information") have to be, along with "instructions" about their "format".  <a href="#aa165f6569015fd4129d20fa0d5bba6b4">More...</a><br /></td></tr>
<tr class="separator:aa165f6569015fd4129d20fa0d5bba6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb8e1a268018e2ce7129bd5dcb9ed4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafb8e1a268018e2ce7129bd5dcb9ed4e"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetPSol</b> (void)=0</td></tr>
<tr class="separator:aafb8e1a268018e2ce7129bd5dcb9ed4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ded411dcade8d0196de0b5afd9c1ac"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#ae2ded411dcade8d0196de0b5afd9c1ac">GetUBSol</a> (void)</td></tr>
<tr class="memdesc:ae2ded411dcade8d0196de0b5afd9c1ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called <em>after</em> <a class="el" href="classMMCFClass.html#acf904d59c12da1f3c30b92ab1c5971fb" title="SolveMMCF() try to solve the current instance of the MMCF-related problem. ">SolveMMCF()</a> and Set[[M]Flw/Xtr]Sol(), these methods write in the memory provided for the purpose respectively the "optimal" primal solution of the problem and the primal solution of the "whole" problem corresponding to the Upper Bound, according to the required "style" [see Set[[M]Flw/Xtr]Sol()].  <a href="#ae2ded411dcade8d0196de0b5afd9c1ac">More...</a><br /></td></tr>
<tr class="separator:ae2ded411dcade8d0196de0b5afd9c1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c90450cc40400f4161cc4cd3fe4ea24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c90450cc40400f4161cc4cd3fe4ea24"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>PSolIsFNumber</b> (void)</td></tr>
<tr class="separator:a4c90450cc40400f4161cc4cd3fe4ea24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e0d46bb7c4594fe46e9e490e81c806"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#af2e0d46bb7c4594fe46e9e490e81c806">UBSolIsFNumber</a> (void)</td></tr>
<tr class="memdesc:af2e0d46bb7c4594fe46e9e490e81c806"><td class="mdescLeft">&#160;</td><td class="mdescRight">These methods tell if the primal solutions (to be retrieved with GetPSol()) and the upper bound solutions (to be retrieved with <a class="el" href="classMMCFClass.html#ae2ded411dcade8d0196de0b5afd9c1ac" title="Called after SolveMMCF() and Set[[M]Flw/Xtr]Sol(), these methods write in the memory provided for the...">GetUBSol()</a>) are of type `FNumber' rather than `MFNumber'.  <a href="#af2e0d46bb7c4594fe46e9e490e81c806">More...</a><br /></td></tr>
<tr class="separator:af2e0d46bb7c4594fe46e9e490e81c806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad1c547840cdcbacfac6ff861b90308"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ad1c547840cdcbacfac6ff861b90308"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>SetNPot</b> (<a class="el" href="classMMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a> NPt=0, <a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> wd=Inf&lt; <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())</td></tr>
<tr class="separator:a4ad1c547840cdcbacfac6ff861b90308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a981e3087bad0ec614e9bf65f71944"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5a981e3087bad0ec614e9bf65f71944"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>SetRCst</b> (<a class="el" href="classMMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a> RCs=0, <a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> wd=Inf&lt; <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())</td></tr>
<tr class="separator:aa5a981e3087bad0ec614e9bf65f71944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69cc3ca347071948f12ad0fb8fe56c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac69cc3ca347071948f12ad0fb8fe56c7"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>SetMCCst</b> (<a class="el" href="classMMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a> MCs=0)</td></tr>
<tr class="separator:ac69cc3ca347071948f12ad0fb8fe56c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59d4824b69fb63f01fb9324e65ea55e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa59d4824b69fb63f01fb9324e65ea55e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>SetXtrRC</b> (<a class="el" href="classMMCFClass.html#ab31dfeace09a5b1b6c386f4ff089c8c6">Row</a> XRC=0)</td></tr>
<tr class="separator:aa59d4824b69fb63f01fb9324e65ea55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b8040a69417e6aa5a6562ab7f78f15"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a84b8040a69417e6aa5a6562ab7f78f15">SetXtrDV</a> (<a class="el" href="classMMCFClass.html#ab31dfeace09a5b1b6c386f4ff089c8c6">Row</a> XDV=0)</td></tr>
<tr class="memdesc:a84b8040a69417e6aa5a6562ab7f78f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">SetNPot(), SetRCst(), SetMCCst(), SetXtrRC() and <a class="el" href="classMMCFClass.html#a84b8040a69417e6aa5a6562ab7f78f15" title="SetNPot(), SetRCst(), SetMCCst(), SetXtrRC() and SetXtrDV() are meant to pass to the object pointers ...">SetXtrDV()</a> are meant to pass to the object pointers to the memory where, respectively,.  <a href="#a84b8040a69417e6aa5a6562ab7f78f15">More...</a><br /></td></tr>
<tr class="separator:a84b8040a69417e6aa5a6562ab7f78f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f451f23e0c6c28b032c38fcab180528"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f451f23e0c6c28b032c38fcab180528"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetDSol</b> (void)=0</td></tr>
<tr class="separator:a4f451f23e0c6c28b032c38fcab180528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d0cdad147df2c60745d70101a24dae"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a18d0cdad147df2c60745d70101a24dae">GetLBSol</a> (void)</td></tr>
<tr class="memdesc:a18d0cdad147df2c60745d70101a24dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called <em>after</em> <a class="el" href="classMMCFClass.html#acf904d59c12da1f3c30b92ab1c5971fb" title="SolveMMCF() try to solve the current instance of the MMCF-related problem. ">SolveMMCF()</a> and Set[NPot/RCst/MCCst/XtrRC/XtrDV](), these methods write in the memory provided for the purpose respectively the "optimal" dual solution of the problem and the dual solution of the "whole" problem corresponding to the Lower Bound, according to the required "style".  <a href="#a18d0cdad147df2c60745d70101a24dae">More...</a><br /></td></tr>
<tr class="separator:a18d0cdad147df2c60745d70101a24dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4a28123233c6452569c63d9955eb11"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMMCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a5f4a28123233c6452569c63d9955eb11">CostOf</a> (void)=0</td></tr>
<tr class="memdesc:a5f4a28123233c6452569c63d9955eb11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates and return the cost of the primal or dual solutions provided by the Set****() methods above.  <a href="#a5f4a28123233c6452569c63d9955eb11">More...</a><br /></td></tr>
<tr class="separator:a5f4a28123233c6452569c63d9955eb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2e522d2dae9a64d8370a69086c08de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf2e522d2dae9a64d8370a69086c08de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>TimeMMCF</b> (double &amp;t_us, double &amp;t_ss)</td></tr>
<tr class="separator:aaf2e522d2dae9a64d8370a69086c08de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744bfe60e68ceb8b0678149c4a3ed593"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a744bfe60e68ceb8b0678149c4a3ed593">TimeMMCF</a> (void)</td></tr>
<tr class="memdesc:a744bfe60e68ceb8b0678149c4a3ed593"><td class="mdescLeft">&#160;</td><td class="mdescRight">If these methods are called within any of the methods of the class that are "actively timed" (this depends on the subclasses), they return respectively the user and sistem time and the total time (in seconds) since the start of that method.  <a href="#a744bfe60e68ceb8b0678149c4a3ed593">More...</a><br /></td></tr>
<tr class="separator:a744bfe60e68ceb8b0678149c4a3ed593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading the data of the problem</div></td></tr>
<tr class="memitem:a908730483d3ea6fc4bb64b282db04a7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a908730483d3ea6fc4bb64b282db04a7e"></a>
<a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NrComm</b> (void)</td></tr>
<tr class="separator:a908730483d3ea6fc4bb64b282db04a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5747154546dd9f0094d35d0e6ac2579"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5747154546dd9f0094d35d0e6ac2579"></a>
<a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NrNodes</b> (void)</td></tr>
<tr class="separator:ae5747154546dd9f0094d35d0e6ac2579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0395be6c7758dc41e1ff33151f7caf62"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0395be6c7758dc41e1ff33151f7caf62"></a>
<a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NrArcs</b> (void)</td></tr>
<tr class="separator:a0395be6c7758dc41e1ff33151f7caf62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b05c035560748336ddf3ffa0de8b726"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b05c035560748336ddf3ffa0de8b726"></a>
virtual <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NrXtrVrs</b> (void)</td></tr>
<tr class="separator:a5b05c035560748336ddf3ffa0de8b726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133fccc13b4d6cd23ceabda595e67e50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a133fccc13b4d6cd23ceabda595e67e50"></a>
virtual <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NrXtrCnst</b> (void)</td></tr>
<tr class="separator:a133fccc13b4d6cd23ceabda595e67e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45805e71518b0cf240a9abd17fe56e30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45805e71518b0cf240a9abd17fe56e30"></a>
virtual <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NrSubP</b> (void)</td></tr>
<tr class="separator:a45805e71518b0cf240a9abd17fe56e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321ae32303b0744e905e25a15900700a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a321ae32303b0744e905e25a15900700a">GetCosts</a> (<a class="el" href="classMMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a> Csts, <a class="el" href="classMMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> strt=0, <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=Inf&lt; <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:a321ae32303b0744e905e25a15900700a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the costs of the flow variables in the MMCF instance.  <a href="#a321ae32303b0744e905e25a15900700a">More...</a><br /></td></tr>
<tr class="separator:a321ae32303b0744e905e25a15900700a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0752a5d77a50de3750d1031e8bcfb207"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a0752a5d77a50de3750d1031e8bcfb207">GetXtrCsts</a> (<a class="el" href="classMMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a> XtrCs, <a class="el" href="classMMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> strt=0, <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=Inf&lt; <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())</td></tr>
<tr class="separator:a0752a5d77a50de3750d1031e8bcfb207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c152b98641e97d5949b0fca8cbbb21"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a70c152b98641e97d5949b0fca8cbbb21">GetICaps</a> (<a class="el" href="classMMCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a> ICps, <a class="el" href="classMMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> strt=0, <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=Inf&lt; <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:a70c152b98641e97d5949b0fca8cbbb21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the Individual Capacities of the flow variables in the MMCF instance.  <a href="#a70c152b98641e97d5949b0fca8cbbb21">More...</a><br /></td></tr>
<tr class="separator:a70c152b98641e97d5949b0fca8cbbb21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4309ff3df4a4733ed4e568a99fdbe2a5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a4309ff3df4a4733ed4e568a99fdbe2a5">GetMCaps</a> (<a class="el" href="classMMCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a> MCps, <a class="el" href="classMMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> strt=0, <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=Inf&lt; <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:a4309ff3df4a4733ed4e568a99fdbe2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the Mutual Capacities of the flow variables in the MMCF instance.  <a href="#a4309ff3df4a4733ed4e568a99fdbe2a5">More...</a><br /></td></tr>
<tr class="separator:a4309ff3df4a4733ed4e568a99fdbe2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Adding/removing/changing data</div></td></tr>
<tr class="memitem:ab9538ab2a11e9a86271120ab2edc4a66"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#ab9538ab2a11e9a86271120ab2edc4a66">ChgCosts</a> (<a class="el" href="classMMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a> NwCsts, <a class="el" href="classMMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> strt=0, <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=Inf&lt; <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:ab9538ab2a11e9a86271120ab2edc4a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the costs of the flow variables in the MMCF instance.  <a href="#ab9538ab2a11e9a86271120ab2edc4a66">More...</a><br /></td></tr>
<tr class="separator:ab9538ab2a11e9a86271120ab2edc4a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268bacf3429429242d80a5f44cdc9102"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a268bacf3429429242d80a5f44cdc9102">ChgXtrCsts</a> (<a class="el" href="classMMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a> NwXtrCs, <a class="el" href="classMMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> strt=0, <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=Inf&lt; <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())</td></tr>
<tr class="separator:a268bacf3429429242d80a5f44cdc9102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b366b2ac8d46548b587f67c64e4eb8f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a1b366b2ac8d46548b587f67c64e4eb8f">ChgICaps</a> (<a class="el" href="classMMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> NwICps, <a class="el" href="classMMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> strt=0, <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=Inf&lt; <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:a1b366b2ac8d46548b587f67c64e4eb8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the Individual Capacities of the flow variables in the MMCF instance.  <a href="#a1b366b2ac8d46548b587f67c64e4eb8f">More...</a><br /></td></tr>
<tr class="separator:a1b366b2ac8d46548b587f67c64e4eb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d35cf8474371a0ce7efdce0ace2069"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a66d35cf8474371a0ce7efdce0ace2069">ChgMCaps</a> (<a class="el" href="classMMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> NwMCps, <a class="el" href="classMMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> strt=0, <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=Inf&lt; <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:a66d35cf8474371a0ce7efdce0ace2069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the Mutual Capacities of the flow variables in the MMCF instance.  <a href="#a66d35cf8474371a0ce7efdce0ace2069">More...</a><br /></td></tr>
<tr class="separator:a66d35cf8474371a0ce7efdce0ace2069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68bed0a51d8c555d643ae305d1ce6c8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#ab68bed0a51d8c555d643ae305d1ce6c8">ChgIntVar</a> (<a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> k=Inf&lt; <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;(), bool IntVld=true, <a class="el" href="classMMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> strt=0, <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=Inf&lt; <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())=0</td></tr>
<tr class="memdesc:ab68bed0a51d8c555d643ae305d1ce6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the status of (a subset of) the - flow and extra - variables of the problem in terms of the integrality constraints imposed upon them.  <a href="#ab68bed0a51d8c555d643ae305d1ce6c8">More...</a><br /></td></tr>
<tr class="separator:ab68bed0a51d8c555d643ae305d1ce6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4f17eb90ba6b8021ed8ca15ab8daca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e4f17eb90ba6b8021ed8ca15ab8daca"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>CloseArcs</b> (<a class="el" href="classMMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> whch)=0</td></tr>
<tr class="separator:a6e4f17eb90ba6b8021ed8ca15ab8daca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9ca1c708fde6eb68211a2edd0c7e06"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#acb9ca1c708fde6eb68211a2edd0c7e06">OpenArcs</a> (<a class="el" href="classMMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> whch)=0</td></tr>
<tr class="memdesc:acb9ca1c708fde6eb68211a2edd0c7e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Respectively "Close" and "Open" the arcs indicated in whch, that must point to a vector of indices in [ 0 .  <a href="#acb9ca1c708fde6eb68211a2edd0c7e06">More...</a><br /></td></tr>
<tr class="separator:acb9ca1c708fde6eb68211a2edd0c7e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ed6b704e265ab5a1a093cb9d3507dd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a49ed6b704e265ab5a1a093cb9d3507dd">AddExtraVars</a> (<a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> NXV, <a class="el" href="classMMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a> XCst=0, <a class="el" href="classMMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> XUb=0, <a class="el" href="classMMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> XLb=0, bool IntVar=false, <a class="el" href="classMMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0)</td></tr>
<tr class="separator:a49ed6b704e265ab5a1a093cb9d3507dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc3ace6c36aa14e5713c2e2788df045"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#affc3ace6c36aa14e5713c2e2788df045">AddExtraConstr</a> (<a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> NXC, int *IBeg, int *Indx, double *Vals, <a class="el" href="classMMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> XLr=0, <a class="el" href="classMMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> XUr=0)</td></tr>
<tr class="separator:affc3ace6c36aa14e5713c2e2788df045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destructor</div></td></tr>
<tr class="memitem:a0fa9f0fcc2f5f5038a4f3b80fb743456"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0fa9f0fcc2f5f5038a4f3b80fb743456"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~MMCFClass</b> ()</td></tr>
<tr class="separator:a0fa9f0fcc2f5f5038a4f3b80fb743456"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Protected fields of the class</div></td></tr>
<tr class="memitem:aa8e4c4bb951b34aca6292f6bbebac38f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8e4c4bb951b34aca6292f6bbebac38f"></a>
<a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#aa8e4c4bb951b34aca6292f6bbebac38f">NArcs</a></td></tr>
<tr class="memdesc:aa8e4c4bb951b34aca6292f6bbebac38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of Arcs of the graph. <br /></td></tr>
<tr class="separator:aa8e4c4bb951b34aca6292f6bbebac38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17c0b316f9e362ddc529b893cbcae45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae17c0b316f9e362ddc529b893cbcae45"></a>
<a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#ae17c0b316f9e362ddc529b893cbcae45">NNodes</a></td></tr>
<tr class="memdesc:ae17c0b316f9e362ddc529b893cbcae45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of Nodes of the graph. <br /></td></tr>
<tr class="separator:ae17c0b316f9e362ddc529b893cbcae45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba4b0ec3dedeba97383759741c1cf56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adba4b0ec3dedeba97383759741c1cf56"></a>
<a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#adba4b0ec3dedeba97383759741c1cf56">NComm</a></td></tr>
<tr class="memdesc:adba4b0ec3dedeba97383759741c1cf56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of Commodities. <br /></td></tr>
<tr class="separator:adba4b0ec3dedeba97383759741c1cf56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde6334d6311a01717d396d4bdad9fd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afde6334d6311a01717d396d4bdad9fd6"></a>
<a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#afde6334d6311a01717d396d4bdad9fd6">XtrVrs</a></td></tr>
<tr class="memdesc:afde6334d6311a01717d396d4bdad9fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of "eXtra" Variables. <br /></td></tr>
<tr class="separator:afde6334d6311a01717d396d4bdad9fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8436a963759b48fa5db43d2f026aaaf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8436a963759b48fa5db43d2f026aaaf"></a>
<a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#ab8436a963759b48fa5db43d2f026aaaf">XtrCnst</a></td></tr>
<tr class="memdesc:ab8436a963759b48fa5db43d2f026aaaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of "eXtra" Constraints. <br /></td></tr>
<tr class="separator:ab8436a963759b48fa5db43d2f026aaaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6595756f0dcf54786c755d03be391ed9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6595756f0dcf54786c755d03be391ed9"></a>
<a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a6595756f0dcf54786c755d03be391ed9">NSubPr</a></td></tr>
<tr class="memdesc:a6595756f0dcf54786c755d03be391ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">into how many SubProblems the MMCF can be divided <br /></td></tr>
<tr class="separator:a6595756f0dcf54786c755d03be391ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6105b520fb6788b8487a0ab7aa5dc809"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6105b520fb6788b8487a0ab7aa5dc809"></a>
<a class="el" href="classMMCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a6105b520fb6788b8487a0ab7aa5dc809">OptEps</a></td></tr>
<tr class="memdesc:a6105b520fb6788b8487a0ab7aa5dc809"><td class="mdescLeft">&#160;</td><td class="mdescRight">an OptEps-optimal solution is required <br /></td></tr>
<tr class="separator:a6105b520fb6788b8487a0ab7aa5dc809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f91876360c7d17e55f2c861c5bda37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92f91876360c7d17e55f2c861c5bda37"></a>
<a class="el" href="classMMCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a92f91876360c7d17e55f2c861c5bda37">FsbEps</a></td></tr>
<tr class="memdesc:a92f91876360c7d17e55f2c861c5bda37"><td class="mdescLeft">&#160;</td><td class="mdescRight">FsbEps is the max allowed violation of constraints. <br /></td></tr>
<tr class="separator:a92f91876360c7d17e55f2c861c5bda37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc5b87be358c16e23f5f102c6184e1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8dc5b87be358c16e23f5f102c6184e1a"></a>
<a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a8dc5b87be358c16e23f5f102c6184e1a">WhchSP</a></td></tr>
<tr class="memdesc:a8dc5b87be358c16e23f5f102c6184e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">WhchSP tells which subproblem is one referring to. <br /></td></tr>
<tr class="separator:a8dc5b87be358c16e23f5f102c6184e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a6e3f152fd6f67200a1555f449b009"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0a6e3f152fd6f67200a1555f449b009"></a>
<a class="el" href="classMMCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#ab0a6e3f152fd6f67200a1555f449b009">FSol</a></td></tr>
<tr class="memdesc:ab0a6e3f152fd6f67200a1555f449b009"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the memory of the Flow Solution <br /></td></tr>
<tr class="separator:ab0a6e3f152fd6f67200a1555f449b009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22af0169bcea0710464e02b31b3d14c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22af0169bcea0710464e02b31b3d14c3"></a>
<a class="el" href="classMMCFClass.html#a75f96d2e8b0aa2ace8d6b89ced5b6e3c">MFRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a22af0169bcea0710464e02b31b3d14c3">MFSol</a></td></tr>
<tr class="memdesc:a22af0169bcea0710464e02b31b3d14c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">as above, but of the MFNumber type <br /></td></tr>
<tr class="separator:a22af0169bcea0710464e02b31b3d14c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b270fcf952040ec5743e3f85bc28ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85b270fcf952040ec5743e3f85bc28ad"></a>
<a class="el" href="classMMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a85b270fcf952040ec5743e3f85bc28ad">FBse</a></td></tr>
<tr class="memdesc:a85b270fcf952040ec5743e3f85bc28ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">if FBse != 0, then it must be "sparse" <br /></td></tr>
<tr class="separator:a85b270fcf952040ec5743e3f85bc28ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff5a7dc69e2be0702f411bc1c7d2db7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ff5a7dc69e2be0702f411bc1c7d2db7"></a>
<a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a4ff5a7dc69e2be0702f411bc1c7d2db7">WhchFS</a></td></tr>
<tr class="memdesc:a4ff5a7dc69e2be0702f411bc1c7d2db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">WhchFS tells its "type" of the Flow Solution. <br /></td></tr>
<tr class="separator:a4ff5a7dc69e2be0702f411bc1c7d2db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a6230ab7f8a54ab19b34fccfe774f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3a6230ab7f8a54ab19b34fccfe774f6"></a>
<a class="el" href="classMMCFClass.html#ab31dfeace09a5b1b6c386f4ff089c8c6">Row</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#af3a6230ab7f8a54ab19b34fccfe774f6">XSol</a></td></tr>
<tr class="memdesc:af3a6230ab7f8a54ab19b34fccfe774f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the memory of the "extra" solution <br /></td></tr>
<tr class="separator:af3a6230ab7f8a54ab19b34fccfe774f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c544a08cfb19d3ef88e4b9f2af848fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c544a08cfb19d3ef88e4b9f2af848fe"></a>
<a class="el" href="classMMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a5c544a08cfb19d3ef88e4b9f2af848fe">XBse</a></td></tr>
<tr class="memdesc:a5c544a08cfb19d3ef88e4b9f2af848fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">if XBse != 0, then it must be "sparse" <br /></td></tr>
<tr class="separator:a5c544a08cfb19d3ef88e4b9f2af848fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386171e84cafd415ad24d6ca2deefaa4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a386171e84cafd415ad24d6ca2deefaa4"></a>
<a class="el" href="classMMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a386171e84cafd415ad24d6ca2deefaa4">NPot</a></td></tr>
<tr class="memdesc:a386171e84cafd415ad24d6ca2deefaa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the memory of the Node Potentials (dual costs for the Flow Conservation constraints (1.k)) <br /></td></tr>
<tr class="separator:a386171e84cafd415ad24d6ca2deefaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7814693a25c7da0c76af3c4073c164a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7814693a25c7da0c76af3c4073c164a6"></a>
<a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a7814693a25c7da0c76af3c4073c164a6">WhchNP</a></td></tr>
<tr class="memdesc:a7814693a25c7da0c76af3c4073c164a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">WhchNP tells its "type" of the Node Potentials. <br /></td></tr>
<tr class="separator:a7814693a25c7da0c76af3c4073c164a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fe86a6551657d638974e66739231f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47fe86a6551657d638974e66739231f9"></a>
<a class="el" href="classMMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a47fe86a6551657d638974e66739231f9">RCst</a></td></tr>
<tr class="memdesc:a47fe86a6551657d638974e66739231f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the memory of the flow reduced costs (dual costs for the bound constraints (2.k)) <br /></td></tr>
<tr class="separator:a47fe86a6551657d638974e66739231f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11d297d597683ffc619d0ca2cfaec20"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa11d297d597683ffc619d0ca2cfaec20"></a>
<a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#aa11d297d597683ffc619d0ca2cfaec20">WhchRC</a></td></tr>
<tr class="memdesc:aa11d297d597683ffc619d0ca2cfaec20"><td class="mdescLeft">&#160;</td><td class="mdescRight">WhchRC tells its "type" of the flow reduced costs. <br /></td></tr>
<tr class="separator:aa11d297d597683ffc619d0ca2cfaec20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a23d002bbd7625ee9d9254ac7ce2d7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a23d002bbd7625ee9d9254ac7ce2d7e"></a>
<a class="el" href="classMMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a1a23d002bbd7625ee9d9254ac7ce2d7e">MCst</a></td></tr>
<tr class="memdesc:a1a23d002bbd7625ee9d9254ac7ce2d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the memory of the dual costs for the Mutual Capacity constraints (3) <br /></td></tr>
<tr class="separator:a1a23d002bbd7625ee9d9254ac7ce2d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0667655c892194283e63213554e43f2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0667655c892194283e63213554e43f2a"></a>
<a class="el" href="classMMCFClass.html#ab31dfeace09a5b1b6c386f4ff089c8c6">Row</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a0667655c892194283e63213554e43f2a">XtDV</a></td></tr>
<tr class="memdesc:a0667655c892194283e63213554e43f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the memory of the dual costs for the "extra" constraints (4) <br /></td></tr>
<tr class="separator:a0667655c892194283e63213554e43f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f72a653731ceb18faa9c86c23f97820"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f72a653731ceb18faa9c86c23f97820"></a>
<a class="el" href="classMMCFClass.html#ab31dfeace09a5b1b6c386f4ff089c8c6">Row</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a6f72a653731ceb18faa9c86c23f97820">XtRC</a></td></tr>
<tr class="memdesc:a6f72a653731ceb18faa9c86c23f97820"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the memory of the reduced costs for the "extra" variables (dual costs for constraints (5)) <br /></td></tr>
<tr class="separator:a6f72a653731ceb18faa9c86c23f97820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9cdb58d82795a62dbf95753f4d021a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a9cdb58d82795a62dbf95753f4d021a"></a>
ostream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#a2a9cdb58d82795a62dbf95753f4d021a">MMCFLog</a></td></tr>
<tr class="memdesc:a2a9cdb58d82795a62dbf95753f4d021a"><td class="mdescLeft">&#160;</td><td class="mdescRight">the output stream object <br /></td></tr>
<tr class="separator:a2a9cdb58d82795a62dbf95753f4d021a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee648ba5b533b2291d768f92c02a0a89"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee648ba5b533b2291d768f92c02a0a89"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#aee648ba5b533b2291d768f92c02a0a89">MMCFLLvl</a></td></tr>
<tr class="memdesc:aee648ba5b533b2291d768f92c02a0a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">the "level of verbosity" of the log <br /></td></tr>
<tr class="separator:aee648ba5b533b2291d768f92c02a0a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16905d1abf9f3a831674e5b22e870f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab16905d1abf9f3a831674e5b22e870f2"></a>
OPTtimers *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMMCFClass.html#ab16905d1abf9f3a831674e5b22e870f2">MMCFt</a></td></tr>
<tr class="memdesc:ab16905d1abf9f3a831674e5b22e870f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">mainly the MMCFSolve() time, probably <br /></td></tr>
<tr class="separator:ab16905d1abf9f3a831674e5b22e870f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class defines a standard abstract interface for solvers of (generalized) Multicommodity Min-Cost Flow problems, i.e., problems of the form. </p>
<p>min Sum{k = 0 .. K - 1} C[ k ] * X[ k ] + C[ K ] * Y s.t.</p>
<p>(1.k) E * X[ k ] = b[ k ] k = 0 .. K - 1</p>
<p>(2.k) 0 &lt;= X[ k ] &lt;= U[ k ] k = 0 .. K - 1</p>
<p>(3) Sum{k = 0 .. K - 1} X[ i ] &lt;= U</p>
<p>(4) b[ K ] &lt;= Sum{k = 0 .. K - 1} A[ k ] * X[ k ]</p><ul>
<li>A[ K ] * Y &lt;= b[ K + 1 ]</li>
</ul>
<p>(5) U[ K ] &lt;= Y &lt;= U[ K + 1 ]</p>
<p>X[ k ] are the flow variables, one for each commodity; Y[] are the "extra" variables. (1.k) and (2.k) are the Flow Conservation and Upper Bound constraints for commodity k, respectively. E is the node-arc incidence matrix of an underlying graph G(N, A), which is common to all commodities; however, each commodity can in principle flow only on a subset A[ k ] of the arcs A, and therefore it is in fact defined only on a subgraph G[ k ](N[ k ], A[ k ]), where N[ k ] is the subset of N touched by the arcs in A[ k ]. (3) are the Mutual Capacity constraints, linking the (otherwise disjoint) different commodities; (4), that may be empty, are other "extra" constraints, which may be:</p><ul>
<li>commodity-separable, i.e., for some constraint i there exists a commodity k such that A[ h ][ i ] == 0 for all h != k, but not network-type;</li>
<li>other linking constraints between differnet commodities;</li>
<li>constraints linking some (or all) of the commodities to the extra (non-flow) variables Y;</li>
<li>constraints involving only the extra (non-flow) variables Y. (5) are bound constraints on the extra variables.</li>
</ul>
<p>Actually, the cost function and/or the extra constraints may also be nonlinear and/or nonseparable; however, the interface does not set any standard for this, assuming (temporarly) that the nonlinearities can remain "hidden".</p>
<p>Both (subsets of) the flow variables and (subsets of) the extra variables can be constrained to be integer-valued.</p>
<p>Examples of problems in this class are:</p><ul>
<li>the Linear Continuous Multicommodity Min Cost Flow Problem;</li>
<li>relaxations of the above, such as the Flow Relaxation (obtained relaxing the Mutual Capacity Constraints) or the Knapsack Relaxation (obtained relaxing the Flow Conservation constraints);</li>
<li>extensions of the above, like the Integer MMCF or the Fixed-Charge MMCF.</li>
</ul>
<p>The class provides support for the notion that the MMCF-related problem at hand may be separable in a certain number of independent subproblems, which typically happens in the "relaxations" cases above.</p>
<p>In all the comments below, m has to be understood as the number of arcs in the graph G (#A), n as the number of nodes in the graph G (#N) and K as the number of commodities. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="abb6773f431411c0d0d8b70566df738f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classMMCFClass.html#abb6773f431411c0d0d8b70566df738f3">MMCFStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public enum describing the possible status of the MMCF solver. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="abb6773f431411c0d0d8b70566df738f3a42e6b26684acf67af002df88a9cf997c"></a>kOK&#160;</td><td class="fielddoc">
<p>optimal solution found </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abb6773f431411c0d0d8b70566df738f3a142714524ffdfe9cfebaa1033fd1a18f"></a>kStopped&#160;</td><td class="fielddoc">
<p>optimization stopped </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abb6773f431411c0d0d8b70566df738f3a7db95dc60f32bc33a35f748f639cc6d0"></a>kUnfeasible&#160;</td><td class="fielddoc">
<p>problem is unfeasible </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abb6773f431411c0d0d8b70566df738f3a4b9de95ee3087851acd98262e09f0be8"></a>kUnbounded&#160;</td><td class="fielddoc">
<p>problem is unbounded </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abb6773f431411c0d0d8b70566df738f3aacb2c04376333850bff6fb1065c0c171"></a>kError&#160;</td><td class="fielddoc">
<p>error in the solver </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2a495450fc4f5001d58cc86799027d62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetMMCFLog </td>
          <td>(</td>
          <td class="paramtype">ostream *&#160;</td>
          <td class="paramname"><em>outs</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>lvl</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lvl</td><td>The class ouputs "log" information onto the ostream pointed by outs. lvl controls the "level of verbosity" of the code: lvl == 0 means that nothing at all is printed, and values larger than 0 mean increasing amounts of information, the specific effect of each value being derived- class-dependent. outs == 0 implies lvl == 0. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classMMCFCplex.html#a9b0577c70c2f2e78c53eca038de1b577">MMCFCplex</a>.</p>

</div>
</div>
<a class="anchor" id="a08dba288656dca0fc2151a2c0e20d5fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetMMCFTime </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>TimeIt</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TimeIt</td><td><a class="el" href="classMMCFClass.html#a08dba288656dca0fc2151a2c0e20d5fe">SetMMCFTime()</a> allocates an OPTtimers object [see OPTUtils.h] that should be used for timing the calls to relevant methods of the class. The time can be read with MMCFTime() [see below]. By default, or if SetMMCFTime( false ) is called, no timing is done. Note that, since all the relevant methods ot the class are pure virtual, <a class="el" href="classMMCFClass.html" title="This class defines a standard abstract interface for solvers of (generalized) Multicommodity Min-Cost...">MMCFClass</a> can only manage the OPTtimers object, but it is due to derived classes to actually implement the timing.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that time accumulates over the calls: calling <a class="el" href="classMMCFClass.html#a08dba288656dca0fc2151a2c0e20d5fe">SetMMCFTime()</a>, however, resets the counters, allowing to time specific groups of calls. </p>

</div>
</div>
<a class="anchor" id="a301adeb64435f686d29925b692234390"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetFsbEps </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>FE</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In many cases, only an "approximate" solution of the problem is possible; alternatively, only an "approximate" solution may be required for the purposes of the caller (in order to save time). </p>
<p>The exact meaning of "approximate" is solver-dependent, but the more common ways in which this happens are</p>
<ul>
<li>either the value of the solution is not exactly optimal;</li>
<li>or the constraints are not exactly satisfied.</li>
</ul>
<p>SetOptEps() tells that any solution that is OE-optimal w.r.t. the value of the objective function can be considered optimal. <a class="el" href="classMMCFClass.html#a301adeb64435f686d29925b692234390" title="In many cases, only an &quot;approximate&quot; solution of the problem is possible; alternatively, only an &quot;approximate&quot; solution may be required for the purposes of the caller (in order to save time). ">SetFsbEps()</a> tells that any solution where the violation of the constraints is not larger than FE can be considered feasible.</p>
<p>The exact meaning of OE and FE is not strictly imposed in the interface, but the idea is that they are relative accuracies (that is, OE == 1e-6 should roughly mean that the objectve function value must agree with the optimal value for at least about 6 decimal digits ...). </p>

</div>
</div>
<a class="anchor" id="acf904d59c12da1f3c30b92ab1c5971fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMMCFClass.html#abb6773f431411c0d0d8b70566df738f3">MMCFStatus</a> SolveMMCF </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classMMCFClass.html#acf904d59c12da1f3c30b92ab1c5971fb" title="SolveMMCF() try to solve the current instance of the MMCF-related problem. ">SolveMMCF()</a> try to solve the current instance of the MMCF-related problem. </p>
<p>Note that the meaning of "solution" may vary depending on the solver used. Some issues, such as the approximations in the value of the objective function and the satisfacion of constraints, are (partly) dealt with in the Set***Eps() methods [see above].</p>
<p>The MMCF-related problem may be decomposable into NrSubP() [see below] independent SubProblems; furthermore, it may have some "constant term" (such as those given by RHS-related terms in a Lagrangean relaxation), that is, a subproblem with constant solution. Each of these subproblems can be solved, and its results be queried, independently from the others. SetSubP( ws ) with tells that all the calls to methods that do something subproblem-specific refere to:</p>
<ul>
<li>the 0-th "constant" subproblem if ws == 0;</li>
<li>the ws-th subproblem if 1 &lt;= ws &lt;= NrSubP();</li>
<li>all the subproblems simultaneously <em>but</em> the 0-th "constant" one if ws == NrSubP() + 1;</li>
<li>all the subproblems simultaneously, <em>comprised</em> the 0-th "constant" one, if ws &gt; NrSubP() + 1 (e.g., ws == Inf&lt;Index&gt;()).</li>
</ul>
<p>If SetSubP() is <em>never</em> called, ws == Inf&lt;Index&gt;() is assumed.</p>
<p>For <a class="el" href="classMMCFClass.html#acf904d59c12da1f3c30b92ab1c5971fb" title="SolveMMCF() try to solve the current instance of the MMCF-related problem. ">SolveMMCF()</a>, for instance, 1 &lt;= ws &lt;= NrSubP() only solves the ws-th subproblem, ws == 0 only calculates the "constant", while any ws &gt; NrSubP() solves all the subproblems, calculating also the constant unless ws is exactly NrSubP() + 1.</p>
<p><a class="el" href="classMMCFClass.html#acf904d59c12da1f3c30b92ab1c5971fb" title="SolveMMCF() try to solve the current instance of the MMCF-related problem. ">SolveMMCF()</a> returns the following codes:</p>
<p>kOK if optimization has been carried out succesfully, whatever this means for the solver;</p>
<p>kStopped if optimization have been stopped before that the stopping conditions of the solver applied, e.g. because of the maximum allowed number of "iterations" have been reached; this is not necessarily an error, as it might just be required to re-call <a class="el" href="classMMCFClass.html#acf904d59c12da1f3c30b92ab1c5971fb" title="SolveMMCF() try to solve the current instance of the MMCF-related problem. ">SolveMMCF()</a> giving it more "resources" in order to solve the problem;</p>
<p>kUnfeasible if the current MMCF instance is (primal) unfeasible;</p>
<p>kUnbounded if the current MMCF instance is (primal) unbounded;</p>
<p>kError if there was an error during the optimization; this typically indicates that computation cannot be resumed, although solver-dependent ways of dealing with solver-dependent errors may exhist. </p>

</div>
</div>
<a class="anchor" id="ad43b4696f9396a82a76423603083050a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMMCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a> GetDVal </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These methods must return the objective function value, respectively, of the primal and dual "optimal" (whatever this means for the actual solver) solutions returned by Get[P/D]Sol() [see below]. </p>
<p>The ws set by SetSubP() has the same meaning as in <a class="el" href="classMMCFClass.html#acf904d59c12da1f3c30b92ab1c5971fb" title="SolveMMCF() try to solve the current instance of the MMCF-related problem. ">SolveMMCF()</a> above, i.e., for 1 &lt;= ws &lt;= NrSubP() the value of the ws-th subproblem is returned, for ws == 0 the value of the "constant" is returned and for any ws &gt; NrSubP() the total value is returned.</p>
<p>If GetPVal() returns +INF, then no feasible primal solution has been found (the primal problem is a minimization problem). Analogously, if <a class="el" href="classMMCFClass.html#ad43b4696f9396a82a76423603083050a" title="These methods must return the objective function value, respectively, of the primal and dual &quot;optimal...">GetDVal()</a> returns -INF, then no feasible dual solution has been found.</p>
<p>The solver may provide multiple primal/dual solutions, not all of which optimal and therefore with the same objective function value. Thus, Get[P/D]Val() has to be called for each different primal/dual solution extracted with Get[P/D]Sol() [see below]. In particular, since each call to Get[P/D]Sol() tells whether or not a new solution exists, and thus it may "change the solution that is currently kept in memory", the safe order is to Get[P/D]Val() <em>before</em> Get[P/D]Sol(), since when Get[P/D]Sol() is called again the value returned by Get[P/D]Val() might change, being the one corresponding to the solution that Get[P/D]Sol() will return next time rather than the value of the one it has just returned. Of course, this only applies if Get[P/D]Sol() returns true (but in principle the caller has no way to know beforehand whether or not this will happen). </p>

</div>
</div>
<a class="anchor" id="a3a89c607fa04a6e153ca0a766cad33d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMMCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a> GetLwrBnd </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>HvSol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These methods have to return any known Upper/Lower Bound on the optimal value of the "whole" problem (+/-INF are clearly always a possibility). </p>
<p>They also have to set HvSol to true if a primal/dual solution of the "whole" problem attaining that value is available, and false otherwise: in the former case, these solutions can be obtained with a proper combinations of Set*****() and Get[U/L]BSol() [see below]. If multiple primal/dual solutions are available, each one possibly gives a different Upper/Lower Bound: thus, Get[Uppr/Lwr]Bnd() has to be called for each of them. </p>

</div>
</div>
<a class="anchor" id="aa165f6569015fd4129d20fa0d5bba6b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetXtrSol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#ab31dfeace09a5b1b6c386f4ff089c8c6">Row</a>&#160;</td>
          <td class="paramname"><em>Xtr</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td>
          <td class="paramname"><em>Bse</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set[M]FlwSol() and <a class="el" href="classMMCFClass.html#aa165f6569015fd4129d20fa0d5bba6b4" title="Set[M]FlwSol() and SetXtrSol() are meant to pass to the object pointers to the memory where (respecti...">SetXtrSol()</a> are meant to pass to the object pointers to the memory where (respectively) a flow solution and an extra variables solution (the "primal information") have to be, along with "instructions" about their "format". </p>
<p>They are used in pair with GetPSol() and <a class="el" href="classMMCFClass.html#ae2ded411dcade8d0196de0b5afd9c1ac" title="Called after SolveMMCF() and Set[[M]Flw/Xtr]Sol(), these methods write in the memory provided for the...">GetUBSol()</a> [see below] to access solutions, but they may also be used with <a class="el" href="classMMCFClass.html#a5f4a28123233c6452569c63d9955eb11" title="Evaluates and return the cost of the primal or dual solutions provided by the Set****() methods above...">CostOf()</a> [see below] as a mean for inputting a solution. This double use may generate confusion: read carefully the comments to the above methods.</p>
<p>Set[[M]Flw/Xtr]Sol() must be called before the methods that use the information provided therein: for the "output" methods Get[P/UB]Sol(), it is also a good practice to call them before MMCFSolve(). Thus, the solver will know if the solution are required while it is solving the problem, and may for instance use that memory to write the solution rather than allocating its own. Whether or not this is required is solver-dependent.</p>
<p>Passing 0 as the first argument means that that set of variables is not required/provided: this is useful for accessing/passing only one of the two sets at a time.</p>
<p>Passing 0 as the second argument means that the corresponding solution is in "dense" format, i.e. the i-th variable must be found in the i-th position of the vector. For flow variables, the format is commodity-wise</p>
<p>first arc of the first commodity .. m-th arc of the first commodity .. : : first arc of the K-th commodity .. m-th arc of the K-th commodity.</p>
<p>while for extra variables it clearly depends on the application. If a non-0 is passed instead, it is taken as the pointer to a vector where the indices of the <em>nonzero</em> variables have to be: hence, the solution is in a "sparse" format, with e.g. Flw[ i ] containing the (nonzero) flow of the variable Bse[ i ]. Bse must be ordered in increasing sense, without duplications and Inf&lt;Index&gt;()-terminated, i.e. an Inf&lt;Index&gt;() must be placed right after the last significative entry.</p>
<p>For Set[M]FlwSol(), wf means that what is required is</p>
<ul>
<li>only the flow of the wf-th commodity if 0 &lt;= wf &lt; K;</li>
<li>the <em>aggregate</em> flow (i.e. the <em>sum</em> of the flows for <em>all</em> the commodities) if wf == K;</li>
<li>the <em>disaggregate</em> flow of <em>all</em> the commodities if wf &gt; K.</li>
</ul>
<p>Important note about "names": for all wf &lt;= K, if a `Bse' has been set, then the "names" written in Bse go from 0 to m - 1 because they refere to an arc of the graph; the commodity is clear if 0 &lt;= ws &lt; K, and there is no commodity at all if ws == K. Conversely, for ws &gt; NComm the names go from 0 to m * K - 1, as an item with name `h' referes to arc h % m of commodity h / m.</p>
<p>Note that wf here and ws in SetSubP() refere to two distinct concepts, although decomposition by commodity is clearly one possibility.</p>
<p>The two similar methods concerning flow solutions, SetFlwSol() and SetMFlwSol(), are provided as alternatives in order to take into account one (unpleasant) carachteristic of Multicommodity flows, i.e. that the optimal Multicommodity flow solution of a problem with all-integer capacities and deficits may <em>not</em> be integral. Thus, the type `MFNumber' is explicitly defined as to be distinct from `FNumber', as the former typically has to be a float type, while the latter is often an integer type. However, there are cases where the solution found by <a class="el" href="classMMCFClass.html#acf904d59c12da1f3c30b92ab1c5971fb" title="SolveMMCF() try to solve the current instance of the MMCF-related problem. ">SolveMMCF()</a> is of the `FNumber' type: think e.g. to the Flow Relaxation or to the Integer MMCF problem. Thus, the interface provides support for both cases - see also **SolIsFNumber() and Get**Sol() below. </p>

</div>
</div>
<a class="anchor" id="ae2ded411dcade8d0196de0b5afd9c1ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GetUBSol </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called <em>after</em> <a class="el" href="classMMCFClass.html#acf904d59c12da1f3c30b92ab1c5971fb" title="SolveMMCF() try to solve the current instance of the MMCF-related problem. ">SolveMMCF()</a> and Set[[M]Flw/Xtr]Sol(), these methods write in the memory provided for the purpose respectively the "optimal" primal solution of the problem and the primal solution of the "whole" problem corresponding to the Upper Bound, according to the required "style" [see Set[[M]Flw/Xtr]Sol()]. </p>
<p>The ws set in SetSubP() tells if the solution is relative to one specific subproblem or to the whole problem (ws == 0 is clearly not allowed here). Note that, although each subproblem only has one subset of the variables, each solution is in principle a "full" one, i.e., no assumption is done on how the partition intersects the commodities, although decomposition by commodity is clearly one possibility.</p>
<p>The solver may be capable of providing alternative "good" solutions, other than the one that it is currently returning; if it is capable (and willing) to do that, it should return true, and false otherwise. However, a return value of true does not imply that the method <em>must</em> be called again, the choice being left to the caller. Yet what it does mean is that the value returned by Get[PVal/UpprBnd]() [see above] after the call is different from that returned before, since this is intended to be the value of "the next solution that Get[P/UB]Sol() will return if called", and since not all returned solutions are optimal (not even the first, necessarily) then these values could be different.</p>
<p>If no feasible [primal] solution has been found then GetPVal() returns +INF [see above] GetPSol() should not be called, as there is no such thing as a solution to be got.</p>
<p>Once these methods have been called, they (like all those "consuming" solutions) should "reset" some internal state to indicate that the FSol and XSol vectors provided by the previous call[s] to Set[[M]Flw/Xtr]Sol() are no more valid: this is to avoid that, for instance, a subsequent call to <a class="el" href="classMMCFClass.html#a5f4a28123233c6452569c63d9955eb11" title="Evaluates and return the cost of the primal or dual solutions provided by the Set****() methods above...">CostOf()</a> think that FSol and XSol be its "input" parameters. A nice way for doing that is just to set FSol / MFSol / XSol to 0. Therefore, if (these or others) FSol / MFSol and XSol are needed again by some method, they must be passed again with Set[[M]Flw/Xtr]Sol() after a call to Get[P/UB]Sol(). </p>

</div>
</div>
<a class="anchor" id="af2e0d46bb7c4594fe46e9e490e81c806"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool UBSolIsFNumber </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These methods tell if the primal solutions (to be retrieved with GetPSol()) and the upper bound solutions (to be retrieved with <a class="el" href="classMMCFClass.html#ae2ded411dcade8d0196de0b5afd9c1ac" title="Called after SolveMMCF() and Set[[M]Flw/Xtr]Sol(), these methods write in the memory provided for the...">GetUBSol()</a>) are of type `FNumber' rather than `MFNumber'. </p>
<p>If PSolIsFNumber() returns true (which is clearly solver-dependent), then SetFlwSol() has to be used when dealing with primal solutions, otherwise SetMFlwSol() has to be used; the same holds for upper bound solutions. </p>

</div>
</div>
<a class="anchor" id="a84b8040a69417e6aa5a6562ab7f78f15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetXtrDV </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#ab31dfeace09a5b1b6c386f4ff089c8c6">Row</a>&#160;</td>
          <td class="paramname"><em>XDV</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SetNPot(), SetRCst(), SetMCCst(), SetXtrRC() and <a class="el" href="classMMCFClass.html#a84b8040a69417e6aa5a6562ab7f78f15" title="SetNPot(), SetRCst(), SetMCCst(), SetXtrRC() and SetXtrDV() are meant to pass to the object pointers ...">SetXtrDV()</a> are meant to pass to the object pointers to the memory where, respectively,. </p>
<ul>
<li>the Node Potentials, i.e. the dual costs of the Flow Conservation constraints (1.k),</li>
<li>the Reduced Costs of the flow variables, i.e. essentially the dual costs of the Upper Bound constraints (2.k),</li>
<li>the dual costs of Mutual Capacity constraints (3),</li>
<li>the Reduced Costs of the "extra" (non-flow) variables, i.e. essentially the dual costs of the range constraints (5),</li>
<li>and the dual costs of the "extra" constraints (4)</li>
</ul>
<p>(the "dual information") have to be, along with "instructions" about their "format". They are used in pair with GetDSol() and <a class="el" href="classMMCFClass.html#a18d0cdad147df2c60745d70101a24dae" title="Called after SolveMMCF() and Set[NPot/RCst/MCCst/XtrRC/XtrDV](), these methods write in the memory pr...">GetLBSol()</a> [see below] to access solutions, but they may also be used with <a class="el" href="classMMCFClass.html#a5f4a28123233c6452569c63d9955eb11" title="Evaluates and return the cost of the primal or dual solutions provided by the Set****() methods above...">CostOf()</a> and GetSubG() [see below] as a mean for inputting a solution.</p>
<p>Set[NPot/RCst/MCCst/XtrRC/XtrDV]() must be called before the methods that use the information provided therein: for the "output" methods Get[D/LB]Sol(), it is also a good practice to call them before MMCFSolve(), so that the solver will know if the solution are required while it is solving the problem, and may for instance use that memory to write the solution rather than allocating its own. Whether or not this is required is solver-dependent.</p>
<p>Passing 0 as the first argument means that that set of variables is not required/provided: this is useful for accessing/passing only one of the three sets at a time.</p>
<p>For SetNPot() and SetRCst(), wd means that what is required is</p>
<ul>
<li>only the components of the wd-th commodity if 0 &lt;= wd &lt; K;</li>
<li>the "full" solution, i.e., the components of <em>all</em> the commodities if wd &gt;= K.</li>
</ul>
<p>If wd &gt;= K, the solution is in "dense" format: for Node Potentials and flow Reduced Costs the format is commodity-wise, i.e. respectively</p>
<p>first node of the first commodity .. n-th node of the first commodity .. : : first node of the K-th commodity .. n-th node of the K-th commodity</p>
<p>and</p>
<p>first arc of the first commodity .. m-th arc of the first commodity .. : : first arc of the K-th commodity .. m-th arc of the K-th commodity</p>
<p>while for the dual Costs of Mutual Capacities it is arc-wise, i.e.</p>
<p>first arc .. m-th arc.</p>
<p>Note that wf here and ws in SetSubP() refere to two distinct concepts, although decomposition by commodity is clearly one possibility.</p>
<p>Note that, in general, the reduced costs of a bounded variable is the opposite of the dual cost of the corresponding bound constraint; in fact, the dual cost can be &gt; 0 only if the primal variable attains its bound, hence its reduced cost is &lt;= 0. </p>

</div>
</div>
<a class="anchor" id="a18d0cdad147df2c60745d70101a24dae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GetLBSol </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called <em>after</em> <a class="el" href="classMMCFClass.html#acf904d59c12da1f3c30b92ab1c5971fb" title="SolveMMCF() try to solve the current instance of the MMCF-related problem. ">SolveMMCF()</a> and Set[NPot/RCst/MCCst/XtrRC/XtrDV](), these methods write in the memory provided for the purpose respectively the "optimal" dual solution of the problem and the dual solution of the "whole" problem corresponding to the Lower Bound, according to the required "style". </p>
<p>The ws set in SetSubP() tells if the solution is relative to one specific subproblem or to the whole problem (ws == 0 is clearly not allowed here). Note that if the problem is separable into independent subproblems then each subproblem may have only a subset of the constraints; therefore, for each subproblem only a subset of the dual variables is significative, and for each dual variable there is (at most) one subproblem which it belongs to. Nonethless, each dual solution is in principle a "full" one, i.e., no assumption is done on how the dual variables are partitioned among the subproblems.</p>
<p>The solver may be capable of providing alternative "good" solutions, other than the one that it is currently returning; if it is capable (and willing) to do that, it should return true, and false otherwise. However, a return value of true does not imply that the method <em>must</em> be called again, the choice being left to the caller. Yet what it does mean is that the value returned by Get[FVal/LwrBnd]() [see above] after the call is different from that returned before, since this is intended to be the value of "the next solution that Get[D/LB]Sol() will return if called", and since not all returned solutions are optimal (not even the first, necessarily) then these values could be different.</p>
<p>If no feasible [dual] solution has been found then <a class="el" href="classMMCFClass.html#ad43b4696f9396a82a76423603083050a" title="These methods must return the objective function value, respectively, of the primal and dual &quot;optimal...">GetDVal()</a> returns -INF [see above] GetDSol() should not be called, as there is no such thing as a solution to be got.</p>
<p>These methods (like all those "consuming" solutions) should do something equivalent to setting NPot / RCst / MCst / XtRC / XtDV to 0 for avoiding them to be wrongly used (e.g. as "input" parameters) after the call: see the comments to Get[P/UB]Sol(). </p>

</div>
</div>
<a class="anchor" id="a5f4a28123233c6452569c63d9955eb11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMMCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a> CostOf </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates and return the cost of the primal or dual solutions provided by the Set****() methods above. </p>
<p>The ws set in SetSubP() [see above] has the same meaning as in Get[P/D]Val() [see above], i.e., tells the cost of which subproblem is required to be calculated.</p>
<p>Clearly, the "full" primal/dual solution is required in order to compute the "full cost" (for ws &gt; NrSubP()); however, only the "partial" solution corresponding to the ws-th subproblem is required if 1 &lt;= ws &lt;= NrSubP(). Of course, the "full" solution is also fine in this case.</p>
<p>Note that only one method is provided for both primal and dual costs, so only a primal <em>or</em> a dual solution should have been given with Set****() before the call to <a class="el" href="classMMCFClass.html#a5f4a28123233c6452569c63d9955eb11" title="Evaluates and return the cost of the primal or dual solutions provided by the Set****() methods above...">CostOf()</a>: otherwise, the return value is undefined.</p>
<p>This method (like all those "consuming" solutions) should do something equivalent to setting FSol / XSol to 0 for avaiding them to be wrongly used after the call: see the comments to Get***Sol(). </p>

</div>
</div>
<a class="anchor" id="a744bfe60e68ceb8b0678149c4a3ed593"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double TimeMMCF </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If these methods are called within any of the methods of the class that are "actively timed" (this depends on the subclasses), they return respectively the user and sistem time and the total time (in seconds) since the start of that method. </p>
<p>If methods that are actively timed call other methods that are actively timed, these methods return the (...) time since the beginning of the <em>outer</em> actively timed method. If these methods are called outside of any actively timed method, they return the (...) time spent in all the previous executions of all the actively timed methods of the class.</p>
<p>Implementing the proper calls to MMCFt-&gt;Start() and MMCFt-&gt;Stop() is due to derived classes; these should at least be placed at the beginning and at the end, respectively, of <a class="el" href="classMMCFClass.html#acf904d59c12da1f3c30b92ab1c5971fb" title="SolveMMCF() try to solve the current instance of the MMCF-related problem. ">SolveMMCF()</a> and presumably the Chg***() methods, that is, at least these methods should be "actively timed". </p>

</div>
</div>
<a class="anchor" id="a321ae32303b0744e905e25a15900700a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GetCosts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a>&#160;</td>
          <td class="paramname"><em>Csts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;&#160;<a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the costs of the flow variables in the MMCF instance. </p>
<p>Flow variables are numbered from 0 to m * K - 1 according to the format of FF in GetSol() [see above]. The flow variables whose costs are written in Csts[] are all and only those whose name is</p><ul>
<li>comprised between strt (included) and min( stp , m * K ) (excluded);</li>
<li>contained in nms[] if nms != 0 (in this case, it has to be a vector of indices in [ 0 .. m * K ), with no duplicated elements, ordered in increasing sense and Inf&lt;Index&gt;()-terminated). </li>
</ul>

</div>
</div>
<a class="anchor" id="a0752a5d77a50de3750d1031e8bcfb207"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GetXtrCsts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a>&#160;</td>
          <td class="paramname"><em>XtrCs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;<a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stp</td><td>Reads the costs of the "extra" variables in the MMCF instance; these variables are numbered from 0 to NrXtrVrs() - 1, according to the format of XV in GetSol() [see above].</td></tr>
  </table>
  </dd>
</dl>
<p>The extra variables whose costs are written in XtrCs[] are all and only those whose name is</p><ul>
<li>comprised between strt (included) and min( stp , NrXtrVrs() ) (excluded);</li>
<li>contained in nms[] if nms != 0 (in this case, it has to be a vector of indices in [ 0 .. NrXtrVrs() ), with no duplicated elements, ordered in increasing sense and Inf&lt;Index&gt;()-terminated). </li>
</ul>

</div>
</div>
<a class="anchor" id="a70c152b98641e97d5949b0fca8cbbb21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GetICaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a>&#160;</td>
          <td class="paramname"><em>ICps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;&#160;<a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the Individual Capacities of the flow variables in the MMCF instance. </p>
<p>The format of the returned ICps[] depends on nms[], strt and stp exactly as in <a class="el" href="classMMCFClass.html#a321ae32303b0744e905e25a15900700a" title="Reads the costs of the flow variables in the MMCF instance. ">GetCosts()</a> [see above]. </p>

</div>
</div>
<a class="anchor" id="a4309ff3df4a4733ed4e568a99fdbe2a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GetMCaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a>&#160;</td>
          <td class="paramname"><em>MCps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;&#160;<a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the Mutual Capacities of the flow variables in the MMCF instance. </p>
<p>The mutual capacities written in MCps[] are all and only those of arcs whose name is</p><ul>
<li>comprised between strt (included) and min( stp , m ) (excluded);</li>
<li>contained in nms[] if nms != 0 (in this case, it has to be a vector of indices in [ 0 .. m ), with no duplicated elements, ordered in increasing sense and Inf&lt;Index&gt;()-terminated). </li>
</ul>

</div>
</div>
<a class="anchor" id="ab9538ab2a11e9a86271120ab2edc4a66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgCosts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td>
          <td class="paramname"><em>NwCsts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;&#160;<a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the costs of the flow variables in the MMCF instance. </p>
<p>Flow variables are numbered from 0 to m * K - 1 according to the format of FF in GetSol() [see above]. If nms == 0, the new cost for the flow variable strt + i will be taken from NwCsts[ i ] for all 0 &lt;= i &lt; min( m * K , stp ) - strt. If nms != 0, it has to point to a vector of indices in [ 0 .. m * K ) (with no duplicated elements, ordered in increasing sense and Inf&lt;Index&gt;()-terminated); for all j such that strt &lt;= nms[ j ] &lt; min( stp , m * K ), the new cost for the flow variable nms[ j ] will be taken from NwCsts[ j ]. </p>

</div>
</div>
<a class="anchor" id="a268bacf3429429242d80a5f44cdc9102"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgXtrCsts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td>
          <td class="paramname"><em>NwXtrCs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;<a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stp</td><td>Changes the costs of the "extra" variables in the MMCF instance; these variables are numbered from 0 to NrXtrVrs() - 1 according to the format of XV in GetSol() [see above]. If nms == 0, the new cost for the extra variable strt + i will be taken from NwXtrCs[ i ] for all 0 &lt;= i &lt; min( NrXtrVrs() , stp ) - strt. If nms != 0, it has to point to a vector of indices in [ 0 .. NrXtrVrs() ) (with no duplicated elements, ordered in increasing sense and Inf&lt;Index&gt;()-terminated); for all j such that strt &lt;= nms[ j ] &lt; min( stp , NrXtrVrs() ), the new cost for the extra variable nms[ j ] will be taken from NwXtrCs[ j ]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b366b2ac8d46548b587f67c64e4eb8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgICaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td>
          <td class="paramname"><em>NwICps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;&#160;<a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the Individual Capacities of the flow variables in the MMCF instance. </p>
<p>The format of the returned NwICaps[] depends on nms[], strt and stp exactly as in <a class="el" href="classMMCFClass.html#ab9538ab2a11e9a86271120ab2edc4a66" title="Changes the costs of the flow variables in the MMCF instance. ">ChgCosts()</a> [see above]. </p>

</div>
</div>
<a class="anchor" id="a66d35cf8474371a0ce7efdce0ace2069"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgMCaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td>
          <td class="paramname"><em>NwMCps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;&#160;<a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the Mutual Capacities of the flow variables in the MMCF instance. </p>
<p>If nms == 0, the new mutual capacity for arc i will be taken from NwMCps[ i ] for all 0 &lt;= i &lt; min( m , stp ) - strt. If nms != 0, it has to point to a vector of indices in [ 0 .. m ) (with no duplicated elements, ordered in increasing sense and Inf&lt;Index&gt;()-terminated); for all j such that strt &lt;= nms[ j ] &lt; min( stp , m ), the mutual capacity for the arc nms[ j ] will be taken from NwMCps[ j ]. </p>

</div>
</div>
<a class="anchor" id="ab68bed0a51d8c555d643ae305d1ce6c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ChgIntVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>k</em> = <code>Inf&lt;&#160;<a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>IntVld</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;&#160;<a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the status of (a subset of) the - flow and extra - variables of the problem in terms of the integrality constraints imposed upon them. </p>
<p>ChgIntVar( k , true/false , ... ) for k &lt; K says that some of the variables of the commodity k are/aren't integer-valued. The variables to which the change is applied are the flow variables of commodity k whose index is:</p><ul>
<li>in the set nms[] (which contains indices in [0, m ), ordered in increasing sense and Inf&lt;Index&gt;()-terminated);</li>
<li>comprised between strt (included) and min( stp , m ) (excluded). nms == 0 means "all in the interval [strt, stp)".</li>
</ul>
<p>The status of all other variables remains unchanged.</p>
<p>ChgIntVar( K , ... ) can be used to set the integrality of the "extra" (non-flow) variables; of course, in this case the indices must be in the range [0, NrXtrVrs() ).</p>
<p>ChgIntVar( k , ... ) with k &gt; K (e.g. k == Inf&lt;Index&gt;()) applies the change to all flow variables, irrespective of the commodity to which they belong; in this case, the indices in nms[], strt and stp must be in the [ 0 , m * K ) range. </p>

</div>
</div>
<a class="anchor" id="acb9ca1c708fde6eb68211a2edd0c7e06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OpenArcs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>whch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Respectively "Close" and "Open" the arcs indicated in whch, that must point to a vector of indices in [ 0 . </p>
<p>. m - 1 ] (with no duplicated elements, ordered in increasing sense and Inf&lt;Index&gt;()-terminated). The first forms close/open arcs for <em>all</em> the commodities simultaneously, while the second forms do it only for the commodity 'k'.</p>
<p>Closing an arc for a given commodity 'k' is conceptually equivalent to setting its Individual Capacity to zero [see <a class="el" href="classMMCFClass.html#a1b366b2ac8d46548b587f67c64e4eb8f" title="Changes the Individual Capacities of the flow variables in the MMCF instance. ">ChgICaps()</a> above]; closing an arc for all the commodities is conceptually equivalent to closing the arc for all the commodities individually and/or to setting its Mutual Capacity to zero [see <a class="el" href="classMMCFClass.html#a66d35cf8474371a0ce7efdce0ace2069" title="Changes the Mutual Capacities of the flow variables in the MMCF instance. ">ChgMCaps()</a> above]. Opening an arc is conceptually equivalent to restoring the capacities to their initial value.</p>
<p>However, the solver may implement the above operations more efficiently; furthermore, the original capacities are kept by the solver itself when an arc is closed, so that they do not need to be stored somewhere else for when it is re-opened.</p>
<p>Opening an arc that has not previusly been Closed is an error: however, it is admitted to call CloseArcs( { i } ) even if CloseArcs( k , { i } ) has already been called. The "individual" closure has "precedence" over the "global" one, that is if OpenArcs( { i } ) is called afterwards then the arc remain closed on all the commodities k such that CloseArcs( k , { i } ) had been called previously, until OpenArcs( k , { i } ) is explicitly called for each of these commodities.</p>
<p>OpenArcs( k , { i } ) should not be called for an arc that has been "globally" closed with CloseArcs( { i } ). </p>

</div>
</div>
<a class="anchor" id="a49ed6b704e265ab5a1a093cb9d3507dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AddExtraVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>NXV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td>
          <td class="paramname"><em>XCst</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td>
          <td class="paramname"><em>XUb</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td>
          <td class="paramname"><em>XLb</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>IntVar</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nms</td><td><a class="el" href="classMMCFClass.html#a49ed6b704e265ab5a1a093cb9d3507dd">AddExtraVars()</a> adds to the problem NXV extra variables. Costs, upper and lower bounds of the new variables are given respectively in the read-only vectors pointed by XCst, XUb and XLb; 0 means "all zero" for XCst and XLb, and it means "all +infinity" (= no upper bound) for XUb.</td></tr>
  </table>
  </dd>
</dl>
<p>IntVar == true means that some of the new variables are integer-valued. If nms != 0, it must point to a vector of indices (ordered in increasing sense and Inf&lt;Index&gt;() terminated) containing the indices of those of the new extra variables just being added (thus, indices in the [0, NXV) range) that are integer-valued; otherwise, all the new variables ar integer-valued.</p>
<p>Note that this method only adds variables: <a class="el" href="classMMCFClass.html#affc3ace6c36aa14e5713c2e2788df045">AddExtraConstr()</a> [see below] is provided for adding "extra" linear constraints, which may (or may not) involve these extra variables. </p>

</div>
</div>
<a class="anchor" id="affc3ace6c36aa14e5713c2e2788df045"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AddExtraConstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>NXC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>IBeg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td>
          <td class="paramname"><em>XLr</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td>
          <td class="paramname"><em>XUr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">XUr</td><td>AddExtraConstr adds to the problem NXC new linear constraints. IBeg, Indx and Vals must contain the description of the new constraints: each constraint is represented by the set of indices of variables with nonzero coefficient and the corresponding coefficients. The indices and coefficients of the i-th constraint, i = 0 .. NXC - 1, must be in Indx and Vals, respectively, in the positions between IBeg[ i ] (included) and IStp[ i + 1 ] (excluded). The indices corresponding to each constraint, in Indx, must be ordered in increasing sense and without duplications.</td></tr>
  </table>
  </dd>
</dl>
<p>The mapping between indices and variables is the following: the variable corresponding to arc j for commodity k has the index k * m + j; the i-th "extra" variable has the index K * m + i (the order is "commodity-wise", with the "extra" variables following).</p>
<p>Note that IBeg, Indx and Vals are <em>not</em> pointers to const: this is done to allow the implementation to <em>overwrite</em> those vectors, should it find this useful. Furthermore, the implementation <em>need not</em> to restore the original containts of the vectors: no assumption should be done by the caller on the contents of IBeg, Indx and Vals after the call. The rationale for this is that these data structures may be "big", and that they should be of no use after the call, so by allowing the implementation to exploit that memory some serious memory problem may be avoided.</p>
<p>XLr and XUr are, respectively, the lower and upper range of the extra constraints: if XLr[ i ] == - F_INF, then the row have sense &lt;=, while if XUr[ i ] == F_INF, then the row have sense &gt;=. XLr == 0 means "all
   equal to - F_INF", and XUr == 0 means "all equal to F_INF". It is an error if XLr[ i ] == - F_INF <em>and</em> XUr[ i ] == F_INF for some i (this is not a constraint), and therefore at least one between XLr and XUr must be non-0. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classMMCFClass.html">MMCFClass</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
