<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>CNDSM: Description of &quot;easy&quot; components of Fi()</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CNDSM
   &#160;<span id="projectnumber">1.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__EasyComp.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Description of "easy" components of Fi()</div>  </div>
</div><!--header-->
<div class="contents">

<p>In some cases, the function Fi to be minimized is composed of several different components [see <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> above] which can be subdivided into two different classes:  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaca9733adf962bbe6ae97f1039c0a3bbe"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classNDOSolver.html">NDOSolver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EasyComp.html#gaca9733adf962bbe6ae97f1039c0a3bbe">GetNDOSolver</a> (void)</td></tr>
<tr class="memdesc:gaca9733adf962bbe6ae97f1039c0a3bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allows to read back the pointer to the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> that has been passed to the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> through <a class="el" href="classFiOracle.html#a3a4ace42fe051de8bae0feccea1bce16" title="This method is meant to pass to the FiOracle a pointer to the NDOSolver object that is using it...">SetNDOSolver()</a> [see above], if any.  <a href="#gaca9733adf962bbe6ae97f1039c0a3bbe">More...</a><br /></td></tr>
<tr class="separator:gaca9733adf962bbe6ae97f1039c0a3bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Reading the data of the problem</h2></td></tr>
<tr class="memitem:gad5a82019520f11aeeed9501d044e5ee3"><td class="memItemLeft" align="right" valign="top">virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EasyComp.html#gad5a82019520f11aeeed9501d044e5ee3">GetBNC</a> (cIndex wFi)</td></tr>
<tr class="memdesc:gad5a82019520f11aeeed9501d044e5ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of variables of the "easy" linear problem which describes Fi[ wFi ], that is, the number of columns of the matrices B[ wFi ] and A[ wFi ] and the lenght of the vectors x[ wFi ], c[ wFi ], l[ wFi ] and u[ wFi ].  <a href="#gad5a82019520f11aeeed9501d044e5ee3">More...</a><br /></td></tr>
<tr class="separator:gad5a82019520f11aeeed9501d044e5ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30047aa832e702b7926cc65fba67625a"><td class="memItemLeft" align="right" valign="top">virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EasyComp.html#ga30047aa832e702b7926cc65fba67625a">GetBNR</a> (cIndex wFi)</td></tr>
<tr class="memdesc:ga30047aa832e702b7926cc65fba67625a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rows of the matrix B[ wFi ] and the lenght of the vectors d[ wFi ] and e[ wFi ]; GetBNR( wFi ) can return 0 if only "box" constraints are imposed on the variables x[ wFi ].  <a href="#ga30047aa832e702b7926cc65fba67625a">More...</a><br /></td></tr>
<tr class="separator:ga30047aa832e702b7926cc65fba67625a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2164e0f768d3be7dbbda360cc8f646fc"><td class="memItemLeft" align="right" valign="top">virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EasyComp.html#ga2164e0f768d3be7dbbda360cc8f646fc">GetBNZ</a> (cIndex wFi)</td></tr>
<tr class="memdesc:ga2164e0f768d3be7dbbda360cc8f646fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nonzeroes in the matrix B[ wFi ]; this is clearly 0 if GetBNR( wFi ) == 0.  <a href="#ga2164e0f768d3be7dbbda360cc8f646fc">More...</a><br /></td></tr>
<tr class="separator:ga2164e0f768d3be7dbbda360cc8f646fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1771551bac42d9e58f59116189c54ee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EasyComp.html#gac1771551bac42d9e58f59116189c54ee">GetBDesc</a> (cIndex wFi, int *Bbeg, int *Bind, double *Bval, double *lhs, double *rhs, double *cst, double *lbd, double *ubd)</td></tr>
<tr class="memdesc:gac1771551bac42d9e58f59116189c54ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a description of the matrix B[ wFi ] and of the vectors d[ wFi ], e[ wFi ], c[ wFi ], l[ wFi ] and u[ wFi ].  <a href="#gac1771551bac42d9e58f59116189c54ee">More...</a><br /></td></tr>
<tr class="separator:gac1771551bac42d9e58f59116189c54ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9811ae42439c72a16806d3ce01db7557"><td class="memItemLeft" align="right" valign="top">virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EasyComp.html#ga9811ae42439c72a16806d3ce01db7557">GetANZ</a> (cIndex wFi, cIndex strt=0, Index stp=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:ga9811ae42439c72a16806d3ce01db7557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nonzeroes in the matrix A[ wFi ] (whose number of columns is GetBNC( wFi ) and whose number of rows is <a class="el" href="classFiOracle.html#a9395fc2b1320d4e44be62366feec4e6e" title="Returns the number of variables of the function, i.e., the (maximum) size of the vectors to be passed...">GetNumVar()</a>); more precisely, it returns the number of nonzeroes in the submatrix of A[ wFi ] containing all the rows with indices between start and min( stp , <a class="el" href="classFiOracle.html#a9395fc2b1320d4e44be62366feec4e6e" title="Returns the number of variables of the function, i.e., the (maximum) size of the vectors to be passed...">GetNumVar()</a> ) - 1 (corresponding to the variables with those "names").  <a href="#ga9811ae42439c72a16806d3ce01db7557">More...</a><br /></td></tr>
<tr class="separator:ga9811ae42439c72a16806d3ce01db7557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40c0ae954bd72a9b30bbefc013e2a2ce"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EasyComp.html#ga40c0ae954bd72a9b30bbefc013e2a2ce">GetADesc</a> (cIndex wFi, int *Abeg, int *Aind, double *Aval, cIndex strt=0, Index stp=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:ga40c0ae954bd72a9b30bbefc013e2a2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a description of the submatrix of A[ wFi ] containing all the rows with indices between start and min( stp , GetNumVar() ) - 1; the meaning of Abeg, Aind and Aval is analogous to that of Bbeg, Bind and Bval in <a class="el" href="group__EasyComp.html#gac1771551bac42d9e58f59116189c54ee" title="Returns a description of the matrix B[ wFi ] and of the vectors d[ wFi ], e[ wFi ], c[ wFi ], l[ wFi ] and u[ wFi ]. ">GetBDesc()</a> [see above].  <a href="#ga40c0ae954bd72a9b30bbefc013e2a2ce">More...</a><br /></td></tr>
<tr class="separator:ga40c0ae954bd72a9b30bbefc013e2a2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>In some cases, the function Fi to be minimized is composed of several different components [see <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> above] which can be subdivided into two different classes: </p>
<ul>
<li>"difficult" components, that are known only through a "complicated" oracle (the usual situation), and</li>
<li>"easy" components, for which a "compact, efficient" descritpion is known.</li>
</ul>
<p>These methods allow an NDO solver to obtain a compact description of the "easy" components of Fi; in particular, the components are considered easy if they can be described with a "compact" linear program (any polyhedral function can be described a linear program, but here the idea is that the linear program must have "few" variables and constraints). That is, the h-th component is "easy" if</p>
<p>Fi[ h ]( Lambda ) = sup{ ( c[ h ] - Lambda * A[ h ] ) x[ h ] : d[ h ] &lt;= B[ h ] x[ h ] &lt;= e[ h ] , l[ h ] &lt;= x[ h ] &lt;= u[ h ] }</p>
<p>i.e., if Fi[ h ] is the Lagrangian function of a "compact" linear program. A typical case is when the whole Fi is a Lagrangian function of a complex problem, where the Lagrangian problem decomposes into some "easy" (linear) and some "hard" (nonlinear/nonconvex) problems. Note that if some component has a linear (affine) part, all these are considered to be "embedded" in the linear (affine) 0-th component of Fi.</p>
<p>Some NDO solvers may exploit the knowledge of a complete description of the "easy" components of the function; these methods are thought for providing the interested solver with the information.</p>
<dl class="section note"><dt>Note</dt><dd><em>Important</em>: "easy" components that reveal themselves cannot be considered "standard" components; that is, the "ordinary" <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a>, <a class="el" href="classFiOracle.html#aec7d643acc6b898fe0cd91b8dd042d0f" title="This method must be called to ask the FiOracle whether it can produce a &quot;new&quot; item corresponding to t...">NewGi()</a>, SetGi(), ... [see below] machinery for computing function values and subgradients is not assumed to work with easy components, and the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> is <em>not</em> allowed to call them for "easy" components. In other words, by declaring a component as "easy" the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> is basically freed by all obbligations regarding it, and it's the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a>'s duty to use the provided information to handle it (or refuse to do so and die gracefully). Clearly, whether or not an "easy" component is declared as such is a decision of the FiOrcale, which can then avoid to do so if the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> it's going to be used with does not support it, or if it can handle it (presumably) more efficiently than a generic linear solver due to its knowledge of the structure of the subproblem.</dd>
<dd>
These methods are intended to be called only with 1 &lt;= wFi &lt;= <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a>. Calls with wFi &gt; <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> make no sense. Calls with wFi == 0 would indeed make sense, as the linear 0-th component of Fi is precisely one very special case of function which has a compact polyhedral description (with only one variable x[ 0 ], an empty B[ 0 ], l[ 0 ] == u[ 0 ] == 1 and A[ 0 ] = b). However, other means are already provided for obtaining this very special descritpion [see <a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a> below].</dd>
<dd>
The existence of a polyhedral description of the components is not assumed to vary over time. That is, either a component always has a polyhedral description, or it never has one; in other words, GetBNC( h ) <em>must always return the same value</em> throughout all the life of a <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> object, or at least as long as the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> is used by one given NDO solver. Changes in the number of variables might in principle happen in some cases (e.g., variables generation within the polyhedral description) but this is <em>not</em> supported by the current version of this interface.</dd></dl>
<p>For any component h that has a polyhedral description, the NDO solver should in principle call these methods only once. There are exceptions, however. The first is if the NDO solver uses variables generation techniques, which try to solve a NDO problem by restricting it to a (small) "active set" of the variables, minimizing the function in that subspace and possibly revising the active set. Such a NDO solver may acquire the information about different parts of the matrix A[ h ] in different moments, as it only works with a submatrix. The second exception is if the NDO solver discovers that one of the components which have a polyhedral description is changed (e.g., because the methods ChgFiV() and ChgSbG() of class <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> are called, see <a class="el" href="NDOSlver_8h.html" title="Definition of the abstract base class NDOSolver, which defines the interface for convex minimization ...">NDOSlver.h</a>); in this case, it may want to call these methods again to acquire the new description.</p>
<p>Since in most cases a polyhedral description of the components is not available, these methods are not "pure virtual"; rather, they are given a default implementation which corresponds to "no polyhedral description
available". </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gad5a82019520f11aeeed9501d044e5ee3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Index GetBNC </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>wFi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of variables of the "easy" linear problem which describes Fi[ wFi ], that is, the number of columns of the matrices B[ wFi ] and A[ wFi ] and the lenght of the vectors x[ wFi ], c[ wFi ], l[ wFi ] and u[ wFi ]. </p>
<p>If GetBNC( wFi ) returns 0, then no polyhedral description of Fi[ wFi ] is available, and no calls to any other of these methods with the same wFi are permitted. </p>

</div>
</div>
<a class="anchor" id="ga30047aa832e702b7926cc65fba67625a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Index GetBNR </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>wFi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of rows of the matrix B[ wFi ] and the lenght of the vectors d[ wFi ] and e[ wFi ]; GetBNR( wFi ) can return 0 if only "box" constraints are imposed on the variables x[ wFi ]. </p>

</div>
</div>
<a class="anchor" id="ga2164e0f768d3be7dbbda360cc8f646fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Index GetBNZ </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>wFi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of nonzeroes in the matrix B[ wFi ]; this is clearly 0 if GetBNR( wFi ) == 0. </p>

</div>
</div>
<a class="anchor" id="gac1771551bac42d9e58f59116189c54ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GetBDesc </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>wFi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Bbeg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Bind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Bval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>cst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lbd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ubd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a description of the matrix B[ wFi ] and of the vectors d[ wFi ], e[ wFi ], c[ wFi ], l[ wFi ] and u[ wFi ]. </p>
<p>Bbeg, Bind and Bval must point respectively to a (GetBNC( wFi ) + 1)-vector of ints, a GetBNZ( wFi )-vector of ints and a GetBNZ( wFi )-vector of doubles; upon return, a description of B[ wFi ] has to be written in these arrays. Bbeg[ i ] says where the description of the i-th column of the matrix starts in the arrays Bind[] and Bval[], for i = 0 .. <a class="el" href="group__EasyComp.html#gad5a82019520f11aeeed9501d044e5ee3" title="Returns the number of variables of the &quot;easy&quot; linear problem which describes Fi[ wFi ]...">GetBNC()</a> - 1; for all the indices Bbeg[ i ] &lt;= j &lt; Bbeg[ i + 1 ], Bval[ j ] is the value of (B[ h ])[ Bind[ j ] ][ i ], while all the other elements on the i-th column are zero. lhs and rhs must point to GetBNR( wFi )-vectors of doubles; upon return, the vectors d[ wFi ] and e[ wFi ] have to be written there. Finally, cst, lbd and ubd must point to <a class="el" href="group__EasyComp.html#gad5a82019520f11aeeed9501d044e5ee3" title="Returns the number of variables of the &quot;easy&quot; linear problem which describes Fi[ wFi ]...">GetBNC()</a>-vectors of doubles; upon return, the vectors c[ wFi ], l[ wFi ] and u[ wFi ] have to be written there.</p>
<p>Note that bounds, either of the constraints or on the variables, may be infinite. In particular, for any 0 &lt;= i &lt; GetBNR( wFi ), lhs[ wFi ][ i ] can be == - Inf&lt;double&gt;() to indicate that the i-th constraint has the form B[ wFi ][ i ] x[ wFi ] &lt;= rhs[ wFi ][ i ], while rhs[ wFi ][ i ] can be == + Inf&lt;double&gt;() to indicate that the i-th constraint has the form lhs[ wFi ][ i ] &lt;= B[ wFi ][ i ] x[ wFi ]; it is assumed that at least one of the two bounds is finite, for otherwise there is no i-th constraint. Similarly, any 0 &lt;= j &lt; GetBNC( wFi ), lbd[ wFi ][ j ] can be == - Inf&lt;double&gt;() and/or ubd[ wFi ][ j ] can be == + Inf&lt;double&gt;(), to indicate that x[ wFi ][ j ] has no finite lower/upper bound. In this case, both bounds infinite (respectively - and +) can happen, although some NDO solvers may require the overall feasible region of the wFi-th subproblem to be compact (this makes the function finite everywhere and therefore "more regular"). Note that, however, it is always assumed that lhs[ wFi ][ i ] &lt;= rhs[ wFi ][ i ] (equality is a definite possibility, corresponding to an equality constraint), and lbd[ wFi ][ j ] &lt;= ubd[ wFi ][ j ] (equality here being unlikely, for it corresponds to a fixed variable that can always be dealt with implicitly), for otherwise the component is "trivially empty" (constant - INF, i.e., not proper convex).</p>
<p>The NDO solver is allowed to query only a subset of the information; that is, by passing 0 to some of the pointers, the oracle will not write the corresponding information. This can be done for all parameters individually, except for the first three; that is, if just one among Bbeg, Bind and Bval is 0, then all the other ones are to be treated as if they were 0, too. It if of course expected that at least one among lhs, rhs, cst, lbd and ubd, and/or the three Bbeg, Bind and Bval, be nonzero at each call. </p>

</div>
</div>
<a class="anchor" id="ga9811ae42439c72a16806d3ce01db7557"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Index GetANZ </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>wFi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;Index&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of nonzeroes in the matrix A[ wFi ] (whose number of columns is GetBNC( wFi ) and whose number of rows is <a class="el" href="classFiOracle.html#a9395fc2b1320d4e44be62366feec4e6e" title="Returns the number of variables of the function, i.e., the (maximum) size of the vectors to be passed...">GetNumVar()</a>); more precisely, it returns the number of nonzeroes in the submatrix of A[ wFi ] containing all the rows with indices between start and min( stp , <a class="el" href="classFiOracle.html#a9395fc2b1320d4e44be62366feec4e6e" title="Returns the number of variables of the function, i.e., the (maximum) size of the vectors to be passed...">GetNumVar()</a> ) - 1 (corresponding to the variables with those "names"). </p>

</div>
</div>
<a class="anchor" id="ga40c0ae954bd72a9b30bbefc013e2a2ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GetADesc </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>wFi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Abeg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Aind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Aval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;Index&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a description of the submatrix of A[ wFi ] containing all the rows with indices between start and min( stp , GetNumVar() ) - 1; the meaning of Abeg, Aind and Aval is analogous to that of Bbeg, Bind and Bval in <a class="el" href="group__EasyComp.html#gac1771551bac42d9e58f59116189c54ee" title="Returns a description of the matrix B[ wFi ] and of the vectors d[ wFi ], e[ wFi ], c[ wFi ], l[ wFi ] and u[ wFi ]. ">GetBDesc()</a> [see above]. </p>

</div>
</div>
<a class="anchor" id="gaca9733adf962bbe6ae97f1039c0a3bbe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classNDOSolver.html">NDOSolver</a>* GetNDOSolver </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method allows to read back the pointer to the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> that has been passed to the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> through <a class="el" href="classFiOracle.html#a3a4ace42fe051de8bae0feccea1bce16" title="This method is meant to pass to the FiOracle a pointer to the NDOSolver object that is using it...">SetNDOSolver()</a> [see above], if any. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
