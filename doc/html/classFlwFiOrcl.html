<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>CNDSM: FlwFiOrcl Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CNDSM
   &#160;<span id="projectnumber">1.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classFlwFiOrcl.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classFlwFiOrcl-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FlwFiOrcl Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class instantiates the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> interface [see <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>] to solve the flow Lagrangian relaxation of the (Fixed-Charge) Multicommodity Min Cost Flow Problem ((FC-)MMCF), possibly with "easy" components for the design variables.  
 <a href="classFlwFiOrcl.html#details">More...</a></p>

<p><code>#include &lt;FlwFiOrcl.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FlwFiOrcl:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classFlwFiOrcl.png" usemap="#FlwFiOrcl_map" alt=""/>
  <map id="FlwFiOrcl_map" name="FlwFiOrcl_map">
<area href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have..." alt="FiOracle" shape="rect" coords="0,0,68,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Types</div></td></tr>
<tr class="inherit_header pub_types_classFiOracle"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classFiOracle')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classFiOracle.html">FiOracle</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a617eae97addf230369ca85912ab345ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#a617eae97addf230369ca85912ab345ef">NewGi</a> (<a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> wFi=Inf&lt; <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())</td></tr>
<tr class="memdesc:a617eae97addf230369ca85912ab345ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first time <a class="el" href="classFlwFiOrcl.html#a617eae97addf230369ca85912ab345ef" title="The first time NewGi() is called, it computes the &quot;true&quot; subgradients. ">NewGi()</a> is called, it computes the "true" subgradients.  <a href="#a617eae97addf230369ca85912ab345ef">More...</a><br /></td></tr>
<tr class="separator:a617eae97addf230369ca85912ab345ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ff442d7df1412f96dcfe97660f6451"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#a39ff442d7df1412f96dcfe97660f6451">GetPar</a> (const int wp, bool &amp;value)</td></tr>
<tr class="memdesc:a39ff442d7df1412f96dcfe97660f6451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the current value of the "bool" parameters of the FlwFiOracle.  <a href="#a39ff442d7df1412f96dcfe97660f6451">More...</a><br /></td></tr>
<tr class="separator:a39ff442d7df1412f96dcfe97660f6451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6da8ac4271461aa61b766d63325feb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#a1e6da8ac4271461aa61b766d63325feb">GetPar</a> (const int wp, <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &amp;value)</td></tr>
<tr class="memdesc:a1e6da8ac4271461aa61b766d63325feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the current value of the "int" parameters of the FlwFiOracle [see above].  <a href="#a1e6da8ac4271461aa61b766d63325feb">More...</a><br /></td></tr>
<tr class="separator:a1e6da8ac4271461aa61b766d63325feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72544a64a8e290b4cdb6e9e760956c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae72544a64a8e290b4cdb6e9e760956c3"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#ae72544a64a8e290b4cdb6e9e760956c3">~FlwFiOrcl</a> ()</td></tr>
<tr class="memdesc:ae72544a64a8e290b4cdb6e9e760956c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of the class: it must be virtual. <br /></td></tr>
<tr class="separator:ae72544a64a8e290b4cdb6e9e760956c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructor</div></td></tr>
<tr class="memitem:a1bedd126dd189882b0bb0855962bc7f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#a1bedd126dd189882b0bb0855962bc7f8">FlwFiOrcl</a> (<a class="el" href="classGraph.html">Graph</a> *g, istream *iStrm=NULL)</td></tr>
<tr class="memdesc:a1bedd126dd189882b0bb0855962bc7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the class.  <a href="#a1bedd126dd189882b0bb0855962bc7f8">More...</a><br /></td></tr>
<tr class="separator:a1bedd126dd189882b0bb0855962bc7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Other initializations</div></td></tr>
<tr class="memitem:ad188c78f5811dd712f6078a34b4ee123"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#ad188c78f5811dd712f6078a34b4ee123">SetFiLog</a> (ostream *outs=0, const char lvl=0)</td></tr>
<tr class="memdesc:ad188c78f5811dd712f6078a34b4ee123"><td class="mdescLeft">&#160;</td><td class="mdescRight">lvl controls the "level of verbosity" of the code.  <a href="#ad188c78f5811dd712f6078a34b4ee123">More...</a><br /></td></tr>
<tr class="separator:ad188c78f5811dd712f6078a34b4ee123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a251f92c9d5b50f85a0ed93a3fc438"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36a251f92c9d5b50f85a0ed93a3fc438"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetMaxName</b> (<a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> MxNme)</td></tr>
<tr class="separator:a36a251f92c9d5b50f85a0ed93a3fc438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4cac85adf4298bc87c3bb72b3b9325"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#a6c4cac85adf4298bc87c3bb72b3b9325">SetAggregate</a> (bool aggrgt=true)</td></tr>
<tr class="memdesc:a6c4cac85adf4298bc87c3bb72b3b9325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set aggregation option.  <a href="#a6c4cac85adf4298bc87c3bb72b3b9325">More...</a><br /></td></tr>
<tr class="separator:a6c4cac85adf4298bc87c3bb72b3b9325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82af0e858f6fe842e35ac010558877a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#a82af0e858f6fe842e35ac010558877a5">SetRelax</a> (const char sp4= 'w', bool YiE=false, <a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> sp1=0, <a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> sp2=0, <a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> sp3=0)</td></tr>
<tr class="memdesc:a82af0e858f6fe842e35ac010558877a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set relaxation of Individual Capacities or off.  <a href="#a82af0e858f6fe842e35ac010558877a5">More...</a><br /></td></tr>
<tr class="separator:a82af0e858f6fe842e35ac010558877a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653281899d9d813e910d6da82a589a0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#a653281899d9d813e910d6da82a589a0f">SetInitialSet</a> (<a class="el" href="classMMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> Bse)</td></tr>
<tr class="memdesc:a653281899d9d813e910d6da82a589a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the initial dictionary.  <a href="#a653281899d9d813e910d6da82a589a0f">More...</a><br /></td></tr>
<tr class="separator:a653281899d9d813e910d6da82a589a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6cd24d6cbc7834ebfe496db251dc62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#acb6cd24d6cbc7834ebfe496db251dc62">SetEasy</a> (bool YIsE=false)</td></tr>
<tr class="memdesc:acb6cd24d6cbc7834ebfe496db251dc62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Easy option.  <a href="#acb6cd24d6cbc7834ebfe496db251dc62">More...</a><br /></td></tr>
<tr class="separator:acb6cd24d6cbc7834ebfe496db251dc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading other results</div></td></tr>
<tr class="memitem:ad616ccf391200f75103a424ed0a06954"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad616ccf391200f75103a424ed0a06954"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><b>GetLowerBound</b> (<a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> wFi=Inf&lt; <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())</td></tr>
<tr class="separator:ad616ccf391200f75103a424ed0a06954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3767b41652cef7773f55884517b11ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3767b41652cef7773f55884517b11ee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetLowerBound</b> (HpNum lowB=Inf&lt; HpNum &gt;())</td></tr>
<tr class="separator:af3767b41652cef7773f55884517b11ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873ae3315d2c051ff4988a587883b21e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a873ae3315d2c051ff4988a587883b21e"></a>
<a class="el" href="classFiOracle.html#a04867eec1c7917816fb94b85c12ba6db">FiStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetFiStatus</b> (<a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> wFi=Inf&lt; <a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())</td></tr>
<tr class="separator:a873ae3315d2c051ff4988a587883b21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552d3a2f77f5aa587e7b84799b0c6134"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#a552d3a2f77f5aa587e7b84799b0c6134">AddTime</a> (void)</td></tr>
<tr class="memdesc:a552d3a2f77f5aa587e7b84799b0c6134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the user + system time (in seconds) spent during the execution for adding of new beta variables.  <a href="#a552d3a2f77f5aa587e7b84799b0c6134">More...</a><br /></td></tr>
<tr class="separator:a552d3a2f77f5aa587e7b84799b0c6134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaded2b439b4dcd881bedd255952dd32b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#aaded2b439b4dcd881bedd255952dd32b">RemTime</a> (void)</td></tr>
<tr class="memdesc:aaded2b439b4dcd881bedd255952dd32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">As <a class="el" href="classFlwFiOrcl.html#a552d3a2f77f5aa587e7b84799b0c6134" title="Returns the user + system time (in seconds) spent during the execution for adding of new beta variabl...">AddTime()</a> [see above], it returns the time spent for removing the beta variables.  <a href="#aaded2b439b4dcd881bedd255952dd32b">More...</a><br /></td></tr>
<tr class="separator:aaded2b439b4dcd881bedd255952dd32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7717ab10155d4227966946d374dce479"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7717ab10155d4227966946d374dce479"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>checkSolution</b> (void)</td></tr>
<tr class="separator:a7717ab10155d4227966946d374dce479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classFiOracle"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classFiOracle')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classFiOracle.html">FiOracle</a></td></tr>
<tr class="memitem:gaca9733adf962bbe6ae97f1039c0a3bbe inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classNDOSolver.html">NDOSolver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EasyComp.html#gaca9733adf962bbe6ae97f1039c0a3bbe">GetNDOSolver</a> (void)</td></tr>
<tr class="memdesc:gaca9733adf962bbe6ae97f1039c0a3bbe inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allows to read back the pointer to the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> that has been passed to the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> through <a class="el" href="classFiOracle.html#a3a4ace42fe051de8bae0feccea1bce16" title="This method is meant to pass to the FiOracle a pointer to the NDOSolver object that is using it...">SetNDOSolver()</a> [see above], if any.  <a href="group__EasyComp.html#gaca9733adf962bbe6ae97f1039c0a3bbe">More...</a><br /></td></tr>
<tr class="separator:gaca9733adf962bbe6ae97f1039c0a3bbe inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f8eccd8ffb760f2e13a6672dca6752 inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#ae6f8eccd8ffb760f2e13a6672dca6752">FiOracle</a> (void)</td></tr>
<tr class="memdesc:ae6f8eccd8ffb760f2e13a6672dca6752 inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the class: takes no arguments, since everything that concerns the real evaluation of the function must be done in derived classes, which will have their parameters.  <a href="#ae6f8eccd8ffb760f2e13a6672dca6752">More...</a><br /></td></tr>
<tr class="separator:ae6f8eccd8ffb760f2e13a6672dca6752 inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4ace42fe051de8bae0feccea1bce16 inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a3a4ace42fe051de8bae0feccea1bce16">SetNDOSolver</a> (<a class="el" href="classNDOSolver.html">NDOSolver</a> *NwSlvr=0)</td></tr>
<tr class="memdesc:a3a4ace42fe051de8bae0feccea1bce16 inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is meant to pass to the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> a pointer to the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> object that is using it, and that must be warned if the function Fi changes.  <a href="#a3a4ace42fe051de8bae0feccea1bce16">More...</a><br /></td></tr>
<tr class="separator:a3a4ace42fe051de8bae0feccea1bce16 inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2bdf88862022c6cd471546ddfeb602d inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#ad2bdf88862022c6cd471546ddfeb602d">SetFiTime</a> (const bool TimeIt=true)</td></tr>
<tr class="memdesc:ad2bdf88862022c6cd471546ddfeb602d inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classFiOracle.html#ad2bdf88862022c6cd471546ddfeb602d" title="SetFiTime() allocates an OPTtimers object [see OPTtypes.h] that should be used for timing the calls t...">SetFiTime()</a> allocates an OPTtimers object [see OPTtypes.h] that should be used for timing the calls to relevant methods of the class.  <a href="#ad2bdf88862022c6cd471546ddfeb602d">More...</a><br /></td></tr>
<tr class="separator:ad2bdf88862022c6cd471546ddfeb602d inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a848c4b8e474ab60be98c6acca48ccf inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a8a848c4b8e474ab60be98c6acca48ccf">SetMaxName</a> (cIndex MxNme=0)</td></tr>
<tr class="memdesc:a8a848c4b8e474ab60be98c6acca48ccf inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">In some cases, an optimal solution of the dual problem (D) [see the general notes] is a mostly welcome thing; typically, this solution is given in terms of convex (nonnegative) multipliers which form 0 out of a set of subgradients (linear constraints) generated during the run of a NDO algorithm [see ReadMult() in <a class="el" href="NDOSlver_8h.html" title="Definition of the abstract base class NDOSolver, which defines the interface for convex minimization ...">NDOSlver.h</a>].  <a href="#a8a848c4b8e474ab60be98c6acca48ccf">More...</a><br /></td></tr>
<tr class="separator:a8a848c4b8e474ab60be98c6acca48ccf inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23f3cd83a8888679a62a20aac916fd2 inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#ab23f3cd83a8888679a62a20aac916fd2">MaxNConst</a> (void)</td></tr>
<tr class="memdesc:ab23f3cd83a8888679a62a20aac916fd2 inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">GetMaxN() returns the number of constraints.  <a href="#ab23f3cd83a8888679a62a20aac916fd2">More...</a><br /></td></tr>
<tr class="separator:ab23f3cd83a8888679a62a20aac916fd2 inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9df04b1e885dafb6121783af2e575bb inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#ac9df04b1e885dafb6121783af2e575bb">IsFiContinuous</a> (cIndex NrFi=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:ac9df04b1e885dafb6121783af2e575bb inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the function is continuous.  <a href="#ac9df04b1e885dafb6121783af2e575bb">More...</a><br /></td></tr>
<tr class="separator:ac9df04b1e885dafb6121783af2e575bb inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4298122bb8cdff6d17a26908af36fa42 inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a4298122bb8cdff6d17a26908af36fa42">IsFiConvex</a> (cIndex NrFi=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:a4298122bb8cdff6d17a26908af36fa42 inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the function is continuous.  <a href="#a4298122bb8cdff6d17a26908af36fa42">More...</a><br /></td></tr>
<tr class="separator:a4298122bb8cdff6d17a26908af36fa42 inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ccfa71f5548ef17eb5cb51c2fd3531 inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a33ccfa71f5548ef17eb5cb51c2fd3531">HasGi</a> (cIndex NrFi=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:a33ccfa71f5548ef17eb5cb51c2fd3531 inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the oracle is able to provide first-order information about the function.  <a href="#a33ccfa71f5548ef17eb5cb51c2fd3531">More...</a><br /></td></tr>
<tr class="separator:a33ccfa71f5548ef17eb5cb51c2fd3531 inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef271b80f24b25980d6b0ee4ff17edd inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a1ef271b80f24b25980d6b0ee4ff17edd">IsGiContinuous</a> (cIndex NrFi)</td></tr>
<tr class="memdesc:a1ef271b80f24b25980d6b0ee4ff17edd inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the first-order information of the function [see <a class="el" href="classFiOracle.html#a33ccfa71f5548ef17eb5cb51c2fd3531" title="Returns true if the oracle is able to provide first-order information about the function. ">HasGi()</a> above] is continuous, i.e., the function is differentiable.  <a href="#a1ef271b80f24b25980d6b0ee4ff17edd">More...</a><br /></td></tr>
<tr class="separator:a1ef271b80f24b25980d6b0ee4ff17edd inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622526f48706a50cc884e474c02a3ca6 inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a622526f48706a50cc884e474c02a3ca6">HasH</a> (cIndex NrFi)</td></tr>
<tr class="memdesc:a622526f48706a50cc884e474c02a3ca6 inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the oracle is able to provide second-order information about the function; for this to happen, (the corresponding) <a class="el" href="classFiOracle.html#a33ccfa71f5548ef17eb5cb51c2fd3531" title="Returns true if the oracle is able to provide first-order information about the function. ">HasGi()</a> also has to return true, that is, an oracle being able to provide second-order information is also necessarily able to provide first-order information.  <a href="#a622526f48706a50cc884e474c02a3ca6">More...</a><br /></td></tr>
<tr class="separator:a622526f48706a50cc884e474c02a3ca6 inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabe6e666a34157e78f2bb7b52862944 inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#aaabe6e666a34157e78f2bb7b52862944">IsHContinuous</a> (cIndex NrFi)</td></tr>
<tr class="memdesc:aaabe6e666a34157e78f2bb7b52862944 inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the second-order information of the function [see <a class="el" href="classFiOracle.html#a622526f48706a50cc884e474c02a3ca6" title="Returns true if the oracle is able to provide second-order information about the function; for this t...">HasH()</a> above] is continuous, i.e., the function is twice differentiable.  <a href="#aaabe6e666a34157e78f2bb7b52862944">More...</a><br /></td></tr>
<tr class="separator:aaabe6e666a34157e78f2bb7b52862944 inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3bd9d923f86ecea4c63fdf599f2674 inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a1c3bd9d923f86ecea4c63fdf599f2674">GetMaxName</a> (void) const </td></tr>
<tr class="memdesc:a1c3bd9d923f86ecea4c63fdf599f2674 inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of dual information stored in the <a class="el" href="classFiOracle.html#ae6f8eccd8ffb760f2e13a6672dca6752" title="Constructor of the class: takes no arguments, since everything that concerns the real evaluation of t...">FiOracle()</a>, as set by the lastes call to <a class="el" href="classFiOracle.html#a8a848c4b8e474ab60be98c6acca48ccf" title="In some cases, an optimal solution of the dual problem (D) [see the general notes] is a mostly welcom...">SetMaxName()</a>.  <a href="#a1c3bd9d923f86ecea4c63fdf599f2674">More...</a><br /></td></tr>
<tr class="separator:a1c3bd9d923f86ecea4c63fdf599f2674 inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5deec7bb1a3f6dd38e937b1d10e302df inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a5deec7bb1a3f6dd38e937b1d10e302df">GetMinusInfinity</a> (void)</td></tr>
<tr class="memdesc:a5deec7bb1a3f6dd38e937b1d10e302df inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function Fi to be minimized may be unbounded below, i.e., its infimum may be - INF.  <a href="#a5deec7bb1a3f6dd38e937b1d10e302df">More...</a><br /></td></tr>
<tr class="separator:a5deec7bb1a3f6dd38e937b1d10e302df inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa3c6db35753d8771cf7edfa91b4511 inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a0aa3c6db35753d8771cf7edfa91b4511">GetMaxNZ</a> (cIndex wFi=Inf&lt; Index &gt;()) const </td></tr>
<tr class="memdesc:a0aa3c6db35753d8771cf7edfa91b4511 inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">The subgradients returned by the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> may happen to be very "sparse", i.e., containing very few nonzeroes; sometimes, the maximum number of nonzeroes is known in advance.  <a href="#a0aa3c6db35753d8771cf7edfa91b4511">More...</a><br /></td></tr>
<tr class="separator:a0aa3c6db35753d8771cf7edfa91b4511 inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6cf4670f5890cccb12c2a29541476a0 inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#ac6cf4670f5890cccb12c2a29541476a0">GetMaxCNZ</a> (cIndex wFi=Inf&lt; Index &gt;()) const </td></tr>
<tr class="memdesc:ac6cf4670f5890cccb12c2a29541476a0 inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method has the same meaning as <a class="el" href="classFiOracle.html#a0aa3c6db35753d8771cf7edfa91b4511" title="The subgradients returned by the FiOracle may happen to be very &quot;sparse&quot;, i.e., containing very few n...">GetMaxNZ()</a> [see above], but it is about the sparsity of constraints rather than subgradients, as the two may be different.  <a href="#ac6cf4670f5890cccb12c2a29541476a0">More...</a><br /></td></tr>
<tr class="separator:ac6cf4670f5890cccb12c2a29541476a0 inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179fff6118652ccec0be73c6be9392ef inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a179fff6118652ccec0be73c6be9392ef">GetUC</a> (cIndex i)</td></tr>
<tr class="memdesc:a179fff6118652ccec0be73c6be9392ef inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variables of the function may be either constrained in sign, i.e., required to be nonnegative, or unconstrained; if Fi is a Lagrangian function, for instance, constrained variables correspond to inequality constraints while unconstrained variables correspond to equality constraints.  <a href="#a179fff6118652ccec0be73c6be9392ef">More...</a><br /></td></tr>
<tr class="separator:a179fff6118652ccec0be73c6be9392ef inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d98454a28ee04340a55e6eb74008344 inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual LMNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a7d98454a28ee04340a55e6eb74008344">GetUB</a> (cIndex i)</td></tr>
<tr class="memdesc:a7d98454a28ee04340a55e6eb74008344 inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">For some of the variables of the function, an upper bound on the optimal value may be known.  <a href="#a7d98454a28ee04340a55e6eb74008344">More...</a><br /></td></tr>
<tr class="separator:a7d98454a28ee04340a55e6eb74008344 inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d48adde3013240cedc4c12f7e849cf4 inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual LMNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a2d48adde3013240cedc4c12f7e849cf4">GetBndEps</a> (void)</td></tr>
<tr class="memdesc:a2d48adde3013240cedc4c12f7e849cf4 inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">When some of the variables are declared by the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> either to be nonnegative [see <a class="el" href="classFiOracle.html#a179fff6118652ccec0be73c6be9392ef" title="The variables of the function may be either constrained in sign, i.e., required to be nonnegative...">GetUC()</a> above] or to possess a finite upper bound [see <a class="el" href="classFiOracle.html#a7d98454a28ee04340a55e6eb74008344" title="For some of the variables of the function, an upper bound on the optimal value may be known...">GetUB()</a> above], the NDO algorithm should take care to only provide values for these variables which satisfy 0 &lt;= Lambda[ i ] &lt;= GetUB( i ) in the points it intends to probe the function in [see <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a> below].  <a href="#a2d48adde3013240cedc4c12f7e849cf4">More...</a><br /></td></tr>
<tr class="separator:a2d48adde3013240cedc4c12f7e849cf4 inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bc426be37980f2cf9d1c43ac166f55 inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#ac9bc426be37980f2cf9d1c43ac166f55">GetGlobalLipschitz</a> (cIndex wFi=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:ac9bc426be37980f2cf9d1c43ac166f55 inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Lipschitz constant.  <a href="#ac9bc426be37980f2cf9d1c43ac166f55">More...</a><br /></td></tr>
<tr class="separator:ac9bc426be37980f2cf9d1c43ac166f55 inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5a82019520f11aeeed9501d044e5ee3 inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EasyComp.html#gad5a82019520f11aeeed9501d044e5ee3">GetBNC</a> (cIndex wFi)</td></tr>
<tr class="memdesc:gad5a82019520f11aeeed9501d044e5ee3 inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of variables of the "easy" linear problem which describes Fi[ wFi ], that is, the number of columns of the matrices B[ wFi ] and A[ wFi ] and the lenght of the vectors x[ wFi ], c[ wFi ], l[ wFi ] and u[ wFi ].  <a href="group__EasyComp.html#gad5a82019520f11aeeed9501d044e5ee3">More...</a><br /></td></tr>
<tr class="separator:gad5a82019520f11aeeed9501d044e5ee3 inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30047aa832e702b7926cc65fba67625a inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EasyComp.html#ga30047aa832e702b7926cc65fba67625a">GetBNR</a> (cIndex wFi)</td></tr>
<tr class="memdesc:ga30047aa832e702b7926cc65fba67625a inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rows of the matrix B[ wFi ] and the lenght of the vectors d[ wFi ] and e[ wFi ]; GetBNR( wFi ) can return 0 if only "box" constraints are imposed on the variables x[ wFi ].  <a href="group__EasyComp.html#ga30047aa832e702b7926cc65fba67625a">More...</a><br /></td></tr>
<tr class="separator:ga30047aa832e702b7926cc65fba67625a inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2164e0f768d3be7dbbda360cc8f646fc inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EasyComp.html#ga2164e0f768d3be7dbbda360cc8f646fc">GetBNZ</a> (cIndex wFi)</td></tr>
<tr class="memdesc:ga2164e0f768d3be7dbbda360cc8f646fc inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nonzeroes in the matrix B[ wFi ]; this is clearly 0 if GetBNR( wFi ) == 0.  <a href="group__EasyComp.html#ga2164e0f768d3be7dbbda360cc8f646fc">More...</a><br /></td></tr>
<tr class="separator:ga2164e0f768d3be7dbbda360cc8f646fc inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1771551bac42d9e58f59116189c54ee inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EasyComp.html#gac1771551bac42d9e58f59116189c54ee">GetBDesc</a> (cIndex wFi, int *Bbeg, int *Bind, double *Bval, double *lhs, double *rhs, double *cst, double *lbd, double *ubd)</td></tr>
<tr class="memdesc:gac1771551bac42d9e58f59116189c54ee inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a description of the matrix B[ wFi ] and of the vectors d[ wFi ], e[ wFi ], c[ wFi ], l[ wFi ] and u[ wFi ].  <a href="group__EasyComp.html#gac1771551bac42d9e58f59116189c54ee">More...</a><br /></td></tr>
<tr class="separator:gac1771551bac42d9e58f59116189c54ee inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9811ae42439c72a16806d3ce01db7557 inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EasyComp.html#ga9811ae42439c72a16806d3ce01db7557">GetANZ</a> (cIndex wFi, cIndex strt=0, Index stp=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:ga9811ae42439c72a16806d3ce01db7557 inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nonzeroes in the matrix A[ wFi ] (whose number of columns is GetBNC( wFi ) and whose number of rows is <a class="el" href="classFiOracle.html#a9395fc2b1320d4e44be62366feec4e6e" title="Returns the number of variables of the function, i.e., the (maximum) size of the vectors to be passed...">GetNumVar()</a>); more precisely, it returns the number of nonzeroes in the submatrix of A[ wFi ] containing all the rows with indices between start and min( stp , <a class="el" href="classFiOracle.html#a9395fc2b1320d4e44be62366feec4e6e" title="Returns the number of variables of the function, i.e., the (maximum) size of the vectors to be passed...">GetNumVar()</a> ) - 1 (corresponding to the variables with those "names").  <a href="group__EasyComp.html#ga9811ae42439c72a16806d3ce01db7557">More...</a><br /></td></tr>
<tr class="separator:ga9811ae42439c72a16806d3ce01db7557 inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40c0ae954bd72a9b30bbefc013e2a2ce inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EasyComp.html#ga40c0ae954bd72a9b30bbefc013e2a2ce">GetADesc</a> (cIndex wFi, int *Abeg, int *Aind, double *Aval, cIndex strt=0, Index stp=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:ga40c0ae954bd72a9b30bbefc013e2a2ce inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a description of the submatrix of A[ wFi ] containing all the rows with indices between start and min( stp , GetNumVar() ) - 1; the meaning of Abeg, Aind and Aval is analogous to that of Bbeg, Bind and Bval in <a class="el" href="group__EasyComp.html#gac1771551bac42d9e58f59116189c54ee" title="Returns a description of the matrix B[ wFi ] and of the vectors d[ wFi ], e[ wFi ], c[ wFi ], l[ wFi ] and u[ wFi ]. ">GetBDesc()</a> [see above].  <a href="group__EasyComp.html#ga40c0ae954bd72a9b30bbefc013e2a2ce">More...</a><br /></td></tr>
<tr class="separator:ga40c0ae954bd72a9b30bbefc013e2a2ce inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9e2c034a2af960f3a794cad100bb26 inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#add9e2c034a2af960f3a794cad100bb26">SetLamBase</a> (cIndex_Set LmbdB=0, cIndex LmbdBD=0)</td></tr>
<tr class="memdesc:add9e2c034a2af960f3a794cad100bb26 inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">The "format" of the vector Lambda set by <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a> [see above] depends on the argument LamB passed to <a class="el" href="classFiOracle.html#add9e2c034a2af960f3a794cad100bb26" title="The &quot;format&quot; of the vector Lambda set by SetLambda() [see above] depends on the argument LamB passed ...">SetLamBase()</a>.  <a href="#add9e2c034a2af960f3a794cad100bb26">More...</a><br /></td></tr>
<tr class="separator:add9e2c034a2af960f3a794cad100bb26 inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90312f57c5be3fb8435a1f394c29533 inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533">Fi</a> (cIndex wFi=Inf&lt; Index &gt;())=0</td></tr>
<tr class="memdesc:aa90312f57c5be3fb8435a1f394c29533 inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method must return the value of the function Fi to be minimized in the point Lmbd set by <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a> and <a class="el" href="classFiOracle.html#add9e2c034a2af960f3a794cad100bb26" title="The &quot;format&quot; of the vector Lambda set by SetLambda() [see above] depends on the argument LamB passed ...">SetLamBase()</a> [see above].  <a href="#aa90312f57c5be3fb8435a1f394c29533">More...</a><br /></td></tr>
<tr class="separator:aa90312f57c5be3fb8435a1f394c29533 inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7d643acc6b898fe0cd91b8dd042d0f inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#aec7d643acc6b898fe0cd91b8dd042d0f">NewGi</a> (cIndex wFi=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:aec7d643acc6b898fe0cd91b8dd042d0f inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method must be called to ask the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> whether it can produce a "new" item corresponding to the point Lambda set by <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a> and <a class="el" href="classFiOracle.html#add9e2c034a2af960f3a794cad100bb26" title="The &quot;format&quot; of the vector Lambda set by SetLambda() [see above] depends on the argument LamB passed ...">SetLamBase()</a> [see above].  <a href="#aec7d643acc6b898fe0cd91b8dd042d0f">More...</a><br /></td></tr>
<tr class="separator:aec7d643acc6b898fe0cd91b8dd042d0f inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc17c68285be9171d126705efb15cdd inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd">GetGi</a> (SgRow SubG, cIndex_Set &amp;SGBse, cIndex Name=Inf&lt; Index &gt;(), cIndex strt=0, Index stp=Inf&lt; Index &gt;())=0</td></tr>
<tr class="memdesc:a4bc17c68285be9171d126705efb15cdd inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a> [and <a class="el" href="classFiOracle.html#adf35d71a3d63ba31c64910bdbe650864" title="GetVal() [and GetGi(), see above] can be used to query information about the items. ">GetVal()</a>, see below] can be used to query information about the items.  <a href="#a4bc17c68285be9171d126705efb15cdd">More...</a><br /></td></tr>
<tr class="separator:a4bc17c68285be9171d126705efb15cdd inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf35d71a3d63ba31c64910bdbe650864 inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#adf35d71a3d63ba31c64910bdbe650864">GetVal</a> (cIndex Name=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:adf35d71a3d63ba31c64910bdbe650864 inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classFiOracle.html#adf35d71a3d63ba31c64910bdbe650864" title="GetVal() [and GetGi(), see above] can be used to query information about the items. ">GetVal()</a> [and <a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a>, see above] can be used to query information about the items.  <a href="#adf35d71a3d63ba31c64910bdbe650864">More...</a><br /></td></tr>
<tr class="separator:adf35d71a3d63ba31c64910bdbe650864 inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e53e0ca809a3be0075a6b8d53fd3b07 inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a2e53e0ca809a3be0075a6b8d53fd3b07">SetGiName</a> (cIndex Name)</td></tr>
<tr class="memdesc:a2e53e0ca809a3be0075a6b8d53fd3b07 inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">After that a new item has been produced, i.e., a call to <a class="el" href="classFiOracle.html#aec7d643acc6b898fe0cd91b8dd042d0f" title="This method must be called to ask the FiOracle whether it can produce a &quot;new&quot; item corresponding to t...">NewGi()</a> returned true, and that (possibly) <a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a> / <a class="el" href="classFiOracle.html#adf35d71a3d63ba31c64910bdbe650864" title="GetVal() [and GetGi(), see above] can be used to query information about the items. ">GetVal()</a> have been used to retrieve information about it, the NDO solver can use <a class="el" href="classFiOracle.html#a2e53e0ca809a3be0075a6b8d53fd3b07" title="After that a new item has been produced, i.e., a call to NewGi() returned true, and that (possibly) G...">SetGiName()</a> to tell the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> that a "name" has been assigned to that new item by NDO solver.  <a href="#a2e53e0ca809a3be0075a6b8d53fd3b07">More...</a><br /></td></tr>
<tr class="separator:a2e53e0ca809a3be0075a6b8d53fd3b07 inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd48c1da81bbd115bd8e41e4abc8f936 inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#acd48c1da81bbd115bd8e41e4abc8f936">GetLowerBound</a> (cIndex wFi=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:acd48c1da81bbd115bd8e41e4abc8f936 inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">In some cases, a Lower Bound on the minimal value of Fi is known; if Fi is a Lagrangian function, for instance, the objective function value c( x ) of any dual feasible solution x (s.t.  <a href="#acd48c1da81bbd115bd8e41e4abc8f936">More...</a><br /></td></tr>
<tr class="separator:acd48c1da81bbd115bd8e41e4abc8f936 inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5c05cf616d9205ee6d83ecbc9fafc5 inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classFiOracle.html#a04867eec1c7917816fb94b85c12ba6db">FiStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#aad5c05cf616d9205ee6d83ecbc9fafc5">GetFiStatus</a> (Index wFi=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:aad5c05cf616d9205ee6d83ecbc9fafc5 inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classFiOracle.html#aad5c05cf616d9205ee6d83ecbc9fafc5" title="GetFiStatus() returns the internal status of the FiOracle object. ">GetFiStatus()</a> returns the internal status of the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> object.  <a href="#aad5c05cf616d9205ee6d83ecbc9fafc5">More...</a><br /></td></tr>
<tr class="separator:aad5c05cf616d9205ee6d83ecbc9fafc5 inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87131a6ed4539663f0406932bcfb007 inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#ae87131a6ed4539663f0406932bcfb007">FiTime</a> (double &amp;t_us, double &amp;t_ss)</td></tr>
<tr class="memdesc:ae87131a6ed4539663f0406932bcfb007 inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this method is called within any of the methods of the class that are "actively timed" (this depends on the subclasses), it returns the user and sistem time (in seconds) since the start of that method.  <a href="#ae87131a6ed4539663f0406932bcfb007">More...</a><br /></td></tr>
<tr class="separator:ae87131a6ed4539663f0406932bcfb007 inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e53341358998440f1d1d9436b6cdfec inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a4e53341358998440f1d1d9436b6cdfec">FiTime</a> (void)</td></tr>
<tr class="memdesc:a4e53341358998440f1d1d9436b6cdfec inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">As <a class="el" href="classFiOracle.html#ae87131a6ed4539663f0406932bcfb007" title="If this method is called within any of the methods of the class that are &quot;actively timed&quot; (this depen...">FiTime( double &amp; , double &amp; )</a> [see above], except that returns the total (system + user ) time.  <a href="#a4e53341358998440f1d1d9436b6cdfec">More...</a><br /></td></tr>
<tr class="separator:a4e53341358998440f1d1d9436b6cdfec inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80f5c831464c830e75d9a86c18eb1e3 inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#aa80f5c831464c830e75d9a86c18eb1e3">Deleted</a> (cIndex i=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:aa80f5c831464c830e75d9a86c18eb1e3 inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">If so instructed by <a class="el" href="classFiOracle.html#a8a848c4b8e474ab60be98c6acca48ccf" title="In some cases, an optimal solution of the dual problem (D) [see the general notes] is a mostly welcom...">SetMaxName()</a> [see above], the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> should keep "dual" information attached to the subgradients/constraints produced [see <a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a> above].  <a href="#aa80f5c831464c830e75d9a86c18eb1e3">More...</a><br /></td></tr>
<tr class="separator:aa80f5c831464c830e75d9a86c18eb1e3 inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4d7bd37454c8023326b3668e4f4c27 inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a2b4d7bd37454c8023326b3668e4f4c27">Aggregate</a> (cHpRow Mlt, cIndex_Set NmSt, cIndex Dm, cIndex NwNm)</td></tr>
<tr class="memdesc:a2b4d7bd37454c8023326b3668e4f4c27 inherit pub_methods_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Many NDO algorithms perform operations on the subgradients that they obtain from the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>; the most common operation is taking linear or convex combinations of some subgradients/constraints.  <a href="#a2b4d7bd37454c8023326b3668e4f4c27">More...</a><br /></td></tr>
<tr class="separator:a2b4d7bd37454c8023326b3668e4f4c27 inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae10264c96f255eb0f1724d12170045 inherit pub_methods_classFiOracle"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ae10264c96f255eb0f1724d12170045"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~FiOracle</b> ()</td></tr>
<tr class="separator:a5ae10264c96f255eb0f1724d12170045 inherit pub_methods_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Algorithmic parameters</div></td></tr>
<tr class="memitem:af0f39a2857b038758ca7fb0204c6ccd4"><td class="memItemLeft" align="right" valign="top">HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#af0f39a2857b038758ca7fb0204c6ccd4">EpsFi</a></td></tr>
<tr class="memdesc:af0f39a2857b038758ca7fb0204c6ccd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precision for the design problem.  <a href="#af0f39a2857b038758ca7fb0204c6ccd4">More...</a><br /></td></tr>
<tr class="separator:af0f39a2857b038758ca7fb0204c6ccd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefcc22d3b15ea4210473c724156d871c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefcc22d3b15ea4210473c724156d871c"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#aefcc22d3b15ea4210473c724156d871c">EpsCon</a></td></tr>
<tr class="memdesc:aefcc22d3b15ea4210473c724156d871c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precision for the constraints problem. <br /></td></tr>
<tr class="separator:aefcc22d3b15ea4210473c724156d871c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99977ca83ef6b4dcbd9b010c67649b33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#a99977ca83ef6b4dcbd9b010c67649b33">Aggrgtd</a></td></tr>
<tr class="memdesc:a99977ca83ef6b4dcbd9b010c67649b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Agreggation flag.  <a href="#a99977ca83ef6b4dcbd9b010c67649b33">More...</a><br /></td></tr>
<tr class="separator:a99977ca83ef6b4dcbd9b010c67649b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4caf669ab1aa3040358727fd2de40e64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#a4caf669ab1aa3040358727fd2de40e64">YIsEasy</a></td></tr>
<tr class="memdesc:a4caf669ab1aa3040358727fd2de40e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if the ys are easy components.  <a href="#a4caf669ab1aa3040358727fd2de40e64">More...</a><br /></td></tr>
<tr class="separator:a4caf669ab1aa3040358727fd2de40e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Lagrangian data</div></td></tr>
<tr class="memitem:af2c0bb5f92075a8cdc9060d1386ea438"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#af2c0bb5f92075a8cdc9060d1386ea438">InvULambda</a></td></tr>
<tr class="memdesc:af2c0bb5f92075a8cdc9060d1386ea438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse vocabulary of ULambda.  <a href="#af2c0bb5f92075a8cdc9060d1386ea438">More...</a><br /></td></tr>
<tr class="separator:af2c0bb5f92075a8cdc9060d1386ea438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a3b9d070f1ddf5c202d8cedcd82b80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#a43a3b9d070f1ddf5c202d8cedcd82b80">ZLambdaCount</a></td></tr>
<tr class="memdesc:a43a3b9d070f1ddf5c202d8cedcd82b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter of iterations with value zero for each variable.  <a href="#a43a3b9d070f1ddf5c202d8cedcd82b80">More...</a><br /></td></tr>
<tr class="separator:a43a3b9d070f1ddf5c202d8cedcd82b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d714c86e13a0c304053d0edaec3a370"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d714c86e13a0c304053d0edaec3a370"></a>
<a class="el" href="classMMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SGBse1</b></td></tr>
<tr class="separator:a3d714c86e13a0c304053d0edaec3a370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Instance data</div></td></tr>
<tr class="memitem:a2eafc63ded0de4be42a8c99695bb9908"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#a2eafc63ded0de4be42a8c99695bb9908">MaxNumVar</a></td></tr>
<tr class="memdesc:a2eafc63ded0de4be42a8c99695bb9908"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of variables.  <a href="#a2eafc63ded0de4be42a8c99695bb9908">More...</a><br /></td></tr>
<tr class="separator:a2eafc63ded0de4be42a8c99695bb9908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae218aa1fbadae57b65692e278fdb0051"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#ae218aa1fbadae57b65692e278fdb0051">OrigCosts</a></td></tr>
<tr class="memdesc:ae218aa1fbadae57b65692e278fdb0051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of original unit costs.  <a href="#ae218aa1fbadae57b65692e278fdb0051">More...</a><br /></td></tr>
<tr class="separator:ae218aa1fbadae57b65692e278fdb0051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002ad2186b3adc5fe18e35c3316bd706"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#a002ad2186b3adc5fe18e35c3316bd706">OrigXtrCosts</a></td></tr>
<tr class="memdesc:a002ad2186b3adc5fe18e35c3316bd706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of original design costs.  <a href="#a002ad2186b3adc5fe18e35c3316bd706">More...</a><br /></td></tr>
<tr class="separator:a002ad2186b3adc5fe18e35c3316bd706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d3f0af75e06d91ecb74b987a3724c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#ac1d3f0af75e06d91ecb74b987a3724c4">OrigCapacities</a></td></tr>
<tr class="memdesc:ac1d3f0af75e06d91ecb74b987a3724c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of original individual capacities.  <a href="#ac1d3f0af75e06d91ecb74b987a3724c4">More...</a><br /></td></tr>
<tr class="separator:ac1d3f0af75e06d91ecb74b987a3724c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2473bea633b02968f0ee4b05975990"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa2473bea633b02968f0ee4b05975990"></a>
<a class="el" href="classMMCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#afa2473bea633b02968f0ee4b05975990">OrigTotCap</a></td></tr>
<tr class="memdesc:afa2473bea633b02968f0ee4b05975990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of mutual capacity for the arcs. <br /></td></tr>
<tr class="separator:afa2473bea633b02968f0ee4b05975990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac2add7a8982339695b91fca4644847"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeac2add7a8982339695b91fca4644847"></a>
<a class="el" href="classMMCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#aeac2add7a8982339695b91fca4644847">OrigDeficits</a></td></tr>
<tr class="memdesc:aeac2add7a8982339695b91fca4644847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Original deficits. <br /></td></tr>
<tr class="separator:aeac2add7a8982339695b91fca4644847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87df88cd01480859ba973cdc4c51a3f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87df88cd01480859ba973cdc4c51a3f3"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#a87df88cd01480859ba973cdc4c51a3f3">LowerBound</a></td></tr>
<tr class="memdesc:a87df88cd01480859ba973cdc4c51a3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (coarse) lower bound on the value of Fi. <br /></td></tr>
<tr class="separator:a87df88cd01480859ba973cdc4c51a3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Solutions data</div></td></tr>
<tr class="memitem:a497d9f3e1f445591b68901241c578772"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a497d9f3e1f445591b68901241c578772"></a>
<a class="el" href="classMMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#a497d9f3e1f445591b68901241c578772">OldWFi</a></td></tr>
<tr class="memdesc:a497d9f3e1f445591b68901241c578772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Witch subproblem belongs the solution. <br /></td></tr>
<tr class="separator:a497d9f3e1f445591b68901241c578772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22d984cbce923b78fdcd93a0e955634"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac22d984cbce923b78fdcd93a0e955634"></a>
<a class="el" href="classMMCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#ac22d984cbce923b78fdcd93a0e955634">OldFSols</a></td></tr>
<tr class="memdesc:ac22d984cbce923b78fdcd93a0e955634"><td class="mdescLeft">&#160;</td><td class="mdescRight">History of subgradients (Flow Solution). <br /></td></tr>
<tr class="separator:ac22d984cbce923b78fdcd93a0e955634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade01d1fe826ee9ee290c2aebd643c620"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade01d1fe826ee9ee290c2aebd643c620"></a>
Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#ade01d1fe826ee9ee290c2aebd643c620">OldXSols</a></td></tr>
<tr class="memdesc:ade01d1fe826ee9ee290c2aebd643c620"><td class="mdescLeft">&#160;</td><td class="mdescRight">History of subgradients (Extra Solution). <br /></td></tr>
<tr class="separator:ade01d1fe826ee9ee290c2aebd643c620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc2bbd3a8a6439dc2f7aa1653ce1607"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbc2bbd3a8a6439dc2f7aa1653ce1607"></a>
SIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#abbc2bbd3a8a6439dc2f7aa1653ce1607">KOld</a></td></tr>
<tr class="memdesc:abbc2bbd3a8a6439dc2f7aa1653ce1607"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of allocated Old Solution <br /></td></tr>
<tr class="separator:abbc2bbd3a8a6439dc2f7aa1653ce1607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d407e6ef40467617262b2823bb45e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39d407e6ef40467617262b2823bb45e1"></a>
<a class="el" href="classMMCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FSolution</b></td></tr>
<tr class="separator:a39d407e6ef40467617262b2823bb45e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144587aafe1aba4f330d4731ab86905c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a144587aafe1aba4f330d4731ab86905c"></a>
<a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#a144587aafe1aba4f330d4731ab86905c">SolWFi</a></td></tr>
<tr class="memdesc:a144587aafe1aba4f330d4731ab86905c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Witch subproblem belongs last gi created. <br /></td></tr>
<tr class="separator:a144587aafe1aba4f330d4731ab86905c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7169a452aeb45218d73a411fcf45f70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7169a452aeb45218d73a411fcf45f70"></a>
<a class="el" href="classMMCFClass.html#ab31dfeace09a5b1b6c386f4ff089c8c6">Row</a>&#160;</td><td class="memItemRight" valign="bottom"><b>XSolution</b></td></tr>
<tr class="separator:ae7169a452aeb45218d73a411fcf45f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1003cd7792ad815400713aa41130b79c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1003cd7792ad815400713aa41130b79c"></a>
Bool_Vec&#160;</td><td class="memItemRight" valign="bottom"><b>SolvedP</b></td></tr>
<tr class="separator:a1003cd7792ad815400713aa41130b79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Variables management related</div></td></tr>
<tr class="memitem:a4bc12418f8db7ed8bb5021d7d4ac9e6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#a4bc12418f8db7ed8bb5021d7d4ac9e6f">SPar1</a></td></tr>
<tr class="memdesc:a4bc12418f8db7ed8bb5021d7d4ac9e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variables addition interval.  <a href="#a4bc12418f8db7ed8bb5021d7d4ac9e6f">More...</a><br /></td></tr>
<tr class="separator:a4bc12418f8db7ed8bb5021d7d4ac9e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef574316ef9598970f78516b0b3a02b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#aef574316ef9598970f78516b0b3a02b6">SPar2</a></td></tr>
<tr class="memdesc:aef574316ef9598970f78516b0b3a02b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum n.  <a href="#aef574316ef9598970f78516b0b3a02b6">More...</a><br /></td></tr>
<tr class="separator:aef574316ef9598970f78516b0b3a02b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b038a25ffccdd50bb0466e5dc9ffe1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#ae5b038a25ffccdd50bb0466e5dc9ffe1">SPar3</a></td></tr>
<tr class="memdesc:ae5b038a25ffccdd50bb0466e5dc9ffe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remotion of original constraints is checked every SPar3 iterations.  <a href="#ae5b038a25ffccdd50bb0466e5dc9ffe1">More...</a><br /></td></tr>
<tr class="separator:ae5b038a25ffccdd50bb0466e5dc9ffe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64390b3d9dee15229601ba2a8c32f32d"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#a64390b3d9dee15229601ba2a8c32f32d">SPar4</a></td></tr>
<tr class="memdesc:a64390b3d9dee15229601ba2a8c32f32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">For specifying which kind of constraints have to be relaxed.  <a href="#a64390b3d9dee15229601ba2a8c32f32d">More...</a><br /></td></tr>
<tr class="separator:a64390b3d9dee15229601ba2a8c32f32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5ccd861bb616aeed4cafa217aeed01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b5ccd861bb616aeed4cafa217aeed01"></a>
Bool_Vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#a9b5ccd861bb616aeed4cafa217aeed01">LsHasChgd</a></td></tr>
<tr class="memdesc:a9b5ccd861bb616aeed4cafa217aeed01"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if Lambda has changed since the last call to <a class="el" href="classFlwFiOrcl.html#a617eae97addf230369ca85912ab345ef" title="The first time NewGi() is called, it computes the &quot;true&quot; subgradients. ">NewGi()</a> <br /></td></tr>
<tr class="separator:a9b5ccd861bb616aeed4cafa217aeed01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01df8612a786daebcd9d1ebd4a89477d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01df8612a786daebcd9d1ebd4a89477d"></a>
OPTtimers *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#a01df8612a786daebcd9d1ebd4a89477d">Addt</a></td></tr>
<tr class="memdesc:a01df8612a786daebcd9d1ebd4a89477d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer for variables addition. <br /></td></tr>
<tr class="separator:a01df8612a786daebcd9d1ebd4a89477d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547bb4a223106ef3a86a1bf979b5b7da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a547bb4a223106ef3a86a1bf979b5b7da"></a>
OPTtimers *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlwFiOrcl.html#a547bb4a223106ef3a86a1bf979b5b7da">Remt</a></td></tr>
<tr class="memdesc:a547bb4a223106ef3a86a1bf979b5b7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer for variables deletion. <br /></td></tr>
<tr class="separator:a547bb4a223106ef3a86a1bf979b5b7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classFiOracle"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classFiOracle')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classFiOracle.html">FiOracle</a></td></tr>
<tr class="memitem:a70ef9a6fc1d031fea63743eef7d8ddf4 inherit pro_attribs_classFiOracle"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70ef9a6fc1d031fea63743eef7d8ddf4"></a>
<a class="el" href="classNDOSolver.html">NDOSolver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a70ef9a6fc1d031fea63743eef7d8ddf4">Slvr</a></td></tr>
<tr class="memdesc:a70ef9a6fc1d031fea63743eef7d8ddf4 inherit pro_attribs_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">(pointer to) the NDO solver that is currently using this oracle <br /></td></tr>
<tr class="separator:a70ef9a6fc1d031fea63743eef7d8ddf4 inherit pro_attribs_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8543193099c64b041d5ad1cc2ace45 inherit pro_attribs_classFiOracle"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa8543193099c64b041d5ad1cc2ace45"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#afa8543193099c64b041d5ad1cc2ace45">NumVar</a></td></tr>
<tr class="memdesc:afa8543193099c64b041d5ad1cc2ace45 inherit pro_attribs_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">(current) number of variables if <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> <br /></td></tr>
<tr class="separator:afa8543193099c64b041d5ad1cc2ace45 inherit pro_attribs_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221ac7d18f33270b4ef7f4586f5ebc50 inherit pro_attribs_classFiOracle"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a221ac7d18f33270b4ef7f4586f5ebc50"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a221ac7d18f33270b4ef7f4586f5ebc50">MaxName</a></td></tr>
<tr class="memdesc:a221ac7d18f33270b4ef7f4586f5ebc50 inherit pro_attribs_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum name to be used in <a class="el" href="classFiOracle.html#a2e53e0ca809a3be0075a6b8d53fd3b07" title="After that a new item has been produced, i.e., a call to NewGi() returned true, and that (possibly) G...">SetGiName()</a> <br /></td></tr>
<tr class="separator:a221ac7d18f33270b4ef7f4586f5ebc50 inherit pro_attribs_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55348f0c36b3cdc7f522f04116d6afc5 inherit pro_attribs_classFiOracle"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55348f0c36b3cdc7f522f04116d6afc5"></a>
cLMRow&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a55348f0c36b3cdc7f522f04116d6afc5">Lambda</a></td></tr>
<tr class="memdesc:a55348f0c36b3cdc7f522f04116d6afc5 inherit pro_attribs_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">(pointer to) the point where <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> has to be evaluated <br /></td></tr>
<tr class="separator:a55348f0c36b3cdc7f522f04116d6afc5 inherit pro_attribs_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f7311fea45f493699851bcee1c0628 inherit pro_attribs_classFiOracle"><td class="memItemLeft" align="right" valign="top">cIndex_Set&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a17f7311fea45f493699851bcee1c0628">LamBase</a></td></tr>
<tr class="memdesc:a17f7311fea45f493699851bcee1c0628 inherit pro_attribs_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">(pointer to) the set of indices of nonzeroes if Lambda[] is in "sparse" format.  <a href="#a17f7311fea45f493699851bcee1c0628">More...</a><br /></td></tr>
<tr class="separator:a17f7311fea45f493699851bcee1c0628 inherit pro_attribs_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfe4878ba2fa905d8cb1dd1d3acb81b inherit pro_attribs_classFiOracle"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cfe4878ba2fa905d8cb1dd1d3acb81b"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a7cfe4878ba2fa905d8cb1dd1d3acb81b">LamBDim</a></td></tr>
<tr class="memdesc:a7cfe4878ba2fa905d8cb1dd1d3acb81b inherit pro_attribs_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">length of LamBase[] <br /></td></tr>
<tr class="separator:a7cfe4878ba2fa905d8cb1dd1d3acb81b inherit pro_attribs_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb1cfdeeaec516bdc172e485e6a4753 inherit pro_attribs_classFiOracle"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bb1cfdeeaec516bdc172e485e6a4753"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a1bb1cfdeeaec516bdc172e485e6a4753">LHasChgd</a></td></tr>
<tr class="memdesc:a1bb1cfdeeaec516bdc172e485e6a4753 inherit pro_attribs_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if Lambda has changed since the last call to <a class="el" href="classFiOracle.html#aec7d643acc6b898fe0cd91b8dd042d0f" title="This method must be called to ask the FiOracle whether it can produce a &quot;new&quot; item corresponding to t...">NewGi()</a> <br /></td></tr>
<tr class="separator:a1bb1cfdeeaec516bdc172e485e6a4753 inherit pro_attribs_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d5dae033892e385945f7cbe99bdb99 inherit pro_attribs_classFiOracle"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49d5dae033892e385945f7cbe99bdb99"></a>
ostream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a49d5dae033892e385945f7cbe99bdb99">FiLog</a></td></tr>
<tr class="memdesc:a49d5dae033892e385945f7cbe99bdb99 inherit pro_attribs_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">the output stream object for log purposes <br /></td></tr>
<tr class="separator:a49d5dae033892e385945f7cbe99bdb99 inherit pro_attribs_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd13d86b57f9d3f02181d0439670117 inherit pro_attribs_classFiOracle"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fd13d86b57f9d3f02181d0439670117"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a1fd13d86b57f9d3f02181d0439670117">FiLLvl</a></td></tr>
<tr class="memdesc:a1fd13d86b57f9d3f02181d0439670117 inherit pro_attribs_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">the "level of verbosity" of the log <br /></td></tr>
<tr class="separator:a1fd13d86b57f9d3f02181d0439670117 inherit pro_attribs_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37f87b4def17d7b955b7d74a73e124a inherit pro_attribs_classFiOracle"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae37f87b4def17d7b955b7d74a73e124a"></a>
OPTtimers *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#ae37f87b4def17d7b955b7d74a73e124a">Fit</a></td></tr>
<tr class="memdesc:ae37f87b4def17d7b955b7d74a73e124a inherit pro_attribs_classFiOracle"><td class="mdescLeft">&#160;</td><td class="mdescRight">OPTtimer for timing purposes. <br /></td></tr>
<tr class="separator:ae37f87b4def17d7b955b7d74a73e124a inherit pro_attribs_classFiOracle"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class instantiates the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> interface [see <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>] to solve the flow Lagrangian relaxation of the (Fixed-Charge) Multicommodity Min Cost Flow Problem ((FC-)MMCF), possibly with "easy" components for the design variables. </p>
<p>It derives from MMCFFlwBase (and hence from <a class="el" href="classMMCFClass.html" title="This class defines a standard abstract interface for solvers of (generalized) Multicommodity Min-Cost...">MMCFClass</a>) and uses its methods to solve the flow relaxation.</p>
<p>The problem formulation is: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \phi( \alpha , \beta ) = \min \left\{ \sum_{k \in K} \sum_{(i, j) \in A} \left( c_{ij}^k + \alpha_{ij} + \beta_{ij}^k \right)x_{ij}^k + \left( f_{ij} - \alpha_{ij} u_{ij} - \sum_{k \in K} \beta_{ij}^k u_{ij}^k \right) y_{ij} \right\} \]" src="form_5.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_{(i, j) \in A} x_{ij}^k - \sum_{(j,i) \in A} x_{ij}^k = b_i^k \quad,\quad i \in N , k \in K \]" src="form_6.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ 0 \leq x_{ij}^k \leq u_{ij}^k \quad,\quad (i, j) \in A , k \in K \]" src="form_7.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ y_{ij} \in \{0, 1\} \quad,\quad (i, j) \in A \]" src="form_8.png"/>
</p>
<p> The pair <img class="formulaInl" alt="$( \alpha, \beta )$" src="form_9.png"/> is the Lambda vector described in the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> interface. The <img class="formulaInl" alt="$\alpha$" src="form_10.png"/>'s are dual variables associated to the relaxed mutual capacity constraints. These variables are always used. The <img class="formulaInl" alt="$\beta$" src="form_11.png"/>'s are dual variables associated to the relaxed individual capacity constraints. These variables only are used if SetICapRelax( true ) is called. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a910766732a42bed0195cb243a22e3e42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classFlwFiOrcl.html#a910766732a42bed0195cb243a22e3e42">FlwParam</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public enum for handling the FlwFiOrcl-specific parameters in [see below]. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1bedd126dd189882b0bb0855962bc7f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFlwFiOrcl.html">FlwFiOrcl</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">istream *&#160;</td>
          <td class="paramname"><em>iStrm</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor of the class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>an instance of the class <a class="el" href="classGraph.html" title="The class Graph is a service class for solvers of (generalized) Multicommodity Min-Cost Flow problems...">Graph</a> that defines the problem.</td></tr>
    <tr><td class="paramname">iStrm</td><td>parameters file used to read some parameters not predicted in the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> interface. In particular, the following parameters are read:</td></tr>
  </table>
  </dd>
</dl>
<ol type="1">
<li>SPar1 [0] how often the check for adding variables is performed (0 = never, all variables are there from the beginning)</li>
<li>SPar2 [0] a variable is removed if it has had value zero for SPar2 consecutive iterations, if 0 = no variables is removed</li>
<li>SPar3 [0] how often the check form removing variable is performed</li>
<li>SPar4 [w] relaxation type: 0 weak , b strong formulation and s the individual capacity constraints are the ones and only the ones involved</li>
<li>YiE [0] 0: easy components are to be used 1: otherwise</li>
<li>Aggrgtd [1] 0 if disaggregated master problem 1: aggregated master problem</li>
<li>KOld [0] pre-set number of old solutions that are kept in memory</li>
</ol>
<p>EpsFi [1e-6] precision for the design part</p><ol type="1">
<li>EpsCon [1e-6] precision for the constraints</li>
</ol>
<p>Note that the separation parameters SPar1-3 are irrelevant if the weak relaxation has been required. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad188c78f5811dd712f6078a34b4ee123"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetFiLog </td>
          <td>(</td>
          <td class="paramtype">ostream *&#160;</td>
          <td class="paramname"><em>outs</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>lvl</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>lvl controls the "level of verbosity" of the code. </p>
<p>The first four bits of lvl have the following meaning:</p>
<p>0 =&gt; no log at all (also assumed if log = 0);</p>
<p>&gt;0 =&gt; "basic" log: only the errors are reported; </p>

<p>Reimplemented from <a class="el" href="classFiOracle.html#aaabfddb18251ec0f18a70f6d8f265e28">FiOracle</a>.</p>

</div>
</div>
<a class="anchor" id="a6c4cac85adf4298bc87c3bb72b3b9325"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetAggregate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aggrgt</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set aggregation option. </p>
<p>Used to tell the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> if it should work with Fi aggregated (true) or disaggregated (false) option. </p>

</div>
</div>
<a class="anchor" id="a82af0e858f6fe842e35ac010558877a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetRelax </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>sp4</em> = <code>'w'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>YiE</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>sp1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>sp2</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>sp3</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set relaxation of Individual Capacities or off. </p>
<p>Used to tell to the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> if the relaxation of individual capacities constraints is considered. In the case of strong formulation, set the parameters PAV [0] and PRV [0] for adding and removing of the betas. [see <a class="el" href="classFlwFiOrcl.html" title="This class instantiates the FiOracle interface [see FiOracle.h] to solve the flow Lagrangian relaxati...">FlwFiOrcl</a>( Graph*, istream*=0 ) ]. </p>

</div>
</div>
<a class="anchor" id="a653281899d9d813e910d6da82a589a0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetInitialSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td>
          <td class="paramname"><em>Bse</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the initial dictionary. </p>
<p>Bse is the base of the current (beta) solution Thus, the dimension is not greater than</p>
<ul>
<li>MaxNumVar - NArcs, if there are mutual forcing capacity constraints</li>
<li>MaxNumVar, if there are only individual forcing capacity constraints </li>
</ul>

</div>
</div>
<a class="anchor" id="acb6cd24d6cbc7834ebfe496db251dc62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetEasy </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>YIsE</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Easy option. </p>
<p>Used to tell to the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> that there exist "easy" components of Fi(). By default YIsEasy has the value to false and all components are handled as "difficult". </p>

</div>
</div>
<a class="anchor" id="a617eae97addf230369ca85912ab345ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NewGi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>wFi</em> = <code>Inf&lt;&#160;<a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The first time <a class="el" href="classFlwFiOrcl.html#a617eae97addf230369ca85912ab345ef" title="The first time NewGi() is called, it computes the &quot;true&quot; subgradients. ">NewGi()</a> is called, it computes the "true" subgradients. </p>
<p>The second time it computes (epsilon-)subgradients associated with a primal solution that is obtained by running the heuristic with the commodities ordered by decreasing demand. Every subsequent call, it computes (epsilon-)subgradients associated with primal solutions that are obtained by running the heuristic with the commodities randomly ordered. Thus, it can always be called, but it can generate repeated epsilon subgradients.</p>
<p>The "true" subgradients are calculated using the following formulas:</p><ul>
<li>If the disaggregated version is used: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ gi^k(\alpha_{ij})=gi^k(\beta_{ij}^k)=x_{ij}^k ,\forall\: subproblem\: k \]" src="form_12.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ gi^0(\alpha_{i,j})=-u_{ij}y_{ij}\]" src="form_13.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ gi^0(\beta_{i,j}^k)=b_{ij}^ky_{ij}\]" src="form_14.png"/>
</p>
</li>
<li>If the aggregated version is used: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ gi(\alpha_{i,j})=\left(sum_{k \in K}x_{ij}^k-u_{ij}y_{ij}\right) \]" src="form_15.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ gi(\beta_{i,j}^k)=x_{ij}^k-b_{ij}^ky_{ij}\]" src="form_16.png"/>
</p>
 </li>
</ul>

</div>
</div>
<a class="anchor" id="a552d3a2f77f5aa587e7b84799b0c6134"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double AddTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the user + system time (in seconds) spent during the execution for adding of new beta variables. </p>

</div>
</div>
<a class="anchor" id="aaded2b439b4dcd881bedd255952dd32b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double RemTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As <a class="el" href="classFlwFiOrcl.html#a552d3a2f77f5aa587e7b84799b0c6134" title="Returns the user + system time (in seconds) spent during the execution for adding of new beta variabl...">AddTime()</a> [see above], it returns the time spent for removing the beta variables. </p>

</div>
</div>
<a class="anchor" id="a39ff442d7df1412f96dcfe97660f6451"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GetPar </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>wp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the current value of the "bool" parameters of the FlwFiOracle. </p>
<p>The enum FlwParam is used (in the obvious way) for selecting the parameter to be get. </p>

</div>
</div>
<a class="anchor" id="a1e6da8ac4271461aa61b766d63325feb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GetPar </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>wp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the current value of the "int" parameters of the FlwFiOracle [see above]. </p>
<p>The enum FlwParam is used (in the obvious way) for selecting the parameter to be get. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="af0f39a2857b038758ca7fb0204c6ccd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HpNum EpsFi</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Precision for the design problem. </p>
<p>The design solution value is considered (y=1) only if less than or equal to -Eps. This value is set to EFnal (read from parameter input file) by the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a>. </p>

</div>
</div>
<a class="anchor" id="a99977ca83ef6b4dcbd9b010c67649b33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Aggrgtd</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Agreggation flag. </p>
<p>Variable that defines if FlwFiOracle outputs aggregated or disaggregated information </p>

</div>
</div>
<a class="anchor" id="a4caf669ab1aa3040358727fd2de40e64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool YIsEasy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>true if the ys are easy components. </p>

</div>
</div>
<a class="anchor" id="af2c0bb5f92075a8cdc9060d1386ea438"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> InvULambda</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverse vocabulary of ULambda. </p>
<p>This vector contains the name of the variable beta corresponding to the position in Lambda of the index (+ NArcs) in the vector. It terminates with Inf&lt;Index&gt;() </p>

</div>
</div>
<a class="anchor" id="a43a3b9d070f1ddf5c202d8cedcd82b80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> ZLambdaCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counter of iterations with value zero for each variable. </p>

</div>
</div>
<a class="anchor" id="a2eafc63ded0de4be42a8c99695bb9908"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> MaxNumVar</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum number of variables. </p>
<p>By default the value of this variable is equal to NrArcs() + NrArcs() * NrComm(), it means the individual capacities constrainsts are relaxed. If SetICapRelax( false ) is called then the value of the variable is NrArcs(), it means only the mutual capacity constraints are relaxed. </p>

</div>
</div>
<a class="anchor" id="ae218aa1fbadae57b65692e278fdb0051"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a> OrigCosts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array of original unit costs. </p>
<p>Each entry corresponds to the cost of one unit of flow of one commodity traversing one arc. For arc j and commodity k, this cost is OrigCosts[ k * m + j ], where m stands for the total number of arcs. </p>

</div>
</div>
<a class="anchor" id="a002ad2186b3adc5fe18e35c3316bd706"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a> OrigXtrCosts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array of original design costs. </p>
<p>Each entry is associated with the fixed cost of the corresponding arc; if OrigXtrCosts == 0, then no extra costs are defined for the instance. </p>

</div>
</div>
<a class="anchor" id="ac1d3f0af75e06d91ecb74b987a3724c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a> OrigCapacities</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array of original individual capacities. </p>
<p>Each entry OrigCapacities[ k * m + j ] corresponds to the maximum flow of a given commodity, k, allowed in a given arc, j. </p>

</div>
</div>
<a class="anchor" id="a4bc12418f8db7ed8bb5021d7d4ac9e6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> SPar1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variables addition interval. </p>
<p>Original constraints are checked every SPar1 and a variable is added for each one currently violated (0 = no adding of variables is allowed). </p>

</div>
</div>
<a class="anchor" id="aef574316ef9598970f78516b0b3a02b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> SPar2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum n. </p>
<p>of iterations each variable can be 0. If one variable is ParRemVariables iterations with value zero it's removed. </p>

</div>
</div>
<a class="anchor" id="ae5b038a25ffccdd50bb0466e5dc9ffe1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> SPar3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remotion of original constraints is checked every SPar3 iterations. </p>

</div>
</div>
<a class="anchor" id="a64390b3d9dee15229601ba2a8c32f32d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char SPar4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For specifying which kind of constraints have to be relaxed. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classFlwFiOrcl.html">FlwFiOrcl</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
