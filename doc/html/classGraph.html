<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>CNDSM: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CNDSM
   &#160;<span id="projectnumber">1.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classGraph.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classGraph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Graph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The class <a class="el" href="classGraph.html" title="The class Graph is a service class for solvers of (generalized) Multicommodity Min-Cost Flow problems...">Graph</a> is a service class for solvers of (generalized) Multicommodity Min-Cost Flow problems, i.e., problems of the form.  
 <a href="classGraph.html#details">More...</a></p>

<p><code>#include &lt;Graph.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph_1_1Inf.html">Inf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Very small class to simplify extracting the "+ infinity" value for a basic type (FNumber, CNumber, Index); just use Inf&lt;type&gt;().  <a href="classGraph_1_1Inf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph_1_1MMCFGException.html">MMCFGException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small class for exceptions.  <a href="classGraph_1_1MMCFGException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Public types</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="el" href="classGraph.html" title="The class Graph is a service class for solvers of (generalized) Multicommodity Min-Cost Flow problems...">Graph</a> defines three main public types:</p>
<ul>
<li>Index, the type of arc and node indices;</li>
<li>FNumber, the type of arc capacities (individual and mutual) and node deficits;</li>
<li>CNumber, the type of flow costs.</li>
</ul>
<p>By re-defining the types in this section one can reduce the memory footprint of the object in case "small" data types (e.g., integer ones) can be used. However, <em>it is the user's responsibility to ensure that these types are set to reasonable values</em>. </p>
</div></td></tr>
<tr class="memitem:ad53d6229d7ec28555a9c9c2fd9abf773"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad53d6229d7ec28555a9c9c2fd9abf773"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a></td></tr>
<tr class="memdesc:ad53d6229d7ec28555a9c9c2fd9abf773"><td class="mdescLeft">&#160;</td><td class="mdescRight">index of a node or arc ( &gt;= 0 ) <br /></td></tr>
<tr class="separator:ad53d6229d7ec28555a9c9c2fd9abf773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3388eb329ff0551a0b86b6c67e33d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace3388eb329ff0551a0b86b6c67e33d8"></a>
typedef <a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a></td></tr>
<tr class="memdesc:ace3388eb329ff0551a0b86b6c67e33d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">set (array) of indices <br /></td></tr>
<tr class="separator:ace3388eb329ff0551a0b86b6c67e33d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6fa182c6468c6ef5677848b11b24b92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6fa182c6468c6ef5677848b11b24b92"></a>
typedef <a class="el" href="classGraph.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ae6fa182c6468c6ef5677848b11b24b92">Index_Mat</a></td></tr>
<tr class="memdesc:ae6fa182c6468c6ef5677848b11b24b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">set of set of indices <br /></td></tr>
<tr class="separator:ae6fa182c6468c6ef5677848b11b24b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76aaabb20535c51a2752b93f6c38fe54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76aaabb20535c51a2752b93f6c38fe54"></a>
typedef const <a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a></td></tr>
<tr class="memdesc:a76aaabb20535c51a2752b93f6c38fe54"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only index <br /></td></tr>
<tr class="separator:a76aaabb20535c51a2752b93f6c38fe54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81575b2d4e4d5636b17170432150ae69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81575b2d4e4d5636b17170432150ae69"></a>
typedef <a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a></td></tr>
<tr class="memdesc:a81575b2d4e4d5636b17170432150ae69"><td class="mdescLeft">&#160;</td><td class="mdescRight">read-only index array <br /></td></tr>
<tr class="separator:a81575b2d4e4d5636b17170432150ae69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea3e5951d222b2a8e57de1b4246a909"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeea3e5951d222b2a8e57de1b4246a909"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a></td></tr>
<tr class="memdesc:aeea3e5951d222b2a8e57de1b4246a909"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of arc flow <br /></td></tr>
<tr class="separator:aeea3e5951d222b2a8e57de1b4246a909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dae1f1a39c208ce3c2b337cd5bb3d00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dae1f1a39c208ce3c2b337cd5bb3d00"></a>
typedef <a class="el" href="classGraph.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a></td></tr>
<tr class="memdesc:a9dae1f1a39c208ce3c2b337cd5bb3d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of flows <br /></td></tr>
<tr class="separator:a9dae1f1a39c208ce3c2b337cd5bb3d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6147b8769d68944cacb75c83dfeb7794"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6147b8769d68944cacb75c83dfeb7794"></a>
typedef <a class="el" href="classGraph.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a6147b8769d68944cacb75c83dfeb7794">FMat</a></td></tr>
<tr class="memdesc:a6147b8769d68944cacb75c83dfeb7794"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix of flows <br /></td></tr>
<tr class="separator:a6147b8769d68944cacb75c83dfeb7794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f747fbdff346237c8db4469d569994"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11f747fbdff346237c8db4469d569994"></a>
typedef const <a class="el" href="classGraph.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a11f747fbdff346237c8db4469d569994">cFNumber</a></td></tr>
<tr class="memdesc:a11f747fbdff346237c8db4469d569994"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only flow <br /></td></tr>
<tr class="separator:a11f747fbdff346237c8db4469d569994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad325f3193dbba0ddef1da4e72d29eda6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad325f3193dbba0ddef1da4e72d29eda6"></a>
typedef <a class="el" href="classGraph.html#a11f747fbdff346237c8db4469d569994">cFNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a></td></tr>
<tr class="memdesc:ad325f3193dbba0ddef1da4e72d29eda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">read-only flow array <br /></td></tr>
<tr class="separator:ad325f3193dbba0ddef1da4e72d29eda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d0627ba8213afe1ec4ebeb4508e8f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24d0627ba8213afe1ec4ebeb4508e8f1"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a></td></tr>
<tr class="memdesc:a24d0627ba8213afe1ec4ebeb4508e8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of arc flow cost <br /></td></tr>
<tr class="separator:a24d0627ba8213afe1ec4ebeb4508e8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62409402be4e4b301e1a568f99f877be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62409402be4e4b301e1a568f99f877be"></a>
typedef <a class="el" href="classGraph.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a62409402be4e4b301e1a568f99f877be">CRow</a></td></tr>
<tr class="memdesc:a62409402be4e4b301e1a568f99f877be"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of costs <br /></td></tr>
<tr class="separator:a62409402be4e4b301e1a568f99f877be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f7a8d9519b2c031be661be60fd81e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66f7a8d9519b2c031be661be60fd81e3"></a>
typedef <a class="el" href="classGraph.html#a62409402be4e4b301e1a568f99f877be">CRow</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a66f7a8d9519b2c031be661be60fd81e3">CMat</a></td></tr>
<tr class="memdesc:a66f7a8d9519b2c031be661be60fd81e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix of costs <br /></td></tr>
<tr class="separator:a66f7a8d9519b2c031be661be60fd81e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07dbefeeb08c3f63073622411893eb76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07dbefeeb08c3f63073622411893eb76"></a>
typedef const <a class="el" href="classGraph.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a07dbefeeb08c3f63073622411893eb76">cCNumber</a></td></tr>
<tr class="memdesc:a07dbefeeb08c3f63073622411893eb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only cost <br /></td></tr>
<tr class="separator:a07dbefeeb08c3f63073622411893eb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab700102e9ba8bb6015be6818d4e99097"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab700102e9ba8bb6015be6818d4e99097"></a>
typedef <a class="el" href="classGraph.html#a07dbefeeb08c3f63073622411893eb76">cCNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a></td></tr>
<tr class="memdesc:ab700102e9ba8bb6015be6818d4e99097"><td class="mdescLeft">&#160;</td><td class="mdescRight">read-only cost array <br /></td></tr>
<tr class="separator:ab700102e9ba8bb6015be6818d4e99097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ee7b3099b0bc780a6a4b43629488fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5ee7b3099b0bc780a6a4b43629488fa"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a></td></tr>
<tr class="memdesc:af5ee7b3099b0bc780a6a4b43629488fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of the objective function: has to hold sums of products of FNumber(s) by CNumber(s) <br /></td></tr>
<tr class="separator:af5ee7b3099b0bc780a6a4b43629488fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43a4b443a5a34a30e1398994912945d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad43a4b443a5a34a30e1398994912945d"></a>
typedef bool *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ad43a4b443a5a34a30e1398994912945d">Bool_Vec</a></td></tr>
<tr class="memdesc:ad43a4b443a5a34a30e1398994912945d"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of booleans <br /></td></tr>
<tr class="separator:ad43a4b443a5a34a30e1398994912945d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a46e43efb25c4d56aac74e6d95973e912"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a46e43efb25c4d56aac74e6d95973e912">Graph</a> (const char *const FN, char FT= 's')</td></tr>
<tr class="memdesc:a46e43efb25c4d56aac74e6d95973e912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the Class: builds an instance of MMCF reading the data from the input file `FN'; `FT' must be:  <a href="#a46e43efb25c4d56aac74e6d95973e912">More...</a><br /></td></tr>
<tr class="separator:a46e43efb25c4d56aac74e6d95973e912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157396871a8c2a05ee2d5d596405b643"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a157396871a8c2a05ee2d5d596405b643">Graph</a> (<a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> n, <a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> m, <a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> comm, const <a class="el" href="classGraph.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> *Def, <a class="el" href="classGraph.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> S, <a class="el" href="classGraph.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> E, <a class="el" href="classGraph.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> CapTot, const <a class="el" href="classGraph.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> *Cap, const <a class="el" href="classGraph.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a> *Cost)</td></tr>
<tr class="memdesc:a157396871a8c2a05ee2d5d596405b643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the class: builds an instance of MMCF reading the data from the provided parameters.  <a href="#a157396871a8c2a05ee2d5d596405b643">More...</a><br /></td></tr>
<tr class="separator:a157396871a8c2a05ee2d5d596405b643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ef15067c8e3a67fc91caeeadaa4290"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ae5ef15067c8e3a67fc91caeeadaa4290">NrComm</a> (void)</td></tr>
<tr class="memdesc:ae5ef15067c8e3a67fc91caeeadaa4290"><td class="mdescLeft">&#160;</td><td class="mdescRight">"base" constructor of the class, that in fact does nothing: is tought as a mean for derived class to provide their own initialization of the data structures, in case they are incompatible with the ones given in the "standard" constructor.  <a href="#ae5ef15067c8e3a67fc91caeeadaa4290">More...</a><br /></td></tr>
<tr class="separator:ae5ef15067c8e3a67fc91caeeadaa4290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1ee5e303f8a33c68785c38376d0f05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#acb1ee5e303f8a33c68785c38376d0f05">NrArcs</a> (void)</td></tr>
<tr class="memdesc:acb1ee5e303f8a33c68785c38376d0f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of arcs of the network.  <a href="#acb1ee5e303f8a33c68785c38376d0f05">More...</a><br /></td></tr>
<tr class="separator:acb1ee5e303f8a33c68785c38376d0f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8be50014ba948824300612c04d2815"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a1b8be50014ba948824300612c04d2815">NrNodes</a> (void)</td></tr>
<tr class="memdesc:a1b8be50014ba948824300612c04d2815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nodes of the network.  <a href="#a1b8be50014ba948824300612c04d2815">More...</a><br /></td></tr>
<tr class="separator:a1b8be50014ba948824300612c04d2815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bed463a9b2a5a719c3dde9739d6de95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a9bed463a9b2a5a719c3dde9739d6de95">NrExtraVars</a> (void)</td></tr>
<tr class="memdesc:a9bed463a9b2a5a719c3dde9739d6de95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of extra (non-flow) variables in the problem.  <a href="#a9bed463a9b2a5a719c3dde9739d6de95">More...</a><br /></td></tr>
<tr class="separator:a9bed463a9b2a5a719c3dde9739d6de95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5128751af2a541d28e6c09b2af3ff0e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a5128751af2a541d28e6c09b2af3ff0e1">NrExtraNonZ</a> (<a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> FrstC=0, <a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> LstC=<a class="el" href="classGraph_1_1Inf.html">Inf</a>&lt; <a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())</td></tr>
<tr class="memdesc:a5128751af2a541d28e6c09b2af3ff0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">NrExtraConst() returns the total number of "extra" constraints.  <a href="#a5128751af2a541d28e6c09b2af3ff0e1">More...</a><br /></td></tr>
<tr class="separator:a5128751af2a541d28e6c09b2af3ff0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8387ea24fc67b029029d543c78454fed"><td class="memItemLeft" align="right" valign="top">MCFType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a8387ea24fc67b029029d543c78454fed">ProblemType</a> (<a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> k)</td></tr>
<tr class="memdesc:a8387ea24fc67b029029d543c78454fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of the k-th subproblem: it can be a generic Min Cost Flow problem or a Shortest Path Tree problem.  <a href="#a8387ea24fc67b029029d543c78454fed">More...</a><br /></td></tr>
<tr class="separator:a8387ea24fc67b029029d543c78454fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1009b5a010f3ba94a5748df83831ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a0b1009b5a010f3ba94a5748df83831ea">Directed</a> (void)</td></tr>
<tr class="memdesc:a0b1009b5a010f3ba94a5748df83831ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the graph is directed, false otherwise.  <a href="#a0b1009b5a010f3ba94a5748df83831ea">More...</a><br /></td></tr>
<tr class="separator:a0b1009b5a010f3ba94a5748df83831ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0fbd038d74dc734ff0290ea45c1bfb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#abe0fbd038d74dc734ff0290ea45c1bfb">NamesStartFrom1</a> (void)</td></tr>
<tr class="memdesc:abe0fbd038d74dc734ff0290ea45c1bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if node "names" (in the arc description) go from 1 to n, false if they go from 0 to n - 1.  <a href="#abe0fbd038d74dc734ff0290ea45c1bfb">More...</a><br /></td></tr>
<tr class="separator:abe0fbd038d74dc734ff0290ea45c1bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26c758f072f253671052fe9664d3595"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGraph.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ad26c758f072f253671052fe9664d3595">TotalCapacityJ</a> (<a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> j)</td></tr>
<tr class="memdesc:ad26c758f072f253671052fe9664d3595"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first form returns a read-only pointer to a m-vector containing the mutual capacities of the arcs; the second form returns the mutual capacity of arc j.  <a href="#ad26c758f072f253671052fe9664d3595">More...</a><br /></td></tr>
<tr class="separator:ad26c758f072f253671052fe9664d3595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd44bbe7e170b21d53b41eaabf9e60b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#acdd44bbe7e170b21d53b41eaabf9e60b">NActives</a> (void)</td></tr>
<tr class="memdesc:acdd44bbe7e170b21d53b41eaabf9e60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actives() returns a read-only pointer to a m-vector (ordered in increasing sense and Inf&lt;Index&gt;()-terminated) of the indices of arcs that have an associated mutual capacity constraint: it returns 0 if every arc has a constraint.  <a href="#acdd44bbe7e170b21d53b41eaabf9e60b">More...</a><br /></td></tr>
<tr class="separator:acdd44bbe7e170b21d53b41eaabf9e60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82926e7eeda572956e4df41ee4c2da5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGraph.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ad82926e7eeda572956e4df41ee4c2da5">CostKJ</a> (<a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> k, <a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> j)</td></tr>
<tr class="memdesc:ad82926e7eeda572956e4df41ee4c2da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first form returns a read-only pointer to a m-vector containing the costs of the arcs relative to commodity k; the second form returns the cost of arc j relative to commodity k.  <a href="#ad82926e7eeda572956e4df41ee4c2da5">More...</a><br /></td></tr>
<tr class="separator:ad82926e7eeda572956e4df41ee4c2da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4457086e8c668c0ac84104d52f2ad76c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGraph.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a4457086e8c668c0ac84104d52f2ad76c">CapacityKJ</a> (<a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> k, <a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> j)</td></tr>
<tr class="memdesc:a4457086e8c668c0ac84104d52f2ad76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first form returns a read-only pointer to a m-vector containing the single-commodity capacities relative to commodity k; the second form returns the single-commodity capacity of arc j for commodity k.  <a href="#a4457086e8c668c0ac84104d52f2ad76c">More...</a><br /></td></tr>
<tr class="separator:a4457086e8c668c0ac84104d52f2ad76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefa8a92f5b18bcc6db76698823efb4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#abefa8a92f5b18bcc6db76698823efb4c">NActivesK</a> (<a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> k)</td></tr>
<tr class="memdesc:abefa8a92f5b18bcc6db76698823efb4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ActivesK( k ) returns a read-only pointer to the vector (ordered in.  <a href="#abefa8a92f5b18bcc6db76698823efb4c">More...</a><br /></td></tr>
<tr class="separator:abefa8a92f5b18bcc6db76698823efb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f6948c66a0a4a72d881e3f9f6701aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGraph.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ac7f6948c66a0a4a72d881e3f9f6701aa">DeficitKJ</a> (<a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> k, <a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> j)</td></tr>
<tr class="memdesc:ac7f6948c66a0a4a72d881e3f9f6701aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first form returns a read-only pointer to a n-vector containing the node deficits relative to commodity k; the second form returns the deficit of node j relative to commodity k.  <a href="#ac7f6948c66a0a4a72d881e3f9f6701aa">More...</a><br /></td></tr>
<tr class="separator:ac7f6948c66a0a4a72d881e3f9f6701aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e44c6205c9171e1e072b51cef1bc66e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a3e44c6205c9171e1e072b51cef1bc66e">StartNJ</a> (<a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> j)</td></tr>
<tr class="memdesc:a3e44c6205c9171e1e072b51cef1bc66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first form returns a read-only pointer to a m-vector containing the starting nodes of the arcs; the second form returns the starting node of arc j.  <a href="#a3e44c6205c9171e1e072b51cef1bc66e">More...</a><br /></td></tr>
<tr class="separator:a3e44c6205c9171e1e072b51cef1bc66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa701f9eb35c2ed0afe4b7c9a573ac155"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa701f9eb35c2ed0afe4b7c9a573ac155"></a>
<a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aa701f9eb35c2ed0afe4b7c9a573ac155">EndNJ</a> (<a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> j)</td></tr>
<tr class="memdesc:aa701f9eb35c2ed0afe4b7c9a573ac155"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first form returns a read-only pointer to a m-vector containing the ending nodes of the arcs; the second form returns the ending node of arc j. <br /></td></tr>
<tr class="separator:aa701f9eb35c2ed0afe4b7c9a573ac155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea35ab8b1343e74da770e41de843ec5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGraph.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a2ea35ab8b1343e74da770e41de843ec5">WIntVar</a> (<a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> k)</td></tr>
<tr class="memdesc:a2ea35ab8b1343e74da770e41de843ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some of the variables of the MMCF-like problem may be constrained to be integer-valued.  <a href="#a2ea35ab8b1343e74da770e41de843ec5">More...</a><br /></td></tr>
<tr class="separator:a2ea35ab8b1343e74da770e41de843ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdfee03a128035deb78eda466222ae1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a1fdfee03a128035deb78eda466222ae1">ExtraConstr</a> (int *IBeg, int *Indx, double *Vals, <a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> FrstC=0, <a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> LstC=<a class="el" href="classGraph_1_1Inf.html">Inf</a>&lt; <a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())</td></tr>
<tr class="memdesc:a1fdfee03a128035deb78eda466222ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes in IBeg, Indx and Vals the description of those "extra" linear constraints of the problem whose "names" (indices) are comprised between FrstC and LstC (see <a class="el" href="classGraph.html#a5128751af2a541d28e6c09b2af3ff0e1" title="NrExtraConst() returns the total number of &quot;extra&quot; constraints. ">NrExtraNonZ()</a> above).  <a href="#a1fdfee03a128035deb78eda466222ae1">More...</a><br /></td></tr>
<tr class="separator:a1fdfee03a128035deb78eda466222ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551805a33376f114f37d5a700797553e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a551805a33376f114f37d5a700797553e">ProblemType</a> (const MCFType NewType, <a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> k)</td></tr>
<tr class="memdesc:a551805a33376f114f37d5a700797553e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the type of the k-th subproblem.  <a href="#a551805a33376f114f37d5a700797553e">More...</a><br /></td></tr>
<tr class="separator:a551805a33376f114f37d5a700797553e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5718ccb9ce4c885c85f73b8a3825816a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a5718ccb9ce4c885c85f73b8a3825816a">Directed</a> (bool DG)</td></tr>
<tr class="memdesc:a5718ccb9ce4c885c85f73b8a3825816a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decides if the graph G of the problem has to be considered as a directed (DG == true) or an undirected (DG == false) graph, setting the value that is returned by <a class="el" href="classGraph.html#a0b1009b5a010f3ba94a5748df83831ea" title="Returns true if the graph is directed, false otherwise. ">Directed( void )</a> [see above].  <a href="#a5718ccb9ce4c885c85f73b8a3825816a">More...</a><br /></td></tr>
<tr class="separator:a5718ccb9ce4c885c85f73b8a3825816a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d53ec2c780478a9ef2c308ff85b5c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a88d53ec2c780478a9ef2c308ff85b5c4">NamesStartFrom1</a> (bool NSF1)</td></tr>
<tr class="memdesc:a88d53ec2c780478a9ef2c308ff85b5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decides if node "names" (in the arc description) go from 1 to n or from 0 to n - 1, setting the value that is returned by <a class="el" href="classGraph.html#abe0fbd038d74dc734ff0290ea45c1bfb" title="Returns true if node &quot;names&quot; (in the arc description) go from 1 to n, false if they go from 0 to n - ...">NamesStartFrom1( void )</a> [see above].  <a href="#a88d53ec2c780478a9ef2c308ff85b5c4">More...</a><br /></td></tr>
<tr class="separator:a88d53ec2c780478a9ef2c308ff85b5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa084dfb28f2d6bd924159276866ea5b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aaa084dfb28f2d6bd924159276866ea5b">UpDtTotCapJ</a> (<a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> j, <a class="el" href="classGraph.html#a11f747fbdff346237c8db4469d569994">cFNumber</a> NewUj=<a class="el" href="classGraph_1_1Inf.html">Inf</a>&lt; <a class="el" href="classGraph.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a> &gt;())</td></tr>
<tr class="memdesc:aaa084dfb28f2d6bd924159276866ea5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the total upper capacities, either all of them or just the j-th, i.e.  <a href="#aaa084dfb28f2d6bd924159276866ea5b">More...</a><br /></td></tr>
<tr class="separator:aaa084dfb28f2d6bd924159276866ea5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ae01873c31fa8d2c289189efbe519e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ae8ae01873c31fa8d2c289189efbe519e">UpdateArcCstKJ</a> (<a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> k, <a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> j, <a class="el" href="classGraph.html#a07dbefeeb08c3f63073622411893eb76">cCNumber</a> NewCkj=0)</td></tr>
<tr class="memdesc:ae8ae01873c31fa8d2c289189efbe519e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the arc costs, either all of the commodity k or just the one relative to j-th arc for commodity k.  <a href="#ae8ae01873c31fa8d2c289189efbe519e">More...</a><br /></td></tr>
<tr class="separator:ae8ae01873c31fa8d2c289189efbe519e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42276a521fe9ca47f316dfa686dac317"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a42276a521fe9ca47f316dfa686dac317">UpDtArcCapKJ</a> (<a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> k, <a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> j, <a class="el" href="classGraph.html#a11f747fbdff346237c8db4469d569994">cFNumber</a> NewUkj=0)</td></tr>
<tr class="memdesc:a42276a521fe9ca47f316dfa686dac317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the single-commodity capacities, either all of the commodity k or just the one relative to the j-th arc for commodity k.  <a href="#a42276a521fe9ca47f316dfa686dac317">More...</a><br /></td></tr>
<tr class="separator:a42276a521fe9ca47f316dfa686dac317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bf108e1fe3dc0b4f2071a209b34979"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a08bf108e1fe3dc0b4f2071a209b34979">UpDtNdeDfctKJ</a> (<a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> k, <a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> j, <a class="el" href="classGraph.html#a11f747fbdff346237c8db4469d569994">cFNumber</a> NewDkj=0)</td></tr>
<tr class="memdesc:a08bf108e1fe3dc0b4f2071a209b34979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the node deficits, either all of the commodity k or just the one relative to the j-th arc for commodity k.  <a href="#a08bf108e1fe3dc0b4f2071a209b34979">More...</a><br /></td></tr>
<tr class="separator:a08bf108e1fe3dc0b4f2071a209b34979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b59b567311c0b34246061e886c8b95f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a9b59b567311c0b34246061e886c8b95f">SetIntVar</a> (<a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> k, bool IntVld=true, <a class="el" href="classGraph.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> strt=0, <a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=<a class="el" href="classGraph_1_1Inf.html">Inf</a>&lt; <a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())</td></tr>
<tr class="memdesc:a9b59b567311c0b34246061e886c8b95f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the <a class="el" href="classGraph.html" title="The class Graph is a service class for solvers of (generalized) Multicommodity Min-Cost Flow problems...">Graph</a> object the information about which among the (flow and non-flow) variables of the problem are integer-valued.  <a href="#a9b59b567311c0b34246061e886c8b95f">More...</a><br /></td></tr>
<tr class="separator:a9b59b567311c0b34246061e886c8b95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f23c410a3a50056aa1e8c014e185e8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ac9f23c410a3a50056aa1e8c014e185e8">SetExtraVars</a> (<a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> NXV)</td></tr>
<tr class="memdesc:ac9f23c410a3a50056aa1e8c014e185e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the <a class="el" href="classGraph.html" title="The class Graph is a service class for solvers of (generalized) Multicommodity Min-Cost Flow problems...">Graph</a> object that there are NXV "extra" (non-flow) variables in the problem.  <a href="#ac9f23c410a3a50056aa1e8c014e185e8">More...</a><br /></td></tr>
<tr class="separator:ac9f23c410a3a50056aa1e8c014e185e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c641c4c950069bd97c8d4ec63fd010"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a86c641c4c950069bd97c8d4ec63fd010">SetExtraConstr</a> (<a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> NXC, int *IBeg, int *Indx, double *Vals)</td></tr>
<tr class="memdesc:a86c641c4c950069bd97c8d4ec63fd010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives to the <a class="el" href="classGraph.html" title="The class Graph is a service class for solvers of (generalized) Multicommodity Min-Cost Flow problems...">Graph</a> object a description of the "extra" constraints in the problem: NXC is the number of such constraints, and IStp, Indx and Vals must contain the description.  <a href="#a86c641c4c950069bd97c8d4ec63fd010">More...</a><br /></td></tr>
<tr class="separator:a86c641c4c950069bd97c8d4ec63fd010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe434663e22c263e46b301196d0fb21"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#acfe434663e22c263e46b301196d0fb21">PreProcess</a> (<a class="el" href="classGraph.html#a11f747fbdff346237c8db4469d569994">cFNumber</a> IncUk=0, <a class="el" href="classGraph.html#a11f747fbdff346237c8db4469d569994">cFNumber</a> DecUk=0, <a class="el" href="classGraph.html#a11f747fbdff346237c8db4469d569994">cFNumber</a> IncUjk=0, <a class="el" href="classGraph.html#a11f747fbdff346237c8db4469d569994">cFNumber</a> DecUjk=0, <a class="el" href="classGraph.html#a11f747fbdff346237c8db4469d569994">cFNumber</a> ChgDfct=0, <a class="el" href="classGraph.html#a07dbefeeb08c3f63073622411893eb76">cCNumber</a> DecCsts=0)</td></tr>
<tr class="memdesc:acfe434663e22c263e46b301196d0fb21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs various pre-processing of the data, trying to make the instance more easily solvable.  <a href="#acfe434663e22c263e46b301196d0fb21">More...</a><br /></td></tr>
<tr class="separator:acfe434663e22c263e46b301196d0fb21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930e2af5720510e2ee8f03fd6d831441"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a930e2af5720510e2ee8f03fd6d831441">MakeSingleSourced</a> (bool ToAll=false)</td></tr>
<tr class="memdesc:a930e2af5720510e2ee8f03fd6d831441"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method scans the graph and makes all the commodities single-sourced by adding, if necessary, one node to the graph and connecting it to all sources with arcs having individual capacities equal to the capacity of.  <a href="#a930e2af5720510e2ee8f03fd6d831441">More...</a><br /></td></tr>
<tr class="separator:a930e2af5720510e2ee8f03fd6d831441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a544a1ade639057e8c14b957026a25"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aa9a544a1ade639057e8c14b957026a25">OutMPSFile</a> (const char *const FN, bool FxdClmns=false, const char *const PN=0)</td></tr>
<tr class="memdesc:aa9a544a1ade639057e8c14b957026a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the current MMCF problem as a Linear Programming problem in the standard MPS format: if FxdClmns == true, then the fixed-column MPS format is used, else (the default) the "modern" MPS format is used, where fields have not a fixed column positions but are just blank-delimited.  <a href="#aa9a544a1ade639057e8c14b957026a25">More...</a><br /></td></tr>
<tr class="separator:aa9a544a1ade639057e8c14b957026a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e048ecce375386cb69fff17eebca2a1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classGraph.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a2e048ecce375386cb69fff17eebca2a1">UpperBound</a> (void)</td></tr>
<tr class="memdesc:a2e048ecce375386cb69fff17eebca2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a (very coarse) Upper Bound to the value of the optimal solution of the MMCF currently represented in the <a class="el" href="classGraph.html" title="The class Graph is a service class for solvers of (generalized) Multicommodity Min-Cost Flow problems...">Graph</a> object.  <a href="#a2e048ecce375386cb69fff17eebca2a1">More...</a><br /></td></tr>
<tr class="separator:a2e048ecce375386cb69fff17eebca2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae4f21f1c357df2e1c73d270454629aec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ae4f21f1c357df2e1c73d270454629aec">CmnIntlz</a> (void)</td></tr>
<tr class="memdesc:ae4f21f1c357df2e1c73d270454629aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ae4f21f1c357df2e1c73d270454629aec">More...</a><br /></td></tr>
<tr class="separator:ae4f21f1c357df2e1c73d270454629aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae17c0b316f9e362ddc529b893cbcae45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae17c0b316f9e362ddc529b893cbcae45"></a>
<a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ae17c0b316f9e362ddc529b893cbcae45">NNodes</a></td></tr>
<tr class="memdesc:ae17c0b316f9e362ddc529b893cbcae45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes. <br /></td></tr>
<tr class="separator:ae17c0b316f9e362ddc529b893cbcae45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e4c4bb951b34aca6292f6bbebac38f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8e4c4bb951b34aca6292f6bbebac38f"></a>
<a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aa8e4c4bb951b34aca6292f6bbebac38f">NArcs</a></td></tr>
<tr class="memdesc:aa8e4c4bb951b34aca6292f6bbebac38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of arcs. <br /></td></tr>
<tr class="separator:aa8e4c4bb951b34aca6292f6bbebac38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba4b0ec3dedeba97383759741c1cf56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adba4b0ec3dedeba97383759741c1cf56"></a>
<a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#adba4b0ec3dedeba97383759741c1cf56">NComm</a></td></tr>
<tr class="memdesc:adba4b0ec3dedeba97383759741c1cf56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of commodities. <br /></td></tr>
<tr class="separator:adba4b0ec3dedeba97383759741c1cf56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55766819873ef7c2c3952c7fa36e03c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa55766819873ef7c2c3952c7fa36e03c"></a>
<a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aa55766819873ef7c2c3952c7fa36e03c">NCnst</a></td></tr>
<tr class="memdesc:aa55766819873ef7c2c3952c7fa36e03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of arcs with mutual capacity constraints. <br /></td></tr>
<tr class="separator:aa55766819873ef7c2c3952c7fa36e03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ac118373c3f09892e96de225964663"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22ac118373c3f09892e96de225964663"></a>
<a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a22ac118373c3f09892e96de225964663">NXtrV</a></td></tr>
<tr class="memdesc:a22ac118373c3f09892e96de225964663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of "extra" variables. <br /></td></tr>
<tr class="separator:a22ac118373c3f09892e96de225964663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3f5d6671ee13850d2f786708bcfeea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c3f5d6671ee13850d2f786708bcfeea"></a>
<a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a0c3f5d6671ee13850d2f786708bcfeea">NXtrC</a></td></tr>
<tr class="memdesc:a0c3f5d6671ee13850d2f786708bcfeea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of "extra" constraints. <br /></td></tr>
<tr class="separator:a0c3f5d6671ee13850d2f786708bcfeea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3575bac34f3bd41ab80e0fc41f6a89"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca3575bac34f3bd41ab80e0fc41f6a89"></a>
<a class="el" href="classGraph.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aca3575bac34f3bd41ab80e0fc41f6a89">Startn</a></td></tr>
<tr class="memdesc:aca3575bac34f3bd41ab80e0fc41f6a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topology of the graph: starting nodes. <br /></td></tr>
<tr class="separator:aca3575bac34f3bd41ab80e0fc41f6a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3e486fb3f3234987201cacccba7758"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc3e486fb3f3234987201cacccba7758"></a>
<a class="el" href="classGraph.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#abc3e486fb3f3234987201cacccba7758">Endn</a></td></tr>
<tr class="memdesc:abc3e486fb3f3234987201cacccba7758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topology of the graph: ending nodes. <br /></td></tr>
<tr class="separator:abc3e486fb3f3234987201cacccba7758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58fcdfac880899575cfdc6936fda5a10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58fcdfac880899575cfdc6936fda5a10"></a>
<a class="el" href="classGraph.html#a66f7a8d9519b2c031be661be60fd81e3">CMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a58fcdfac880899575cfdc6936fda5a10">C</a></td></tr>
<tr class="memdesc:a58fcdfac880899575cfdc6936fda5a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix of the arc costs. <br /></td></tr>
<tr class="separator:a58fcdfac880899575cfdc6936fda5a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c21ba337c102fda04f12b3565cecfd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07c21ba337c102fda04f12b3565cecfd"></a>
<a class="el" href="classGraph.html#a6147b8769d68944cacb75c83dfeb7794">FMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a07c21ba337c102fda04f12b3565cecfd">U</a></td></tr>
<tr class="memdesc:a07c21ba337c102fda04f12b3565cecfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix of the arc upper capacities. <br /></td></tr>
<tr class="separator:a07c21ba337c102fda04f12b3565cecfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cf01c374f12530e1c0c82cc434accb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0cf01c374f12530e1c0c82cc434accb"></a>
<a class="el" href="classGraph.html#a6147b8769d68944cacb75c83dfeb7794">FMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ac0cf01c374f12530e1c0c82cc434accb">B</a></td></tr>
<tr class="memdesc:ac0cf01c374f12530e1c0c82cc434accb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix of the node deficits. <br /></td></tr>
<tr class="separator:ac0cf01c374f12530e1c0c82cc434accb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec93f67e98d0f857a07204ca44456350"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec93f67e98d0f857a07204ca44456350"></a>
MCFType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aec93f67e98d0f857a07204ca44456350">PT</a></td></tr>
<tr class="memdesc:aec93f67e98d0f857a07204ca44456350"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of flow subproblem <br /></td></tr>
<tr class="separator:aec93f67e98d0f857a07204ca44456350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4677adf1c90abaaec88413885636a9f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4677adf1c90abaaec88413885636a9f0"></a>
<a class="el" href="classGraph.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a4677adf1c90abaaec88413885636a9f0">UTot</a></td></tr>
<tr class="memdesc:a4677adf1c90abaaec88413885636a9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of mutual capacities. <br /></td></tr>
<tr class="separator:a4677adf1c90abaaec88413885636a9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3e542240c3080701978acbaf895baf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b3e542240c3080701978acbaf895baf"></a>
<a class="el" href="classGraph.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a1b3e542240c3080701978acbaf895baf">Active</a></td></tr>
<tr class="memdesc:a1b3e542240c3080701978acbaf895baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of the arcs for which a mutual capacity constraint is defined. <br /></td></tr>
<tr class="separator:a1b3e542240c3080701978acbaf895baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d50d9bb6fb74f6309a785e21267365"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5d50d9bb6fb74f6309a785e21267365"></a>
<a class="el" href="classGraph.html#ae6fa182c6468c6ef5677848b11b24b92">Index_Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ac5d50d9bb6fb74f6309a785e21267365">ActiveK</a></td></tr>
<tr class="memdesc:ac5d50d9bb6fb74f6309a785e21267365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like Active for individual capacities. <br /></td></tr>
<tr class="separator:ac5d50d9bb6fb74f6309a785e21267365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14536658f10f3af67fb6a816b0d95865"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14536658f10f3af67fb6a816b0d95865"></a>
<a class="el" href="classGraph.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a14536658f10f3af67fb6a816b0d95865">NamesK</a></td></tr>
<tr class="memdesc:a14536658f10f3af67fb6a816b0d95865"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dual multipliers relative to commodity K start with NamesK[ k ] and end with NamesK[ k + 1 ]. <br /></td></tr>
<tr class="separator:a14536658f10f3af67fb6a816b0d95865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af166327b1cd093f87dc4f695cdbc8e20"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af166327b1cd093f87dc4f695cdbc8e20"></a>
<a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#af166327b1cd093f87dc4f695cdbc8e20">StrtNme</a></td></tr>
<tr class="memdesc:af166327b1cd093f87dc4f695cdbc8e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">The "name" of the first node. <br /></td></tr>
<tr class="separator:af166327b1cd093f87dc4f695cdbc8e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5fc496045f4a1aa74c140826fb26af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe5fc496045f4a1aa74c140826fb26af"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#abe5fc496045f4a1aa74c140826fb26af">DrctdPrb</a></td></tr>
<tr class="memdesc:abe5fc496045f4a1aa74c140826fb26af"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if the problem is directed <br /></td></tr>
<tr class="separator:abe5fc496045f4a1aa74c140826fb26af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a271bf49080742e091a21cf50eeefa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9a271bf49080742e091a21cf50eeefa"></a>
<a class="el" href="classGraph.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ad9a271bf49080742e091a21cf50eeefa">NInt</a></td></tr>
<tr class="memdesc:ad9a271bf49080742e091a21cf50eeefa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of integer-valued variables. <br /></td></tr>
<tr class="separator:ad9a271bf49080742e091a21cf50eeefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275f662a7a69e4f4b3549a01ad3dac27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a275f662a7a69e4f4b3549a01ad3dac27"></a>
<a class="el" href="classGraph.html#ae6fa182c6468c6ef5677848b11b24b92">Index_Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a275f662a7a69e4f4b3549a01ad3dac27">WIsInt</a></td></tr>
<tr class="memdesc:a275f662a7a69e4f4b3549a01ad3dac27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Which of the variables are integer-valued. <br /></td></tr>
<tr class="separator:a275f662a7a69e4f4b3549a01ad3dac27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7f8dce8014f63dc33740d6e2688c9d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc7f8dce8014f63dc33740d6e2688c9d"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#afc7f8dce8014f63dc33740d6e2688c9d">IdxBeg</a></td></tr>
<tr class="memdesc:afc7f8dce8014f63dc33740d6e2688c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of "extra" constraints: start. <br /></td></tr>
<tr class="separator:afc7f8dce8014f63dc33740d6e2688c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae609d509006ee582e830f66889b4d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ae609d509006ee582e830f66889b4d3"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a3ae609d509006ee582e830f66889b4d3">CoefIdx</a></td></tr>
<tr class="memdesc:a3ae609d509006ee582e830f66889b4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of "extra" constraints: indices. <br /></td></tr>
<tr class="separator:a3ae609d509006ee582e830f66889b4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d4b153781cdde5c1248472c0cdb0fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16d4b153781cdde5c1248472c0cdb0fe"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a16d4b153781cdde5c1248472c0cdb0fe">CoefVal</a></td></tr>
<tr class="memdesc:a16d4b153781cdde5c1248472c0cdb0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of "extra" constraints: values. <br /></td></tr>
<tr class="separator:a16d4b153781cdde5c1248472c0cdb0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17e0855fdf95fcc506a3050416e1a39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa17e0855fdf95fcc506a3050416e1a39"></a>
<a class="el" href="classGraph.html#ad43a4b443a5a34a30e1398994912945d">Bool_Vec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aa17e0855fdf95fcc506a3050416e1a39">CIsCpy</a></td></tr>
<tr class="memdesc:aa17e0855fdf95fcc506a3050416e1a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">true for each row of C[] that is a copy of another <br /></td></tr>
<tr class="separator:aa17e0855fdf95fcc506a3050416e1a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d13922475a02efec64018b86dfe4d85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d13922475a02efec64018b86dfe4d85"></a>
<a class="el" href="classGraph.html#ad43a4b443a5a34a30e1398994912945d">Bool_Vec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a6d13922475a02efec64018b86dfe4d85">UIsCpy</a></td></tr>
<tr class="memdesc:a6d13922475a02efec64018b86dfe4d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">true for each row of U[] that is a copy of another <br /></td></tr>
<tr class="separator:a6d13922475a02efec64018b86dfe4d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cfafbdf135c8b024e47b758edbf8c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0cfafbdf135c8b024e47b758edbf8c4"></a>
<a class="el" href="classGraph.html#ad43a4b443a5a34a30e1398994912945d">Bool_Vec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ac0cfafbdf135c8b024e47b758edbf8c4">BIsCpy</a></td></tr>
<tr class="memdesc:ac0cfafbdf135c8b024e47b758edbf8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">true for each row of B[] that is a copy of another <br /></td></tr>
<tr class="separator:ac0cfafbdf135c8b024e47b758edbf8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696d221a8eb957680461f971fdf093e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a696d221a8eb957680461f971fdf093e8"></a>
<a class="el" href="classGraph.html#ad43a4b443a5a34a30e1398994912945d">Bool_Vec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a696d221a8eb957680461f971fdf093e8">DIsCpy</a></td></tr>
<tr class="memdesc:a696d221a8eb957680461f971fdf093e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">true for each row of D[] that is a copy of another <br /></td></tr>
<tr class="separator:a696d221a8eb957680461f971fdf093e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The class <a class="el" href="classGraph.html" title="The class Graph is a service class for solvers of (generalized) Multicommodity Min-Cost Flow problems...">Graph</a> is a service class for solvers of (generalized) Multicommodity Min-Cost Flow problems, i.e., problems of the form. </p>
<p>min Sum{k = 0 .. K - 1} C[ k ] * X[ k ] + C[ K ] * Y s.t.</p>
<p>(1.k) E * X[ k ] = b[ k ] k = 0 .. K - 1</p>
<p>(2.k) 0 &lt;= X[ k ] &lt;= U[ k ] k = 0 .. K - 1</p>
<p>(3) Sum{k = 0 .. K - 1} X[ i ] &lt;= U</p>
<p>(4) b[ K ] &lt;= Sum{k = 0 .. K - 1} A[ k ] * X[ k ]</p><ul>
<li>A[ K ] * Y &lt;= b[ K + 1 ]</li>
</ul>
<p>(5) U[ K ] &lt;= Y &lt;= U[ K + 1 ]</p>
<p>X[ k ] are the flow variables, one for each commodity; Y[] are the "extra" variables. (1.k) and (2.k) are the Flow Conservation and Upper Bound constraints for commodity k, respectively. E is the node-arc incidence matrix of an underlying graph G(N, A), which is common to all commodities; however, each commodity can in principle flow only on a subset A[ k ] of the arcs A, and therefore it is in fact defined only on a subgraph G[ k ](N[ k ], A[ k ]), where N[ k ] is the subset of N touched by the arcs in A[ k ]. (3) are the Mutual Capacity constraints, linking the (otherwise disjoint) different commodities; (4), that may be empty, are other "extra" constraints, which may be:</p><ul>
<li>commodity-separable, i.e., for some constraint i there exists a commodity k such that A[ h ][ i ] == 0 for all h != k, but not network-type;</li>
<li>other linking constraints between differnet commodities;</li>
<li>constraints linking some (or all) of the commodities to the extra (non-flow) variables Y;</li>
<li>constraints involving only the extra (non-flow) variables Y. (5) are bound constraints on the extra variables.</li>
</ul>
<p>The flow variables X[ k ] and constrains (1.k), (2.k) and (3) are present in all Multicommodity-type problems; the extra variables Y and the extra constraints (4) and (5) are optional.</p>
<p>Flow and extra variables can be declared to be either continuous or integer-valued.</p>
<p>The <a class="el" href="classGraph.html" title="The class Graph is a service class for solvers of (generalized) Multicommodity Min-Cost Flow problems...">Graph</a> class allows to read a description of a MMCF problem from file or from memory and to make them available in an uniform way to solvers. This class is intended essentially only for initialization; the solvers will copy all the relevant information in their internal data structures, and <a class="el" href="classGraph.html" title="The class Graph is a service class for solvers of (generalized) Multicommodity Min-Cost Flow problems...">Graph</a> can be deleted afterwards. However, <a class="el" href="classGraph.html" title="The class Graph is a service class for solvers of (generalized) Multicommodity Min-Cost Flow problems...">Graph</a> also offers some nice pre-processing features, intended to make the instance more easily solvable.</p>
<p>The base class <a class="el" href="classGraph.html" title="The class Graph is a service class for solvers of (generalized) Multicommodity Min-Cost Flow problems...">Graph</a> deals with "generic" MMCF problems, i.e. where there are only constrains (1.k), (2.k) and (3); extra constraints and variables can be added, but there is limited support for them. However, all the methods for handling extra constrains and variables are virtual, hence derived classes can be implemented that deal with special cases of MMCF instances with a special structire of the extra constrains and variables.</p>
<p>In all the comments below, m has to be understood as the number of arcs in the graph G (#A), n as the number of nodes in the graph G (#N) and K as the number of commodities. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a46e43efb25c4d56aac74e6d95973e912"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html">Graph</a> </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>FN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>FT</em> = <code>'s'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor of the Class: builds an instance of MMCF reading the data from the input file `FN'; `FT' must be: </p>
<ul>
<li>'s' (default) for single-file "Canadian" format; this format is actually for Fixed-Charge MMCF, hence there is a Fixed Charge Cost information attached to each arc. Thus, m extra variables are defined, their cost is set to this Fixed Charge Cost, their upper and lower bounds are set set to 0 and 1, respectively, and their type is set to integer;</li>
<li>'c' for single-file PPRN format: actually, the format read by this constructor is a bit more general than the standard definition, since it is permitted for an arc not to have single-commodity capacity (-1);</li>
<li>'p' for a (PSP) formulation \</li>
<li>'o' for a (OSP) formulation | for Jones-Lustig (JL) standard four-files</li>
<li>'d' for a (ODP) formulation | format</li>
<li>'u' /</li>
<li>'m' for the four-files mnetgen format, an extension of the original file format produced by mnetgen (see mnetgen.C), partially compatible with the JL format</li>
</ul>
<p>All the four-files formats read the instance from the 4 files `FN'.nod (the instance size), `FN'.sup (node supply information - but see 'u'), `FN'.arc (arc information) and `FN'.mut (mutual capacity constraints information). The 'o' and 'u' formats are essentially the same, but with 'u' the node supply informations are searched in a `FN'.od.</p>
<p>Actually, there are some restrictions on some of the formats:</p>
<ul>
<li>in the 'c' format, all the coefficients corresponding to the same "extra" constraint must appear consecutively in the file, and the constraints must be well-ordered (that is, all the information about the extra constraint 1 must be found first, then all the information about the extra constraint 2 and so on); also, the separating lines must contain noting (they can be avoided);</li>
<li>in the 'd' ('u') format, it is not allowed to put -1 in the origin or destination columns (1st and 2nd) of *.sup (*.od) file;</li>
<li>in the 'o' format, it is not allowed to put -1 in the origin columns (1st) of *.sup file.</li>
</ul>
<p>After the end of the constructor, the data read is in a "raw" form, i.e. if arc j is not defined for commodity k then CostKJ( k , j ) == Inf&lt;CNumber&gt;() and CapacityKJ( k , j ) == 0, if no single-commodity upper bound is defined for arc j then CapacityKJ( k , j ) == Inf&lt;FNumber&gt;(), if no mutual capacity constraint is defined for arc j then TotalCapacityJ( j ) == Inf&lt;FNumber&gt;() and if node i is not defined for commodity k then DeficitKJ( k , i ) == Inf&lt;FNumber&gt;().</p>
<p>A preprocessing phase [see <a class="el" href="classGraph.html#acfe434663e22c263e46b301196d0fb21" title="Performs various pre-processing of the data, trying to make the instance more easily solvable...">PreProcess()</a> below] is available that, among other things, makes sure that all the Inf&lt;FNumber&gt;() arc capacities (that may disturb some solver) are replaced with proper, finite values. That preprocessing also ensures some obvious things, such as that all arcs entering/leaving a non-existent node for commodity k are non-existent. </p>

</div>
</div>
<a class="anchor" id="a157396871a8c2a05ee2d5d596405b643"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html">Graph</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGraph.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> *&#160;</td>
          <td class="paramname"><em>Def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td>
          <td class="paramname"><em>CapTot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGraph.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> *&#160;</td>
          <td class="paramname"><em>Cap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGraph.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a> *&#160;</td>
          <td class="paramname"><em>Cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor of the class: builds an instance of MMCF reading the data from the provided parameters. </p>
<ul>
<li>n is the number of nodes of the network;</li>
<li>m is the number of arcs (or edges) of the network;</li>
<li>comm is the number of commodities;</li>
<li>Def is the (K x n)-matrix of the node deficits: Def[ k ][ i ] is the deficit of node i relative to commodity k; Def can be 0, meaning that all deficits are 0, and likewise each Def[ k ] can be 0, meaning that all the deficits for commodity k are 0;</li>
<li>S is the m-vector of the starting nodes of the arcs;</li>
<li>E is the m-vector of the ending nodes of the arcs - hence, the i-th arc, 0 &lt;= i &lt; m, is S[ i ] &ndash;&gt; E[ i ];</li>
<li>CapTot is the m-vector of the arc mutual capacities; CapTot can be 0, meaning that all mutual capacities are infinite;</li>
<li>Cap is the (K x m)-matrix of the arc capacities: Cap[ k ][ i ] is the upper capacity of arc i relative to commodity k; Cap can be 0, meaning that all arc capacities are infinite, and likewise each Cap[ k ] can be 0, meaning that all arc capacities for commodity k are infinite;</li>
<li>Cost is the (K x m)-matrix of the arc costs: Cost[ k ][ i ] is the cost of arc i relative to commodity k; arcs with Cost[ k ][ i ] == Inf&lt;CNumber&gt;() are intended as non-existent, thus allowing graphs to be different for each commodity: this is stronger then setting U[ k ][ i ] == 0 [see <a class="el" href="classGraph.html#acfe434663e22c263e46b301196d0fb21" title="Performs various pre-processing of the data, trying to make the instance more easily solvable...">PreProcess()</a> below]; Cost can be 0, meaning that all costs are 0, and likewise each Cost[ k ] can be 0, meaning that all the costs for commodity k are 0;</li>
</ul>
<p>Arc i for commodity k is non-existent if Cost[ k ][ i ] == Inf&lt;CNumber&gt;(), and has no single-commodity capacity if U[ k ][ i ] == Inf&lt;FNumber&gt;(). Arc i has no mutual capacity if CapTot[ i ] == Inf&lt;FNumber&gt;(). Node i for commodity k is non-existent if Def[ k ][ i ] == Inf&lt;FNumber&gt;(). All arcs entering/leaving a non-existent node for commodity k should be non-existent; this is guaranteed by <a class="el" href="classGraph.html#acfe434663e22c263e46b301196d0fb21" title="Performs various pre-processing of the data, trying to make the instance more easily solvable...">PreProcess()</a> [see below].</p>
<p>This constructor builds a problem with no extra variables and constraints, and with all the (flow) variables continuous. This can be changed later with <a class="el" href="classGraph.html#a9b59b567311c0b34246061e886c8b95f" title="Gives the Graph object the information about which among the (flow and non-flow) variables of the pro...">SetIntVar()</a>, SetExtraVar() and <a class="el" href="classGraph.html#a86c641c4c950069bd97c8d4ec63fd010" title="Gives to the Graph object a description of the &quot;extra&quot; constraints in the problem: NXC is the number ...">SetExtraConstr()</a> [see below].</p>
<p>Memory saving trick: sometimes, all arcs have the same capacity or cost, independently from the commodity. It is clearly possible to construct only one m-vector containing the capacities/costs, and copy its pointer k times in Cap[]/Cost[]. The same holds for deficits. Note that, internally, the <a class="el" href="classGraph.html" title="The class Graph is a service class for solvers of (generalized) Multicommodity Min-Cost Flow problems...">Graph</a> object will initially allocate all memory anyway and copy K times the information to separate vectors; however, the redundancy will be eliminated in <a class="el" href="classGraph.html#acfe434663e22c263e46b301196d0fb21" title="Performs various pre-processing of the data, trying to make the instance more easily solvable...">PreProcess()</a> [see below], if it "survives" (preprocessing can alter the values of the data, thus making initially identical vectors different). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae5ef15067c8e3a67fc91caeeadaa4290"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Graph::Index</a> NrComm </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>"base" constructor of the class, that in fact does nothing: is tought as a mean for derived class to provide their own initialization of the data structures, in case they are incompatible with the ones given in the "standard" constructor. </p>
<p>An help to implement your own constructor is given by the protected method <a class="el" href="classGraph.html#ae4f21f1c357df2e1c73d270454629aec" title="Destructor. ">CmnIntlz()</a>, see below. Returns the number of commodities of the network. </p>

</div>
</div>
<a class="anchor" id="acb1ee5e303f8a33c68785c38376d0f05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Graph::Index</a> NrArcs </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of arcs of the network. </p>

</div>
</div>
<a class="anchor" id="a1b8be50014ba948824300612c04d2815"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Graph::Index</a> NrNodes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of nodes of the network. </p>

</div>
</div>
<a class="anchor" id="a9bed463a9b2a5a719c3dde9739d6de95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Graph::Index</a> NrExtraVars </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of extra (non-flow) variables in the problem. </p>

</div>
</div>
<a class="anchor" id="a5128751af2a541d28e6c09b2af3ff0e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Graph::Index</a> NrExtraNonZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>FrstC</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>LstC</em> = <code><a class="el" href="classGraph_1_1Inf.html">Inf</a>&lt;<a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>NrExtraConst() returns the total number of "extra" constraints. </p>
<p>NrExtraNonZ( i , j ) returns the total number of nonzeroes in the representation the "extra" constraints i, i + 1, ... j as linear two-sided inequalities. The "names" (indices) of "extra" constraints go from 0 to NrExtraConst() - 1. It is illegal to call <a class="el" href="classGraph.html#a5128751af2a541d28e6c09b2af3ff0e1" title="NrExtraConst() returns the total number of &quot;extra&quot; constraints. ">NrExtraNonZ()</a> if there are no "extra" constraints, i.e., NrExtraConst() == 0. </p>

</div>
</div>
<a class="anchor" id="a8387ea24fc67b029029d543c78454fed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Graph::MCFType ProblemType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type of the k-th subproblem: it can be a generic Min Cost Flow problem or a Shortest Path Tree problem. </p>
<p>The type is initially set to kMCF, and turned to kSPT (if it is the case) only if PreProcessing() or <a class="el" href="classGraph.html#a930e2af5720510e2ee8f03fd6d831441" title="This method scans the graph and makes all the commodities single-sourced by adding, if necessary, one node to the graph and connecting it to all sources with arcs having individual capacities equal to the capacity of. ">MakeSingleSourced()</a> [see below] are invoked. </p>

</div>
</div>
<a class="anchor" id="a0b1009b5a010f3ba94a5748df83831ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Directed </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the graph is directed, false otherwise. </p>

</div>
</div>
<a class="anchor" id="abe0fbd038d74dc734ff0290ea45c1bfb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NamesStartFrom1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if node "names" (in the arc description) go from 1 to n, false if they go from 0 to n - 1. </p>

</div>
</div>
<a class="anchor" id="ad26c758f072f253671052fe9664d3595"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html#aeea3e5951d222b2a8e57de1b4246a909">Graph::FNumber</a> TotalCapacityJ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The first form returns a read-only pointer to a m-vector containing the mutual capacities of the arcs; the second form returns the mutual capacity of arc j. </p>

</div>
</div>
<a class="anchor" id="acdd44bbe7e170b21d53b41eaabf9e60b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Graph::Index</a> NActives </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Actives() returns a read-only pointer to a m-vector (ordered in increasing sense and Inf&lt;Index&gt;()-terminated) of the indices of arcs that have an associated mutual capacity constraint: it returns 0 if every arc has a constraint. </p>
<p><a class="el" href="classGraph.html#acdd44bbe7e170b21d53b41eaabf9e60b" title="Actives() returns a read-only pointer to a m-vector (ordered in increasing sense and Inf&lt;Index&gt;()-ter...">NActives()</a> returns the number of such mutual capacity constraints: Actives() == 0 =&gt; <a class="el" href="classGraph.html#acdd44bbe7e170b21d53b41eaabf9e60b" title="Actives() returns a read-only pointer to a m-vector (ordered in increasing sense and Inf&lt;Index&gt;()-ter...">NActives()</a> == <a class="el" href="classGraph.html#acb1ee5e303f8a33c68785c38376d0f05" title="Returns the number of arcs of the network. ">NrArcs()</a>.</p>
<p>This information is computed in <a class="el" href="classGraph.html#acfe434663e22c263e46b301196d0fb21" title="Performs various pre-processing of the data, trying to make the instance more easily solvable...">PreProcess()</a> [see below], and therefore Actives() will always return 0 if called before <a class="el" href="classGraph.html#acfe434663e22c263e46b301196d0fb21" title="Performs various pre-processing of the data, trying to make the instance more easily solvable...">PreProcess()</a>. Note that ProProcess() finds a finite value for mutual capacities, i.e., after ProProcess() TotalCapacityJ( j ) returns something &lt; Inf&lt;FNumber&gt;() even if the index j is not contained in the vector returned by Actives(). </p>

</div>
</div>
<a class="anchor" id="ad82926e7eeda572956e4df41ee4c2da5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html#a24d0627ba8213afe1ec4ebeb4508e8f1">Graph::CNumber</a> CostKJ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The first form returns a read-only pointer to a m-vector containing the costs of the arcs relative to commodity k; the second form returns the cost of arc j relative to commodity k. </p>
<p>If k == <a class="el" href="classGraph.html#ae5ef15067c8e3a67fc91caeeadaa4290" title="&quot;base&quot; constructor of the class, that in fact does nothing: is tought as a mean for derived class to ...">NrComm()</a>, the costs of "extra" (non-flow) variables are returned; it is illegal to call these methods with k == <a class="el" href="classGraph.html#ae5ef15067c8e3a67fc91caeeadaa4290" title="&quot;base&quot; constructor of the class, that in fact does nothing: is tought as a mean for derived class to ...">NrComm()</a> if there are no extra variables, i.e. <a class="el" href="classGraph.html#a9bed463a9b2a5a719c3dde9739d6de95" title="Returns the number of extra (non-flow) variables in the problem. ">NrExtraVars()</a> == 0. </p>

</div>
</div>
<a class="anchor" id="a4457086e8c668c0ac84104d52f2ad76c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html#aeea3e5951d222b2a8e57de1b4246a909">Graph::FNumber</a> CapacityKJ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The first form returns a read-only pointer to a m-vector containing the single-commodity capacities relative to commodity k; the second form returns the single-commodity capacity of arc j for commodity k. </p>
<p>For k == <a class="el" href="classGraph.html#ae5ef15067c8e3a67fc91caeeadaa4290" title="&quot;base&quot; constructor of the class, that in fact does nothing: is tought as a mean for derived class to ...">NrComm()</a> and k == <a class="el" href="classGraph.html#ae5ef15067c8e3a67fc91caeeadaa4290" title="&quot;base&quot; constructor of the class, that in fact does nothing: is tought as a mean for derived class to ...">NrComm()</a> + 1, the lower and upper bounds on the "extra" (non-flow) variables are returned, respectively: it is illegal to call these methods with k &gt; <a class="el" href="classGraph.html#ae5ef15067c8e3a67fc91caeeadaa4290" title="&quot;base&quot; constructor of the class, that in fact does nothing: is tought as a mean for derived class to ...">NrComm()</a> if there are no extra variables, i.e. <a class="el" href="classGraph.html#a9bed463a9b2a5a719c3dde9739d6de95" title="Returns the number of extra (non-flow) variables in the problem. ">NrExtraVars()</a> == 0. </p>

</div>
</div>
<a class="anchor" id="abefa8a92f5b18bcc6db76698823efb4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Graph::Index</a> NActivesK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ActivesK( k ) returns a read-only pointer to the vector (ordered in. </p>
<p>increasing sense and Inf&lt;Index&gt;()-terminated) of the indices of arcs that have an associated individual capacity constrint for the commodity k; it returns 0 if every arc has its constraint.</p>
<p>NActivesK( k ) returns the number of such individual capacity constraints for commodity k: ActivesK( k ) == 0 =&gt; NActivesK( k ) == <a class="el" href="classGraph.html#acb1ee5e303f8a33c68785c38376d0f05" title="Returns the number of arcs of the network. ">NrArcs()</a>. NActivesK( NComm ) returns the total number of such constraints, i.e. the sum over all k of NActivesK( k ).</p>
<p>This information is computed in <a class="el" href="classGraph.html#acfe434663e22c263e46b301196d0fb21" title="Performs various pre-processing of the data, trying to make the instance more easily solvable...">PreProcess()</a> [see below], and therefore Actives( k ) will always return 0 if called before <a class="el" href="classGraph.html#acfe434663e22c263e46b301196d0fb21" title="Performs various pre-processing of the data, trying to make the instance more easily solvable...">PreProcess()</a>. Note that ProProcess() finds a finite value for mutual capacities, i.e. after ProProcess() CapacityKJ( k , j ) returns something &lt; Inf&lt;FNumber&gt;() even if the index j is not contained in the vector returned by Actives( k ). </p>

</div>
</div>
<a class="anchor" id="ac7f6948c66a0a4a72d881e3f9f6701aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html#aeea3e5951d222b2a8e57de1b4246a909">Graph::FNumber</a> DeficitKJ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The first form returns a read-only pointer to a n-vector containing the node deficits relative to commodity k; the second form returns the deficit of node j relative to commodity k. </p>
<p>For k == <a class="el" href="classGraph.html#ae5ef15067c8e3a67fc91caeeadaa4290" title="&quot;base&quot; constructor of the class, that in fact does nothing: is tought as a mean for derived class to ...">NrComm()</a> and k == <a class="el" href="classGraph.html#ae5ef15067c8e3a67fc91caeeadaa4290" title="&quot;base&quot; constructor of the class, that in fact does nothing: is tought as a mean for derived class to ...">NrComm()</a> + 1, the lower and upper ranges of the "extra" constraints are returned, respectively: it is illegal to call these methods with k &gt;= <a class="el" href="classGraph.html#ae5ef15067c8e3a67fc91caeeadaa4290" title="&quot;base&quot; constructor of the class, that in fact does nothing: is tought as a mean for derived class to ...">NrComm()</a> if there are no extra constraints, i.e. NrExtraConst() == 0. </p>

</div>
</div>
<a class="anchor" id="a3e44c6205c9171e1e072b51cef1bc66e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Graph::Index</a> StartNJ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The first form returns a read-only pointer to a m-vector containing the starting nodes of the arcs; the second form returns the starting node of arc j. </p>

</div>
</div>
<a class="anchor" id="a2ea35ab8b1343e74da770e41de843ec5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html#a81575b2d4e4d5636b17170432150ae69">Graph::cIndex_Set</a> WIntVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Some of the variables of the MMCF-like problem may be constrained to be integer-valued. </p>
<p>NIntVar( k ) returns the number of the variables for commodity k that are constrained to be integer-valued. If 0 &lt; NIntVar( k ) &lt; <a class="el" href="classGraph.html#acb1ee5e303f8a33c68785c38376d0f05" title="Returns the number of arcs of the network. ">NrArcs()</a>, WIntVar( k ) returns a read-only pointer to the vector of indices (ordered in increasing sense and Inf&lt;Index&gt;()-terminated) of the flow variables for commodity k that are integer-valued. If NIntVar( k ) == 0 or NIntVar( k ) == <a class="el" href="classGraph.html#acb1ee5e303f8a33c68785c38376d0f05" title="Returns the number of arcs of the network. ">NrArcs()</a>, then WIntVar( k ) returns 0; none/all the variables for commodity k are integer-valued.</p>
<p>For k == <a class="el" href="classGraph.html#ae5ef15067c8e3a67fc91caeeadaa4290" title="&quot;base&quot; constructor of the class, that in fact does nothing: is tought as a mean for derived class to ...">NrComm()</a>, these methods provide the same information for the "extra" (non-flow) variables; of course, the indices in the vector returned by WIntVar( NrComm() ) must be in the range [0, <a class="el" href="classGraph.html#a9bed463a9b2a5a719c3dde9739d6de95" title="Returns the number of extra (non-flow) variables in the problem. ">NrExtraVars()</a>).</p>
<p>NIntVar( k ) for k &gt; <a class="el" href="classGraph.html#ae5ef15067c8e3a67fc91caeeadaa4290" title="&quot;base&quot; constructor of the class, that in fact does nothing: is tought as a mean for derived class to ...">NrComm()</a> returns the <em>total</em> number of variables of the problem which are constrained to be integer-valued, counting both flow and extra variables. </p>

</div>
</div>
<a class="anchor" id="a1fdfee03a128035deb78eda466222ae1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ExtraConstr </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>IBeg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>FrstC</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>LstC</em> = <code><a class="el" href="classGraph_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes in IBeg, Indx and Vals the description of those "extra" linear constraints of the problem whose "names" (indices) are comprised between FrstC and LstC (see <a class="el" href="classGraph.html#a5128751af2a541d28e6c09b2af3ff0e1" title="NrExtraConst() returns the total number of &quot;extra&quot; constraints. ">NrExtraNonZ()</a> above). </p>
<p>The description is constraint-wise: each constraint is represented by the set of indices of variables with nonzero coefficient and the corresponding coefficients. The indices and coefficients corresponding to the i-th constraint that is returned, i = 0, ..., LstC - FrstC, are written in Indx and Vals, respectively, in the positions between IBeg[ i ] (included) and IBeg[ i + 1 ] (excluded). Thus, IBeg[ LstC - FrstC + 1 ] is also written, its content being the index of the first "free" position in Indx and Vals (the indices and values of constraint LstC - FrstC go up to IBeg[ LstC - FrstC + 1 ] - 1).</p>
<p>The indices corresponding to each constraint, written in Indx, are ordered in increasing sense (and clearly without duplications).</p>
<p>The mapping between indices and variables is the following: the variable corresponding to arc j (0 &lt;= j &lt; m) for commodity k (0 &lt;= k &lt; <a class="el" href="classGraph.html#ae5ef15067c8e3a67fc91caeeadaa4290" title="&quot;base&quot; constructor of the class, that in fact does nothing: is tought as a mean for derived class to ...">NrComm()</a>) has the index k * m + j; the i-th "extra" variable (0 &lt;= i &lt; <a class="el" href="classGraph.html#a9bed463a9b2a5a719c3dde9739d6de95" title="Returns the number of extra (non-flow) variables in the problem. ">NrExtraVars()</a>) has the index K * m + i (the representation is "commodity-wise", with the "extra" variables following). </p>

</div>
</div>
<a class="anchor" id="a551805a33376f114f37d5a700797553e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProblemType </td>
          <td>(</td>
          <td class="paramtype">const MCFType&#160;</td>
          <td class="paramname"><em>NewType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the type of the k-th subproblem. </p>

</div>
</div>
<a class="anchor" id="a5718ccb9ce4c885c85f73b8a3825816a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Directed </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>DG</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decides if the graph G of the problem has to be considered as a directed (DG == true) or an undirected (DG == false) graph, setting the value that is returned by <a class="el" href="classGraph.html#a0b1009b5a010f3ba94a5748df83831ea" title="Returns true if the graph is directed, false otherwise. ">Directed( void )</a> [see above]. </p>
<p>If this method is not called, true (a directed graph) is assumed. </p>

</div>
</div>
<a class="anchor" id="a88d53ec2c780478a9ef2c308ff85b5c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NamesStartFrom1 </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>NSF1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decides if node "names" (in the arc description) go from 1 to n or from 0 to n - 1, setting the value that is returned by <a class="el" href="classGraph.html#abe0fbd038d74dc734ff0290ea45c1bfb" title="Returns true if node &quot;names&quot; (in the arc description) go from 1 to n, false if they go from 0 to n - ...">NamesStartFrom1( void )</a> [see above]. </p>
<p>If this method is not called, true ("names" starting from 1) is assumed.</p>
<p>Note that no check is done to verify if the data of the instance actually corresponds to this setting, nor node "names" are scaled if any of these methods are called: this is user's responsibility. </p>

</div>
</div>
<a class="anchor" id="aaa084dfb28f2d6bd924159276866ea5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void UpDtTotCapJ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#a11f747fbdff346237c8db4469d569994">cFNumber</a>&#160;</td>
          <td class="paramname"><em>NewUj</em> = <code><a class="el" href="classGraph_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="classGraph.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the total upper capacities, either all of them or just the j-th, i.e. </p>
<p>the one corresponding to the j-th arc. 0 means "all Inf&lt;FNumber&gt;()". </p>

</div>
</div>
<a class="anchor" id="ae8ae01873c31fa8d2c289189efbe519e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void UpdateArcCstKJ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#a07dbefeeb08c3f63073622411893eb76">cCNumber</a>&#160;</td>
          <td class="paramname"><em>NewCkj</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the arc costs, either all of the commodity k or just the one relative to j-th arc for commodity k. </p>
<p>0 means "all 0".</p>
<p>For k == <a class="el" href="classGraph.html#ae5ef15067c8e3a67fc91caeeadaa4290" title="&quot;base&quot; constructor of the class, that in fact does nothing: is tought as a mean for derived class to ...">NrComm()</a>, the costs of the "extra" (non-flow) variables are changed: it is illegal to call these methods with k &gt;= <a class="el" href="classGraph.html#ae5ef15067c8e3a67fc91caeeadaa4290" title="&quot;base&quot; constructor of the class, that in fact does nothing: is tought as a mean for derived class to ...">NrComm()</a> if there are no extra variables, i.e. <a class="el" href="classGraph.html#a9bed463a9b2a5a719c3dde9739d6de95" title="Returns the number of extra (non-flow) variables in the problem. ">NrExtraVars()</a> == 0. </p>

</div>
</div>
<a class="anchor" id="a42276a521fe9ca47f316dfa686dac317"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void UpDtArcCapKJ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#a11f747fbdff346237c8db4469d569994">cFNumber</a>&#160;</td>
          <td class="paramname"><em>NewUkj</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the single-commodity capacities, either all of the commodity k or just the one relative to the j-th arc for commodity k. </p>
<p>0 means "all
Inf&lt;FNumber&gt;()".</p>
<p>For k == <a class="el" href="classGraph.html#ae5ef15067c8e3a67fc91caeeadaa4290" title="&quot;base&quot; constructor of the class, that in fact does nothing: is tought as a mean for derived class to ...">NrComm()</a> and k == <a class="el" href="classGraph.html#ae5ef15067c8e3a67fc91caeeadaa4290" title="&quot;base&quot; constructor of the class, that in fact does nothing: is tought as a mean for derived class to ...">NrComm()</a> + 1, the lower and upper bounds on the "extra" (non-flow) variables are changed, respectively: it is illegal to call these methods with k &gt;= <a class="el" href="classGraph.html#ae5ef15067c8e3a67fc91caeeadaa4290" title="&quot;base&quot; constructor of the class, that in fact does nothing: is tought as a mean for derived class to ...">NrComm()</a> if there are no extra variables, i.e. <a class="el" href="classGraph.html#a9bed463a9b2a5a719c3dde9739d6de95" title="Returns the number of extra (non-flow) variables in the problem. ">NrExtraVars()</a> == 0. </p>

</div>
</div>
<a class="anchor" id="a08bf108e1fe3dc0b4f2071a209b34979"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void UpDtNdeDfctKJ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#a11f747fbdff346237c8db4469d569994">cFNumber</a>&#160;</td>
          <td class="paramname"><em>NewDkj</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the node deficits, either all of the commodity k or just the one relative to the j-th arc for commodity k. </p>
<p>0 means "all 0".</p>
<p>For k == <a class="el" href="classGraph.html#ae5ef15067c8e3a67fc91caeeadaa4290" title="&quot;base&quot; constructor of the class, that in fact does nothing: is tought as a mean for derived class to ...">NrComm()</a> and k == <a class="el" href="classGraph.html#ae5ef15067c8e3a67fc91caeeadaa4290" title="&quot;base&quot; constructor of the class, that in fact does nothing: is tought as a mean for derived class to ...">NrComm()</a> + 1, the lower and upper ranges of the "extra" constraints are changed, respectively: it is illegal to call these methods with k &gt;= <a class="el" href="classGraph.html#ae5ef15067c8e3a67fc91caeeadaa4290" title="&quot;base&quot; constructor of the class, that in fact does nothing: is tought as a mean for derived class to ...">NrComm()</a> if there are no extra constraints, i.e. NrExtraConst() == 0. </p>

</div>
</div>
<a class="anchor" id="a9b59b567311c0b34246061e886c8b95f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetIntVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>IntVld</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code><a class="el" href="classGraph_1_1Inf.html">Inf</a>&lt;&#160;<a class="el" href="classGraph.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives the <a class="el" href="classGraph.html" title="The class Graph is a service class for solvers of (generalized) Multicommodity Min-Cost Flow problems...">Graph</a> object the information about which among the (flow and non-flow) variables of the problem are integer-valued. </p>
<p>SetIntVar( k , true/false , ... ) says that some of the variables of the commodity k are/aren't integer-valued. The variables to which the change is applied are the flow variables of commodity k whose index is:</p><ul>
<li>in the set nms[] (which contains indices in [0, <a class="el" href="classGraph.html#acb1ee5e303f8a33c68785c38376d0f05" title="Returns the number of arcs of the network. ">NrArcs()</a> ), ordered in increasing sense and Inf&lt;Index&gt;()-terminated);</li>
<li>comprised between strt (included) and min( stp , NrArcs() ) (excluded). nms == 0 means "all in the interval [strt, stp)".</li>
</ul>
<p>The status of all other variables remains unchanged.</p>
<p>SetIntVar( <a class="el" href="classGraph.html#ae5ef15067c8e3a67fc91caeeadaa4290" title="&quot;base&quot; constructor of the class, that in fact does nothing: is tought as a mean for derived class to ...">NrComm()</a> , ... ) can be used to set the integrality of the "extra" (non-flow) variables; of course, in this case the indices must be in the range [0, <a class="el" href="classGraph.html#a9bed463a9b2a5a719c3dde9739d6de95" title="Returns the number of extra (non-flow) variables in the problem. ">NrExtraVars()</a>).</p>
<p>The original status of the variable when the object is constructed depends on the constructor used and on the arguments passed to it [see above]. </p>

</div>
</div>
<a class="anchor" id="ac9f23c410a3a50056aa1e8c014e185e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetExtraVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>NXV</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells the <a class="el" href="classGraph.html" title="The class Graph is a service class for solvers of (generalized) Multicommodity Min-Cost Flow problems...">Graph</a> object that there are NXV "extra" (non-flow) variables in the problem. </p>
<p>The costs and lower/upper bounds on these new variables can be set with the methods UpDtArcCstK<a href="NComm , ...">J</a> and UpDtArcCapK<a href="NComm /
NComm + 1 , ...">J</a> [see above]; they are set by default respectively to 0, 0 and Inf&lt;FNumber&gt;() uniformly. Also; by default all extra variables are continuous, although this can be changed later with <a class="el" href="classGraph.html#a9b59b567311c0b34246061e886c8b95f" title="Gives the Graph object the information about which among the (flow and non-flow) variables of the pro...">SetIntVar()</a>.</p>
<p>Note that every previous information about extra variables is lost when calling this method, that can be called more than once. Also, a call to SetExtraVars( 0 ) deallocates all the memory reserved for "extra" variables information. </p>

</div>
</div>
<a class="anchor" id="a86c641c4c950069bd97c8d4ec63fd010"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetExtraConstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>NXC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>IBeg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives to the <a class="el" href="classGraph.html" title="The class Graph is a service class for solvers of (generalized) Multicommodity Min-Cost Flow problems...">Graph</a> object a description of the "extra" constraints in the problem: NXC is the number of such constraints, and IStp, Indx and Vals must contain the description. </p>
<p>The description is constraint-wise: each constraint is represented by the set of indices of variables with nonzero coefficient and the corresponding coefficients. The indices and coefficients corresponding to the i-th constraint, i = 0, ..., NXC - 1, are to be found in Indx and Vals, respectively, in the positions between IBeg[ i ] (included) and IBeg[ i + 1 ] (excluded). Thus, IBeg[ NXC ] must also be provided that contains the index of the first "free" position in Indx and Vals (the indices and values of constraint NXC - 1 go up to IBeg[ NXC ] - 1).</p>
<p>The indices corresponding to each constraint, in Indx, must be ordered in increasing sense (and clearly without duplications).</p>
<p>The mapping between indices and variables is the following: the variable corresponding to arc j (0 &lt;= j &lt; m) for commodity k (0 &lt;= k &lt; <a class="el" href="classGraph.html#ae5ef15067c8e3a67fc91caeeadaa4290" title="&quot;base&quot; constructor of the class, that in fact does nothing: is tought as a mean for derived class to ...">NrComm()</a>) has the index k * m + j; the i-th "extra" variable (0 &lt;= i &lt; <a class="el" href="classGraph.html#a9bed463a9b2a5a719c3dde9739d6de95" title="Returns the number of extra (non-flow) variables in the problem. ">NrExtraVars()</a>) has the index K * m + i (the representation is "commodity-wise", with the "extra" variables following).</p>
<p>This is the very same format that is returned by <a class="el" href="classGraph.html#a1fdfee03a128035deb78eda466222ae1" title="Writes in IBeg, Indx and Vals the description of those &quot;extra&quot; linear constraints of the problem whos...">ExtraConstr()</a> [see above]. Actually, <a class="el" href="classGraph.html#a1fdfee03a128035deb78eda466222ae1" title="Writes in IBeg, Indx and Vals the description of those &quot;extra&quot; linear constraints of the problem whos...">ExtraConstr()</a> (at least, in the implementation of the base <a class="el" href="classGraph.html" title="The class Graph is a service class for solvers of (generalized) Multicommodity Min-Cost Flow problems...">Graph</a> class) will return exactly the pointers passed to this method, that will be retained inside the <a class="el" href="classGraph.html" title="The class Graph is a service class for solvers of (generalized) Multicommodity Min-Cost Flow problems...">Graph</a> object. That is, after the call the vectors become "property" of the <a class="el" href="classGraph.html" title="The class Graph is a service class for solvers of (generalized) Multicommodity Min-Cost Flow problems...">Graph</a> object and should not be changed. This method can be called more than once: at each call, the previous pointers (if any) are <em>deallocated</em> and substituted with the newly provided ones. Also, the pointers are deallocated in the destructor of <a class="el" href="classGraph.html" title="The class Graph is a service class for solvers of (generalized) Multicommodity Min-Cost Flow problems...">Graph</a>. A call to SetExtraConstr( 0 , ... ) deallocates all the memory reserved for extra constraints information.</p>
<p>The lower/upper bounds on the new constraints can be set with the method UpDtNdeDfctK<a href="NComm / NComm + 1 , ...">J</a> [see above]: they are set by default respectively to 0 and Inf&lt;FNumber&gt;() uniformly.</p>
<p>Note that no check is done in <a class="el" href="classGraph.html#a86c641c4c950069bd97c8d4ec63fd010" title="Gives to the Graph object a description of the &quot;extra&quot; constraints in the problem: NXC is the number ...">SetExtraConstr()</a> about the validity of the data contained in the provided vectors (the indices being within the ranges and properly ordered). However, <a class="el" href="classGraph.html#acfe434663e22c263e46b301196d0fb21" title="Performs various pre-processing of the data, trying to make the instance more easily solvable...">PreProcess()</a> may use the extra constraints for its purposes, and/or modify them (e.g. by removing all references to variables that are declared non-existent). </p>

</div>
</div>
<a class="anchor" id="acfe434663e22c263e46b301196d0fb21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PreProcess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraph.html#a11f747fbdff346237c8db4469d569994">cFNumber</a>&#160;</td>
          <td class="paramname"><em>IncUk</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#a11f747fbdff346237c8db4469d569994">cFNumber</a>&#160;</td>
          <td class="paramname"><em>DecUk</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#a11f747fbdff346237c8db4469d569994">cFNumber</a>&#160;</td>
          <td class="paramname"><em>IncUjk</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#a11f747fbdff346237c8db4469d569994">cFNumber</a>&#160;</td>
          <td class="paramname"><em>DecUjk</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#a11f747fbdff346237c8db4469d569994">cFNumber</a>&#160;</td>
          <td class="paramname"><em>ChgDfct</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraph.html#a07dbefeeb08c3f63073622411893eb76">cCNumber</a>&#160;</td>
          <td class="paramname"><em>DecCsts</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs various pre-processing of the data, trying to make the instance more easily solvable. </p>
<p>The parameters to be given are the following:</p>
<p>IncUk , DecUk =&gt; (&gt;= 0) upper bounds on the increase and decrease of the mutual capacities: may be Inf&lt;FNumber&gt;() if unknown;</p>
<p>IncUjk , DecUjk =&gt; (&gt;= 0) same as above for single-commodity capacities;</p>
<p>ChgDfct =&gt; (&gt;= 0) upper bound on the maximum change, in absolute value, of the node deficits: it must be a finite number, since it is used to generate "loose" but finite individual capacities for arcs that have none;</p>
<p>DecCsts =&gt; (&gt;= 0) upper bound on the decrease of arc Costs: must be &lt; Inf&lt;CNumber&gt;().</p>
<p>Giving tight bounds (0 is the best, obviously) may cause the preprocessor to find more redundant coupling constraints, to squeeze down individual arc capacities, to remove more unused arcs and in general to do a better preprocessing; for instance, IncUjk == 0 allows <a class="el" href="classGraph.html#acfe434663e22c263e46b301196d0fb21" title="Performs various pre-processing of the data, trying to make the instance more easily solvable...">PreProcess()</a> to declare un-existent (set the cost to Inf&lt;CNumber&gt;()) any arc with 0 individual capacity.</p>
<p>For all k such that, after the pre-processing, the graph has only a source and no (existing) arcs have a "real" capacity, the type of the subproblem is set to kSPT: all other problem types (see ProblemType( k ) below) are left unchanged.</p>
<p>Important note: in order for <a class="el" href="classGraph.html#acfe434663e22c263e46b301196d0fb21" title="Performs various pre-processing of the data, trying to make the instance more easily solvable...">PreProcess()</a> to work, it has to be able to guess at least an upper bound on the maximum quantity of each commodity in the graph. In order to do that, <em>all arcs</em> with potentially <em>negative costs</em> (ChgCsts is used to estimate that) must have a <em>finite capacity</em>.</p>
<p><a class="el" href="classGraph.html#acfe434663e22c263e46b301196d0fb21" title="Performs various pre-processing of the data, trying to make the instance more easily solvable...">PreProcess()</a> will also look for redundancy in the data structures (e.g. identical costs/deficits/individual capacities for some commodities) and eliminate them, thus possibly saving some memory.</p>
<p>It can be called <em>only once</em>. </p>

</div>
</div>
<a class="anchor" id="a930e2af5720510e2ee8f03fd6d831441"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MakeSingleSourced </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ToAll</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method scans the graph and makes all the commodities single-sourced by adding, if necessary, one node to the graph and connecting it to all sources with arcs having individual capacities equal to the capacity of. </p>
<p>each source, no mutual capacity and zero cost. The sources then receive 0 imbalance and the super-source the sum of all their original imbalances. The "name" of the source will be the number of nodes in the graph (plus 1 if <a class="el" href="classGraph.html#abe0fbd038d74dc734ff0290ea45c1bfb" title="Returns true if node &quot;names&quot; (in the arc description) go from 1 to n, false if they go from 0 to n - ...">NamesStartFrom1()</a> [see above]).</p>
<p>This is obviously done only if at least one commodity has more than one source, unless ToALL == true: in this case, the super-source is constructed anyway and it is linked to <em>all</em> nodes i with arcs</p>
<p>/ at 0 cost and capacity - B[ i ][ k ] if B[ i ][ k ] &lt; 0 | \ at Inf&lt;CNumber&gt;() cost and capacity 0 if B[ i ][ k ] &gt;= 0.</p>
<p>Hence, in this case exactly n new arcs will be constructed, but the setting is "resistent" to changes in the imbalances vector: if ToAll if false instead, possibly less then n arcs will be constructed.</p>
<p>After the call, ProblemType( k ) will return kSPT for all k such that the graph (before the call) had at least one source: problems with no sources (circulation problems) cannot be converted to SPTs, and their type is left unchanged (being set to kMCF by the constructor).</p>
<p>This method can be called only once, and <em>before</em> <a class="el" href="classGraph.html#acfe434663e22c263e46b301196d0fb21" title="Performs various pre-processing of the data, trying to make the instance more easily solvable...">PreProcess()</a>. </p>

</div>
</div>
<a class="anchor" id="aa9a544a1ade639057e8c14b957026a25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OutMPSFile </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>FN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>FxdClmns</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>PN</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Outputs the current MMCF problem as a Linear Programming problem in the standard MPS format: if FxdClmns == true, then the fixed-column MPS format is used, else (the default) the "modern" MPS format is used, where fields have not a fixed column positions but are just blank-delimited. </p>
<p>`FN' is taken as the [path]name of the output file, and `PN' (if provided) is taken as the name of the problem, to be written in the NAME field of the MPS file. </p>

</div>
</div>
<a class="anchor" id="a2e048ecce375386cb69fff17eebca2a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGraph.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a> UpperBound </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a (very coarse) Upper Bound to the value of the optimal solution of the MMCF currently represented in the <a class="el" href="classGraph.html" title="The class Graph is a service class for solvers of (generalized) Multicommodity Min-Cost Flow problems...">Graph</a> object. </p>
<p>This is useful e.g. to discover if the MMCF has no solutions when using a decomposition-based algorithm; in fact, in this case one should wait for the Lagrangean to go to +INF to declare the problem unfeasible, but any finite UB to the value of the optimal solution can be used as +INF. Note, however, that the upper bound returned by this method <em>can be tight</em>, i.e., it can be actually the value of one feasible solution (in particular, it surely is in case of a feasibility problem, i.e., all costs equal to zero, which is actually feasible; in this case the method will return zero).</p>
<p>If "extra" (non-flow) variables are defined, they are taken into account when calculating the upper bound.</p>
<p>It is better to call <a class="el" href="classGraph.html#a2e048ecce375386cb69fff17eebca2a1" title="Calculates a (very coarse) Upper Bound to the value of the optimal solution of the MMCF currently rep...">UpperBound()</a> <em>after</em> <a class="el" href="classGraph.html#acfe434663e22c263e46b301196d0fb21" title="Performs various pre-processing of the data, trying to make the instance more easily solvable...">PreProcess()</a> [see below]: a tighter bound is returned. </p>

</div>
</div>
<a class="anchor" id="ae4f21f1c357df2e1c73d270454629aec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CmnIntlz </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Called at the end of any constructor, does some initializations that are common to them all: it is "protected" for allowing derived classes that use the "void" constructor to call it. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classGraph.html">Graph</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
