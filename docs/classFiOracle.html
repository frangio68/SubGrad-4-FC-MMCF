<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>CNDSM: FiOracle Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CNDSM
   &#160;<span id="projectnumber">1.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classFiOracle.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classFiOracle-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FiOracle Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The class <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> provides a standard interface between NDO solvers and the functions that they have to minimize.  
 <a href="classFiOracle.html#details">More...</a></p>

<p><code>#include &lt;FiOracle.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FiOracle:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classFiOracle.png" usemap="#FiOracle_map" alt=""/>
  <map id="FiOracle_map" name="FiOracle_map">
<area href="classFlwFiOrcl.html" title="This class instantiates the FiOracle interface [see FiOracle.h] to solve the flow Lagrangian relaxati..." alt="FlwFiOrcl" shape="rect" coords="0,56,76,80"/>
<area href="classKnpsFiOrcl.html" title="Instantiation of FiOracle for Knapsack Lagrangian relaxation of FC-MMFC. " alt="KnpsFiOrcl" shape="rect" coords="86,56,162,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Types</div></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:gaca9733adf962bbe6ae97f1039c0a3bbe"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classNDOSolver.html">NDOSolver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EasyComp.html#gaca9733adf962bbe6ae97f1039c0a3bbe">GetNDOSolver</a> (void)</td></tr>
<tr class="memdesc:gaca9733adf962bbe6ae97f1039c0a3bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allows to read back the pointer to the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> that has been passed to the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> through <a class="el" href="classFiOracle.html#a3a4ace42fe051de8bae0feccea1bce16" title="This method is meant to pass to the FiOracle a pointer to the NDOSolver object that is using it...">SetNDOSolver()</a> [see above], if any.  <a href="group__EasyComp.html#gaca9733adf962bbe6ae97f1039c0a3bbe">More...</a><br /></td></tr>
<tr class="separator:gaca9733adf962bbe6ae97f1039c0a3bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructor</div></td></tr>
<tr class="memitem:ae6f8eccd8ffb760f2e13a6672dca6752"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#ae6f8eccd8ffb760f2e13a6672dca6752">FiOracle</a> (void)</td></tr>
<tr class="memdesc:ae6f8eccd8ffb760f2e13a6672dca6752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the class: takes no arguments, since everything that concerns the real evaluation of the function must be done in derived classes, which will have their parameters.  <a href="#ae6f8eccd8ffb760f2e13a6672dca6752">More...</a><br /></td></tr>
<tr class="separator:ae6f8eccd8ffb760f2e13a6672dca6752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Other initializations</div></td></tr>
<tr class="memitem:a3a4ace42fe051de8bae0feccea1bce16"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a3a4ace42fe051de8bae0feccea1bce16">SetNDOSolver</a> (<a class="el" href="classNDOSolver.html">NDOSolver</a> *NwSlvr=0)</td></tr>
<tr class="memdesc:a3a4ace42fe051de8bae0feccea1bce16"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is meant to pass to the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> a pointer to the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> object that is using it, and that must be warned if the function Fi changes.  <a href="#a3a4ace42fe051de8bae0feccea1bce16">More...</a><br /></td></tr>
<tr class="separator:a3a4ace42fe051de8bae0feccea1bce16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabfddb18251ec0f18a70f6d8f265e28"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#aaabfddb18251ec0f18a70f6d8f265e28">SetFiLog</a> (ostream *outs=0, const char lvl=0)</td></tr>
<tr class="memdesc:aaabfddb18251ec0f18a70f6d8f265e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">The oracle should ouput any "log" information onto the ostream pointed by outs.  <a href="#aaabfddb18251ec0f18a70f6d8f265e28">More...</a><br /></td></tr>
<tr class="separator:aaabfddb18251ec0f18a70f6d8f265e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2bdf88862022c6cd471546ddfeb602d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#ad2bdf88862022c6cd471546ddfeb602d">SetFiTime</a> (const bool TimeIt=true)</td></tr>
<tr class="memdesc:ad2bdf88862022c6cd471546ddfeb602d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classFiOracle.html#ad2bdf88862022c6cd471546ddfeb602d" title="SetFiTime() allocates an OPTtimers object [see OPTtypes.h] that should be used for timing the calls t...">SetFiTime()</a> allocates an OPTtimers object [see OPTtypes.h] that should be used for timing the calls to relevant methods of the class.  <a href="#ad2bdf88862022c6cd471546ddfeb602d">More...</a><br /></td></tr>
<tr class="separator:ad2bdf88862022c6cd471546ddfeb602d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a848c4b8e474ab60be98c6acca48ccf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a8a848c4b8e474ab60be98c6acca48ccf">SetMaxName</a> (cIndex MxNme=0)</td></tr>
<tr class="memdesc:a8a848c4b8e474ab60be98c6acca48ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">In some cases, an optimal solution of the dual problem (D) [see the general notes] is a mostly welcome thing; typically, this solution is given in terms of convex (nonnegative) multipliers which form 0 out of a set of subgradients (linear constraints) generated during the run of a NDO algorithm [see ReadMult() in <a class="el" href="NDOSlver_8h.html" title="Definition of the abstract base class NDOSolver, which defines the interface for convex minimization ...">NDOSlver.h</a>].  <a href="#a8a848c4b8e474ab60be98c6acca48ccf">More...</a><br /></td></tr>
<tr class="separator:a8a848c4b8e474ab60be98c6acca48ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading the data of the problem</div></td></tr>
<tr class="memitem:a9395fc2b1320d4e44be62366feec4e6e"><td class="memItemLeft" align="right" valign="top">virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a9395fc2b1320d4e44be62366feec4e6e">GetNumVar</a> (void) const </td></tr>
<tr class="memdesc:a9395fc2b1320d4e44be62366feec4e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of variables of the function, i.e., the (maximum) size of the vectors to be passed to <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a> and <a class="el" href="classFiOracle.html#add9e2c034a2af960f3a794cad100bb26" title="The &quot;format&quot; of the vector Lambda set by SetLambda() [see above] depends on the argument LamB passed ...">SetLamBase()</a> [see below].  <a href="#a9395fc2b1320d4e44be62366feec4e6e">More...</a><br /></td></tr>
<tr class="separator:a9395fc2b1320d4e44be62366feec4e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750898ca2374a3b61b4452034738a20d"><td class="memItemLeft" align="right" valign="top">virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a750898ca2374a3b61b4452034738a20d">GetMaxNumVar</a> (void) const </td></tr>
<tr class="memdesc:a750898ca2374a3b61b4452034738a20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method provides the only explicit support &ndash; except for the return value `kFiChgd' of <a class="el" href="classFiOracle.html#aad5c05cf616d9205ee6d83ecbc9fafc5" title="GetFiStatus() returns the internal status of the FiOracle object. ">GetFiStatus()</a> [see below] &ndash; of the class <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> for the case where the function Fi changes over time.  <a href="#a750898ca2374a3b61b4452034738a20d">More...</a><br /></td></tr>
<tr class="separator:a750898ca2374a3b61b4452034738a20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06d81fcb88d9d630c6e16b0c1bed758"><td class="memItemLeft" align="right" valign="top">virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758">GetNrFi</a> (void) const </td></tr>
<tr class="memdesc:ac06d81fcb88d9d630c6e16b0c1bed758"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> returns the number of independent components of <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a>; 1 is the minimum number, meaning that the function is not decomposable.  <a href="#ac06d81fcb88d9d630c6e16b0c1bed758">More...</a><br /></td></tr>
<tr class="separator:ac06d81fcb88d9d630c6e16b0c1bed758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23f3cd83a8888679a62a20aac916fd2"><td class="memItemLeft" align="right" valign="top">virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#ab23f3cd83a8888679a62a20aac916fd2">MaxNConst</a> (void)</td></tr>
<tr class="memdesc:ab23f3cd83a8888679a62a20aac916fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">GetMaxN() returns the number of constraints.  <a href="#ab23f3cd83a8888679a62a20aac916fd2">More...</a><br /></td></tr>
<tr class="separator:ab23f3cd83a8888679a62a20aac916fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9df04b1e885dafb6121783af2e575bb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#ac9df04b1e885dafb6121783af2e575bb">IsFiContinuous</a> (cIndex NrFi=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:ac9df04b1e885dafb6121783af2e575bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the function is continuous.  <a href="#ac9df04b1e885dafb6121783af2e575bb">More...</a><br /></td></tr>
<tr class="separator:ac9df04b1e885dafb6121783af2e575bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4298122bb8cdff6d17a26908af36fa42"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a4298122bb8cdff6d17a26908af36fa42">IsFiConvex</a> (cIndex NrFi=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:a4298122bb8cdff6d17a26908af36fa42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the function is continuous.  <a href="#a4298122bb8cdff6d17a26908af36fa42">More...</a><br /></td></tr>
<tr class="separator:a4298122bb8cdff6d17a26908af36fa42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ccfa71f5548ef17eb5cb51c2fd3531"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a33ccfa71f5548ef17eb5cb51c2fd3531">HasGi</a> (cIndex NrFi=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:a33ccfa71f5548ef17eb5cb51c2fd3531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the oracle is able to provide first-order information about the function.  <a href="#a33ccfa71f5548ef17eb5cb51c2fd3531">More...</a><br /></td></tr>
<tr class="separator:a33ccfa71f5548ef17eb5cb51c2fd3531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef271b80f24b25980d6b0ee4ff17edd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a1ef271b80f24b25980d6b0ee4ff17edd">IsGiContinuous</a> (cIndex NrFi)</td></tr>
<tr class="memdesc:a1ef271b80f24b25980d6b0ee4ff17edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the first-order information of the function [see <a class="el" href="classFiOracle.html#a33ccfa71f5548ef17eb5cb51c2fd3531" title="Returns true if the oracle is able to provide first-order information about the function. ">HasGi()</a> above] is continuous, i.e., the function is differentiable.  <a href="#a1ef271b80f24b25980d6b0ee4ff17edd">More...</a><br /></td></tr>
<tr class="separator:a1ef271b80f24b25980d6b0ee4ff17edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622526f48706a50cc884e474c02a3ca6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a622526f48706a50cc884e474c02a3ca6">HasH</a> (cIndex NrFi)</td></tr>
<tr class="memdesc:a622526f48706a50cc884e474c02a3ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the oracle is able to provide second-order information about the function; for this to happen, (the corresponding) <a class="el" href="classFiOracle.html#a33ccfa71f5548ef17eb5cb51c2fd3531" title="Returns true if the oracle is able to provide first-order information about the function. ">HasGi()</a> also has to return true, that is, an oracle being able to provide second-order information is also necessarily able to provide first-order information.  <a href="#a622526f48706a50cc884e474c02a3ca6">More...</a><br /></td></tr>
<tr class="separator:a622526f48706a50cc884e474c02a3ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabe6e666a34157e78f2bb7b52862944"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#aaabe6e666a34157e78f2bb7b52862944">IsHContinuous</a> (cIndex NrFi)</td></tr>
<tr class="memdesc:aaabe6e666a34157e78f2bb7b52862944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the second-order information of the function [see <a class="el" href="classFiOracle.html#a622526f48706a50cc884e474c02a3ca6" title="Returns true if the oracle is able to provide second-order information about the function; for this t...">HasH()</a> above] is continuous, i.e., the function is twice differentiable.  <a href="#aaabe6e666a34157e78f2bb7b52862944">More...</a><br /></td></tr>
<tr class="separator:aaabe6e666a34157e78f2bb7b52862944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3bd9d923f86ecea4c63fdf599f2674"><td class="memItemLeft" align="right" valign="top">virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a1c3bd9d923f86ecea4c63fdf599f2674">GetMaxName</a> (void) const </td></tr>
<tr class="memdesc:a1c3bd9d923f86ecea4c63fdf599f2674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of dual information stored in the <a class="el" href="classFiOracle.html#ae6f8eccd8ffb760f2e13a6672dca6752" title="Constructor of the class: takes no arguments, since everything that concerns the real evaluation of t...">FiOracle()</a>, as set by the lastes call to <a class="el" href="classFiOracle.html#a8a848c4b8e474ab60be98c6acca48ccf" title="In some cases, an optimal solution of the dual problem (D) [see the general notes] is a mostly welcom...">SetMaxName()</a>.  <a href="#a1c3bd9d923f86ecea4c63fdf599f2674">More...</a><br /></td></tr>
<tr class="separator:a1c3bd9d923f86ecea4c63fdf599f2674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5deec7bb1a3f6dd38e937b1d10e302df"><td class="memItemLeft" align="right" valign="top">virtual HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a5deec7bb1a3f6dd38e937b1d10e302df">GetMinusInfinity</a> (void)</td></tr>
<tr class="memdesc:a5deec7bb1a3f6dd38e937b1d10e302df"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function Fi to be minimized may be unbounded below, i.e., its infimum may be - INF.  <a href="#a5deec7bb1a3f6dd38e937b1d10e302df">More...</a><br /></td></tr>
<tr class="separator:a5deec7bb1a3f6dd38e937b1d10e302df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa3c6db35753d8771cf7edfa91b4511"><td class="memItemLeft" align="right" valign="top">virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a0aa3c6db35753d8771cf7edfa91b4511">GetMaxNZ</a> (cIndex wFi=Inf&lt; Index &gt;()) const </td></tr>
<tr class="memdesc:a0aa3c6db35753d8771cf7edfa91b4511"><td class="mdescLeft">&#160;</td><td class="mdescRight">The subgradients returned by the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> may happen to be very "sparse", i.e., containing very few nonzeroes; sometimes, the maximum number of nonzeroes is known in advance.  <a href="#a0aa3c6db35753d8771cf7edfa91b4511">More...</a><br /></td></tr>
<tr class="separator:a0aa3c6db35753d8771cf7edfa91b4511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6cf4670f5890cccb12c2a29541476a0"><td class="memItemLeft" align="right" valign="top">virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#ac6cf4670f5890cccb12c2a29541476a0">GetMaxCNZ</a> (cIndex wFi=Inf&lt; Index &gt;()) const </td></tr>
<tr class="memdesc:ac6cf4670f5890cccb12c2a29541476a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method has the same meaning as <a class="el" href="classFiOracle.html#a0aa3c6db35753d8771cf7edfa91b4511" title="The subgradients returned by the FiOracle may happen to be very &quot;sparse&quot;, i.e., containing very few n...">GetMaxNZ()</a> [see above], but it is about the sparsity of constraints rather than subgradients, as the two may be different.  <a href="#ac6cf4670f5890cccb12c2a29541476a0">More...</a><br /></td></tr>
<tr class="separator:ac6cf4670f5890cccb12c2a29541476a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179fff6118652ccec0be73c6be9392ef"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a179fff6118652ccec0be73c6be9392ef">GetUC</a> (cIndex i)</td></tr>
<tr class="memdesc:a179fff6118652ccec0be73c6be9392ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variables of the function may be either constrained in sign, i.e., required to be nonnegative, or unconstrained; if Fi is a Lagrangian function, for instance, constrained variables correspond to inequality constraints while unconstrained variables correspond to equality constraints.  <a href="#a179fff6118652ccec0be73c6be9392ef">More...</a><br /></td></tr>
<tr class="separator:a179fff6118652ccec0be73c6be9392ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d98454a28ee04340a55e6eb74008344"><td class="memItemLeft" align="right" valign="top">virtual LMNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a7d98454a28ee04340a55e6eb74008344">GetUB</a> (cIndex i)</td></tr>
<tr class="memdesc:a7d98454a28ee04340a55e6eb74008344"><td class="mdescLeft">&#160;</td><td class="mdescRight">For some of the variables of the function, an upper bound on the optimal value may be known.  <a href="#a7d98454a28ee04340a55e6eb74008344">More...</a><br /></td></tr>
<tr class="separator:a7d98454a28ee04340a55e6eb74008344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d48adde3013240cedc4c12f7e849cf4"><td class="memItemLeft" align="right" valign="top">virtual LMNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a2d48adde3013240cedc4c12f7e849cf4">GetBndEps</a> (void)</td></tr>
<tr class="memdesc:a2d48adde3013240cedc4c12f7e849cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">When some of the variables are declared by the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> either to be nonnegative [see <a class="el" href="classFiOracle.html#a179fff6118652ccec0be73c6be9392ef" title="The variables of the function may be either constrained in sign, i.e., required to be nonnegative...">GetUC()</a> above] or to possess a finite upper bound [see <a class="el" href="classFiOracle.html#a7d98454a28ee04340a55e6eb74008344" title="For some of the variables of the function, an upper bound on the optimal value may be known...">GetUB()</a> above], the NDO algorithm should take care to only provide values for these variables which satisfy 0 &lt;= Lambda[ i ] &lt;= GetUB( i ) in the points it intends to probe the function in [see <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a> below].  <a href="#a2d48adde3013240cedc4c12f7e849cf4">More...</a><br /></td></tr>
<tr class="separator:a2d48adde3013240cedc4c12f7e849cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bc426be37980f2cf9d1c43ac166f55"><td class="memItemLeft" align="right" valign="top">virtual HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#ac9bc426be37980f2cf9d1c43ac166f55">GetGlobalLipschitz</a> (cIndex wFi=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:ac9bc426be37980f2cf9d1c43ac166f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Lipschitz constant.  <a href="#ac9bc426be37980f2cf9d1c43ac166f55">More...</a><br /></td></tr>
<tr class="separator:ac9bc426be37980f2cf9d1c43ac166f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5a82019520f11aeeed9501d044e5ee3"><td class="memItemLeft" align="right" valign="top">virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EasyComp.html#gad5a82019520f11aeeed9501d044e5ee3">GetBNC</a> (cIndex wFi)</td></tr>
<tr class="memdesc:gad5a82019520f11aeeed9501d044e5ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of variables of the "easy" linear problem which describes Fi[ wFi ], that is, the number of columns of the matrices B[ wFi ] and A[ wFi ] and the lenght of the vectors x[ wFi ], c[ wFi ], l[ wFi ] and u[ wFi ].  <a href="group__EasyComp.html#gad5a82019520f11aeeed9501d044e5ee3">More...</a><br /></td></tr>
<tr class="separator:gad5a82019520f11aeeed9501d044e5ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30047aa832e702b7926cc65fba67625a"><td class="memItemLeft" align="right" valign="top">virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EasyComp.html#ga30047aa832e702b7926cc65fba67625a">GetBNR</a> (cIndex wFi)</td></tr>
<tr class="memdesc:ga30047aa832e702b7926cc65fba67625a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rows of the matrix B[ wFi ] and the lenght of the vectors d[ wFi ] and e[ wFi ]; GetBNR( wFi ) can return 0 if only "box" constraints are imposed on the variables x[ wFi ].  <a href="group__EasyComp.html#ga30047aa832e702b7926cc65fba67625a">More...</a><br /></td></tr>
<tr class="separator:ga30047aa832e702b7926cc65fba67625a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2164e0f768d3be7dbbda360cc8f646fc"><td class="memItemLeft" align="right" valign="top">virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EasyComp.html#ga2164e0f768d3be7dbbda360cc8f646fc">GetBNZ</a> (cIndex wFi)</td></tr>
<tr class="memdesc:ga2164e0f768d3be7dbbda360cc8f646fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nonzeroes in the matrix B[ wFi ]; this is clearly 0 if GetBNR( wFi ) == 0.  <a href="group__EasyComp.html#ga2164e0f768d3be7dbbda360cc8f646fc">More...</a><br /></td></tr>
<tr class="separator:ga2164e0f768d3be7dbbda360cc8f646fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1771551bac42d9e58f59116189c54ee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EasyComp.html#gac1771551bac42d9e58f59116189c54ee">GetBDesc</a> (cIndex wFi, int *Bbeg, int *Bind, double *Bval, double *lhs, double *rhs, double *cst, double *lbd, double *ubd)</td></tr>
<tr class="memdesc:gac1771551bac42d9e58f59116189c54ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a description of the matrix B[ wFi ] and of the vectors d[ wFi ], e[ wFi ], c[ wFi ], l[ wFi ] and u[ wFi ].  <a href="group__EasyComp.html#gac1771551bac42d9e58f59116189c54ee">More...</a><br /></td></tr>
<tr class="separator:gac1771551bac42d9e58f59116189c54ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9811ae42439c72a16806d3ce01db7557"><td class="memItemLeft" align="right" valign="top">virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EasyComp.html#ga9811ae42439c72a16806d3ce01db7557">GetANZ</a> (cIndex wFi, cIndex strt=0, Index stp=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:ga9811ae42439c72a16806d3ce01db7557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nonzeroes in the matrix A[ wFi ] (whose number of columns is GetBNC( wFi ) and whose number of rows is <a class="el" href="classFiOracle.html#a9395fc2b1320d4e44be62366feec4e6e" title="Returns the number of variables of the function, i.e., the (maximum) size of the vectors to be passed...">GetNumVar()</a>); more precisely, it returns the number of nonzeroes in the submatrix of A[ wFi ] containing all the rows with indices between start and min( stp , <a class="el" href="classFiOracle.html#a9395fc2b1320d4e44be62366feec4e6e" title="Returns the number of variables of the function, i.e., the (maximum) size of the vectors to be passed...">GetNumVar()</a> ) - 1 (corresponding to the variables with those "names").  <a href="group__EasyComp.html#ga9811ae42439c72a16806d3ce01db7557">More...</a><br /></td></tr>
<tr class="separator:ga9811ae42439c72a16806d3ce01db7557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40c0ae954bd72a9b30bbefc013e2a2ce"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EasyComp.html#ga40c0ae954bd72a9b30bbefc013e2a2ce">GetADesc</a> (cIndex wFi, int *Abeg, int *Aind, double *Aval, cIndex strt=0, Index stp=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:ga40c0ae954bd72a9b30bbefc013e2a2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a description of the submatrix of A[ wFi ] containing all the rows with indices between start and min( stp , GetNumVar() ) - 1; the meaning of Abeg, Aind and Aval is analogous to that of Bbeg, Bind and Bval in <a class="el" href="group__EasyComp.html#gac1771551bac42d9e58f59116189c54ee" title="Returns a description of the matrix B[ wFi ] and of the vectors d[ wFi ], e[ wFi ], c[ wFi ], l[ wFi ] and u[ wFi ]. ">GetBDesc()</a> [see above].  <a href="group__EasyComp.html#ga40c0ae954bd72a9b30bbefc013e2a2ce">More...</a><br /></td></tr>
<tr class="separator:ga40c0ae954bd72a9b30bbefc013e2a2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Setting Lambda</div></td></tr>
<tr class="memitem:a8cb2c48818819c88850c6a815440b76f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f">SetLambda</a> (cLMRow Lmbd=0)</td></tr>
<tr class="memdesc:a8cb2c48818819c88850c6a815440b76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass to the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> the point where the function <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> has to be evaluated.  <a href="#a8cb2c48818819c88850c6a815440b76f">More...</a><br /></td></tr>
<tr class="separator:a8cb2c48818819c88850c6a815440b76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9e2c034a2af960f3a794cad100bb26"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#add9e2c034a2af960f3a794cad100bb26">SetLamBase</a> (cIndex_Set LmbdB=0, cIndex LmbdBD=0)</td></tr>
<tr class="memdesc:add9e2c034a2af960f3a794cad100bb26"><td class="mdescLeft">&#160;</td><td class="mdescRight">The "format" of the vector Lambda set by <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a> [see above] depends on the argument LamB passed to <a class="el" href="classFiOracle.html#add9e2c034a2af960f3a794cad100bb26" title="The &quot;format&quot; of the vector Lambda set by SetLambda() [see above] depends on the argument LamB passed ...">SetLamBase()</a>.  <a href="#add9e2c034a2af960f3a794cad100bb26">More...</a><br /></td></tr>
<tr class="separator:add9e2c034a2af960f3a794cad100bb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83893a59c6e60b15233ad9e368198015"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a83893a59c6e60b15233ad9e368198015">SetPrecision</a> (HpNum Eps)</td></tr>
<tr class="memdesc:a83893a59c6e60b15233ad9e368198015"><td class="mdescLeft">&#160;</td><td class="mdescRight">The computation of the function Fi may be a costly task, e.g.  <a href="#a83893a59c6e60b15233ad9e368198015">More...</a><br /></td></tr>
<tr class="separator:a83893a59c6e60b15233ad9e368198015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computing Fi()</div></td></tr>
<tr class="memitem:aa90312f57c5be3fb8435a1f394c29533"><td class="memItemLeft" align="right" valign="top">virtual HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533">Fi</a> (cIndex wFi=Inf&lt; Index &gt;())=0</td></tr>
<tr class="memdesc:aa90312f57c5be3fb8435a1f394c29533"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method must return the value of the function Fi to be minimized in the point Lmbd set by <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a> and <a class="el" href="classFiOracle.html#add9e2c034a2af960f3a794cad100bb26" title="The &quot;format&quot; of the vector Lambda set by SetLambda() [see above] depends on the argument LamB passed ...">SetLamBase()</a> [see above].  <a href="#aa90312f57c5be3fb8435a1f394c29533">More...</a><br /></td></tr>
<tr class="separator:aa90312f57c5be3fb8435a1f394c29533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading subgradients / constraints</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The four methods <a class="el" href="classFiOracle.html#aec7d643acc6b898fe0cd91b8dd042d0f" title="This method must be called to ask the FiOracle whether it can produce a &quot;new&quot; item corresponding to t...">NewGi()</a>, <a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a>, <a class="el" href="classFiOracle.html#adf35d71a3d63ba31c64910bdbe650864" title="GetVal() [and GetGi(), see above] can be used to query information about the items. ">GetVal()</a> and <a class="el" href="classFiOracle.html#a2e53e0ca809a3be0075a6b8d53fd3b07" title="After that a new item has been produced, i.e., a call to NewGi() returned true, and that (possibly) G...">SetGiName()</a> are the ones that allow a NDO solver to obtain first-order information about the function Fi at the point Lambda set by <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a> [see above].</p>
<p>The typical use of these methods, in the simplest possible setting, is the following:</p>
<ul>
<li>after having set Lambda[] with <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a> and computed the value of the function with <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a>, the NDO solver asks the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> whether it can produce a new item by calling <a class="el" href="classFiOracle.html#aec7d643acc6b898fe0cd91b8dd042d0f" title="This method must be called to ask the FiOracle whether it can produce a &quot;new&quot; item corresponding to t...">NewGi()</a> (at the first call a return value of true is expected, but the method has to be called anyway);</li>
<li>the NDO solver then uses <a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a> and <a class="el" href="classFiOracle.html#adf35d71a3d63ba31c64910bdbe650864" title="GetVal() [and GetGi(), see above] can be used to query information about the items. ">GetVal()</a> (in <em>this order</em>, see the comments to <a class="el" href="classFiOracle.html#adf35d71a3d63ba31c64910bdbe650864" title="GetVal() [and GetGi(), see above] can be used to query information about the items. ">GetVal()</a>] to extract a description of the item from the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>;</li>
<li>if the item looks "interesting" to the NDO solver, then it calls <a class="el" href="classFiOracle.html#a2e53e0ca809a3be0075a6b8d53fd3b07" title="After that a new item has been produced, i.e., a call to NewGi() returned true, and that (possibly) G...">SetGiName()</a> to signal to the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> that some (dual) information about it should be retained for later use, otherwise <a class="el" href="classFiOracle.html#a2e53e0ca809a3be0075a6b8d53fd3b07" title="After that a new item has been produced, i.e., a call to NewGi() returned true, and that (possibly) G...">SetGiName()</a> is not called;</li>
<li>in either case, if the NDO solver wants another item it calls again <a class="el" href="classFiOracle.html#aec7d643acc6b898fe0cd91b8dd042d0f" title="This method must be called to ask the FiOracle whether it can produce a &quot;new&quot; item corresponding to t...">NewGi()</a>, until either it gets a return value of false or it has got enough items.</li>
</ul>
<p>However, these methods also have other possible uses, as described in their interface. </p>
</div></td></tr>
<tr class="memitem:aec7d643acc6b898fe0cd91b8dd042d0f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#aec7d643acc6b898fe0cd91b8dd042d0f">NewGi</a> (cIndex wFi=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:aec7d643acc6b898fe0cd91b8dd042d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method must be called to ask the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> whether it can produce a "new" item corresponding to the point Lambda set by <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a> and <a class="el" href="classFiOracle.html#add9e2c034a2af960f3a794cad100bb26" title="The &quot;format&quot; of the vector Lambda set by SetLambda() [see above] depends on the argument LamB passed ...">SetLamBase()</a> [see above].  <a href="#aec7d643acc6b898fe0cd91b8dd042d0f">More...</a><br /></td></tr>
<tr class="separator:aec7d643acc6b898fe0cd91b8dd042d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc17c68285be9171d126705efb15cdd"><td class="memItemLeft" align="right" valign="top">virtual Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd">GetGi</a> (SgRow SubG, cIndex_Set &amp;SGBse, cIndex Name=Inf&lt; Index &gt;(), cIndex strt=0, Index stp=Inf&lt; Index &gt;())=0</td></tr>
<tr class="memdesc:a4bc17c68285be9171d126705efb15cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a> [and <a class="el" href="classFiOracle.html#adf35d71a3d63ba31c64910bdbe650864" title="GetVal() [and GetGi(), see above] can be used to query information about the items. ">GetVal()</a>, see below] can be used to query information about the items.  <a href="#a4bc17c68285be9171d126705efb15cdd">More...</a><br /></td></tr>
<tr class="separator:a4bc17c68285be9171d126705efb15cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf35d71a3d63ba31c64910bdbe650864"><td class="memItemLeft" align="right" valign="top">virtual HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#adf35d71a3d63ba31c64910bdbe650864">GetVal</a> (cIndex Name=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:adf35d71a3d63ba31c64910bdbe650864"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classFiOracle.html#adf35d71a3d63ba31c64910bdbe650864" title="GetVal() [and GetGi(), see above] can be used to query information about the items. ">GetVal()</a> [and <a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a>, see above] can be used to query information about the items.  <a href="#adf35d71a3d63ba31c64910bdbe650864">More...</a><br /></td></tr>
<tr class="separator:adf35d71a3d63ba31c64910bdbe650864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e53e0ca809a3be0075a6b8d53fd3b07"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a2e53e0ca809a3be0075a6b8d53fd3b07">SetGiName</a> (cIndex Name)</td></tr>
<tr class="memdesc:a2e53e0ca809a3be0075a6b8d53fd3b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">After that a new item has been produced, i.e., a call to <a class="el" href="classFiOracle.html#aec7d643acc6b898fe0cd91b8dd042d0f" title="This method must be called to ask the FiOracle whether it can produce a &quot;new&quot; item corresponding to t...">NewGi()</a> returned true, and that (possibly) <a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a> / <a class="el" href="classFiOracle.html#adf35d71a3d63ba31c64910bdbe650864" title="GetVal() [and GetGi(), see above] can be used to query information about the items. ">GetVal()</a> have been used to retrieve information about it, the NDO solver can use <a class="el" href="classFiOracle.html#a2e53e0ca809a3be0075a6b8d53fd3b07" title="After that a new item has been produced, i.e., a call to NewGi() returned true, and that (possibly) G...">SetGiName()</a> to tell the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> that a "name" has been assigned to that new item by NDO solver.  <a href="#a2e53e0ca809a3be0075a6b8d53fd3b07">More...</a><br /></td></tr>
<tr class="separator:a2e53e0ca809a3be0075a6b8d53fd3b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading other results</div></td></tr>
<tr class="memitem:acd48c1da81bbd115bd8e41e4abc8f936"><td class="memItemLeft" align="right" valign="top">virtual HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#acd48c1da81bbd115bd8e41e4abc8f936">GetLowerBound</a> (cIndex wFi=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:acd48c1da81bbd115bd8e41e4abc8f936"><td class="mdescLeft">&#160;</td><td class="mdescRight">In some cases, a Lower Bound on the minimal value of Fi is known; if Fi is a Lagrangian function, for instance, the objective function value c( x ) of any dual feasible solution x (s.t.  <a href="#acd48c1da81bbd115bd8e41e4abc8f936">More...</a><br /></td></tr>
<tr class="separator:acd48c1da81bbd115bd8e41e4abc8f936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5c05cf616d9205ee6d83ecbc9fafc5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classFiOracle.html#a04867eec1c7917816fb94b85c12ba6db">FiStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#aad5c05cf616d9205ee6d83ecbc9fafc5">GetFiStatus</a> (Index wFi=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:aad5c05cf616d9205ee6d83ecbc9fafc5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classFiOracle.html#aad5c05cf616d9205ee6d83ecbc9fafc5" title="GetFiStatus() returns the internal status of the FiOracle object. ">GetFiStatus()</a> returns the internal status of the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> object.  <a href="#aad5c05cf616d9205ee6d83ecbc9fafc5">More...</a><br /></td></tr>
<tr class="separator:aad5c05cf616d9205ee6d83ecbc9fafc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87131a6ed4539663f0406932bcfb007"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#ae87131a6ed4539663f0406932bcfb007">FiTime</a> (double &amp;t_us, double &amp;t_ss)</td></tr>
<tr class="memdesc:ae87131a6ed4539663f0406932bcfb007"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this method is called within any of the methods of the class that are "actively timed" (this depends on the subclasses), it returns the user and sistem time (in seconds) since the start of that method.  <a href="#ae87131a6ed4539663f0406932bcfb007">More...</a><br /></td></tr>
<tr class="separator:ae87131a6ed4539663f0406932bcfb007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e53341358998440f1d1d9436b6cdfec"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a4e53341358998440f1d1d9436b6cdfec">FiTime</a> (void)</td></tr>
<tr class="memdesc:a4e53341358998440f1d1d9436b6cdfec"><td class="mdescLeft">&#160;</td><td class="mdescRight">As <a class="el" href="classFiOracle.html#ae87131a6ed4539663f0406932bcfb007" title="If this method is called within any of the methods of the class that are &quot;actively timed&quot; (this depen...">FiTime( double &amp; , double &amp; )</a> [see above], except that returns the total (system + user ) time.  <a href="#a4e53341358998440f1d1d9436b6cdfec">More...</a><br /></td></tr>
<tr class="separator:a4e53341358998440f1d1d9436b6cdfec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Adding / removing / changing data</div></td></tr>
<tr class="memitem:aa80f5c831464c830e75d9a86c18eb1e3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#aa80f5c831464c830e75d9a86c18eb1e3">Deleted</a> (cIndex i=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:aa80f5c831464c830e75d9a86c18eb1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If so instructed by <a class="el" href="classFiOracle.html#a8a848c4b8e474ab60be98c6acca48ccf" title="In some cases, an optimal solution of the dual problem (D) [see the general notes] is a mostly welcom...">SetMaxName()</a> [see above], the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> should keep "dual" information attached to the subgradients/constraints produced [see <a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a> above].  <a href="#aa80f5c831464c830e75d9a86c18eb1e3">More...</a><br /></td></tr>
<tr class="separator:aa80f5c831464c830e75d9a86c18eb1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4d7bd37454c8023326b3668e4f4c27"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a2b4d7bd37454c8023326b3668e4f4c27">Aggregate</a> (cHpRow Mlt, cIndex_Set NmSt, cIndex Dm, cIndex NwNm)</td></tr>
<tr class="memdesc:a2b4d7bd37454c8023326b3668e4f4c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Many NDO algorithms perform operations on the subgradients that they obtain from the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>; the most common operation is taking linear or convex combinations of some subgradients/constraints.  <a href="#a2b4d7bd37454c8023326b3668e4f4c27">More...</a><br /></td></tr>
<tr class="separator:a2b4d7bd37454c8023326b3668e4f4c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destructor</div></td></tr>
<tr class="memitem:a5ae10264c96f255eb0f1724d12170045"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ae10264c96f255eb0f1724d12170045"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~FiOracle</b> ()</td></tr>
<tr class="separator:a5ae10264c96f255eb0f1724d12170045"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Standard fields</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Although <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> is an abstract base class, it contains some protected fields for holding some information that is always going to be there in all implementations, so that several (simple) methods of the public interface can be given a "standard" implementation that is going to work in most cases. </p>
</div></td></tr>
<tr class="memitem:a70ef9a6fc1d031fea63743eef7d8ddf4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70ef9a6fc1d031fea63743eef7d8ddf4"></a>
<a class="el" href="classNDOSolver.html">NDOSolver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a70ef9a6fc1d031fea63743eef7d8ddf4">Slvr</a></td></tr>
<tr class="memdesc:a70ef9a6fc1d031fea63743eef7d8ddf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">(pointer to) the NDO solver that is currently using this oracle <br /></td></tr>
<tr class="separator:a70ef9a6fc1d031fea63743eef7d8ddf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8543193099c64b041d5ad1cc2ace45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa8543193099c64b041d5ad1cc2ace45"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#afa8543193099c64b041d5ad1cc2ace45">NumVar</a></td></tr>
<tr class="memdesc:afa8543193099c64b041d5ad1cc2ace45"><td class="mdescLeft">&#160;</td><td class="mdescRight">(current) number of variables if <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> <br /></td></tr>
<tr class="separator:afa8543193099c64b041d5ad1cc2ace45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221ac7d18f33270b4ef7f4586f5ebc50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a221ac7d18f33270b4ef7f4586f5ebc50"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a221ac7d18f33270b4ef7f4586f5ebc50">MaxName</a></td></tr>
<tr class="memdesc:a221ac7d18f33270b4ef7f4586f5ebc50"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum name to be used in <a class="el" href="classFiOracle.html#a2e53e0ca809a3be0075a6b8d53fd3b07" title="After that a new item has been produced, i.e., a call to NewGi() returned true, and that (possibly) G...">SetGiName()</a> <br /></td></tr>
<tr class="separator:a221ac7d18f33270b4ef7f4586f5ebc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55348f0c36b3cdc7f522f04116d6afc5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55348f0c36b3cdc7f522f04116d6afc5"></a>
cLMRow&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a55348f0c36b3cdc7f522f04116d6afc5">Lambda</a></td></tr>
<tr class="memdesc:a55348f0c36b3cdc7f522f04116d6afc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">(pointer to) the point where <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> has to be evaluated <br /></td></tr>
<tr class="separator:a55348f0c36b3cdc7f522f04116d6afc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f7311fea45f493699851bcee1c0628"><td class="memItemLeft" align="right" valign="top">cIndex_Set&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a17f7311fea45f493699851bcee1c0628">LamBase</a></td></tr>
<tr class="memdesc:a17f7311fea45f493699851bcee1c0628"><td class="mdescLeft">&#160;</td><td class="mdescRight">(pointer to) the set of indices of nonzeroes if Lambda[] is in "sparse" format.  <a href="#a17f7311fea45f493699851bcee1c0628">More...</a><br /></td></tr>
<tr class="separator:a17f7311fea45f493699851bcee1c0628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfe4878ba2fa905d8cb1dd1d3acb81b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cfe4878ba2fa905d8cb1dd1d3acb81b"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a7cfe4878ba2fa905d8cb1dd1d3acb81b">LamBDim</a></td></tr>
<tr class="memdesc:a7cfe4878ba2fa905d8cb1dd1d3acb81b"><td class="mdescLeft">&#160;</td><td class="mdescRight">length of LamBase[] <br /></td></tr>
<tr class="separator:a7cfe4878ba2fa905d8cb1dd1d3acb81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb1cfdeeaec516bdc172e485e6a4753"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bb1cfdeeaec516bdc172e485e6a4753"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a1bb1cfdeeaec516bdc172e485e6a4753">LHasChgd</a></td></tr>
<tr class="memdesc:a1bb1cfdeeaec516bdc172e485e6a4753"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if Lambda has changed since the last call to <a class="el" href="classFiOracle.html#aec7d643acc6b898fe0cd91b8dd042d0f" title="This method must be called to ask the FiOracle whether it can produce a &quot;new&quot; item corresponding to t...">NewGi()</a> <br /></td></tr>
<tr class="separator:a1bb1cfdeeaec516bdc172e485e6a4753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d5dae033892e385945f7cbe99bdb99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49d5dae033892e385945f7cbe99bdb99"></a>
ostream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a49d5dae033892e385945f7cbe99bdb99">FiLog</a></td></tr>
<tr class="memdesc:a49d5dae033892e385945f7cbe99bdb99"><td class="mdescLeft">&#160;</td><td class="mdescRight">the output stream object for log purposes <br /></td></tr>
<tr class="separator:a49d5dae033892e385945f7cbe99bdb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd13d86b57f9d3f02181d0439670117"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fd13d86b57f9d3f02181d0439670117"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#a1fd13d86b57f9d3f02181d0439670117">FiLLvl</a></td></tr>
<tr class="memdesc:a1fd13d86b57f9d3f02181d0439670117"><td class="mdescLeft">&#160;</td><td class="mdescRight">the "level of verbosity" of the log <br /></td></tr>
<tr class="separator:a1fd13d86b57f9d3f02181d0439670117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37f87b4def17d7b955b7d74a73e124a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae37f87b4def17d7b955b7d74a73e124a"></a>
OPTtimers *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiOracle.html#ae37f87b4def17d7b955b7d74a73e124a">Fit</a></td></tr>
<tr class="memdesc:ae37f87b4def17d7b955b7d74a73e124a"><td class="mdescLeft">&#160;</td><td class="mdescRight">OPTtimer for timing purposes. <br /></td></tr>
<tr class="separator:ae37f87b4def17d7b955b7d74a73e124a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The class <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> provides a standard interface between NDO solvers and the functions that they have to minimize. </p>
<p>Given a point Lambda in a finite vector space of proper dimension, the "oracle" must be capable of computing the value Fi( Lambda ) of the proper convex (possibly nondifferentiable) function Fi. The value is allowed to be +Infinity outside of a convex polyhedral set, i.e., the effective domain of Fi can be any polyhedron (possibly the whole space). We will indicate as Dom(Fi) te set of all points Lambda such that Fi( Lambda ) &lt; + INF, i.e., the domain of Fi.</p>
<p>If Fi is finite in Lambda (i.e., Lambda belongs to Dom(Fi)), the oracle must be capable of returning at least one of its subgradients; both Fi-values and subgradients may be &ndash; to a certain extent &ndash; subject to errors.</p>
<p>For any point Lambda where Fi evaluates to +Infinity, the oracle must be capable of returning a linear constraint which is valid for the domain of Fi (i.e., it is satisfied in all points where Fi is finite) and it is strictly violated by Lambda. A special kind of constraints, i.e. "box" constraints 0 &lt;= Lambda[ i ] &lt;= u[ i ] on some of the variables Lambda[ i ], is usually known in advance, and special means are provided for informing the NDO solver about these constraints, so that it can guarantee feasibility at least w.r.t. those.</p>
<p>Often, (epsilon-)subgradients and linear constraints, which are both carachterized by a real vector in the Lambda-space, will be dealt with indifferently, being generally referred to as "items".</p>
<p>Special support is offered for the case where the function Fi to be minimized is "decomposable", i.e., it is given by the sum of k + 1 independent (convex nondifferentiable) functions</p>
<p>Fi( Lambda ) = {h = 0 .. k} Fi[ h ]( Lambda )</p>
<p>where the 0-th component is singled out because it is affine on some convex set, i.e., </p><pre class="fragment">                    / b0 + b * Lambda  if Lambda is in Feas0
</pre><p> Fi[ 0 ]( Lambda ) = | \ +Infinity otherwise</p>
<p>where Feas0 is a convex set; clearly, Dom(Fi) is a subset of Feas0 (one may alternatively say that Fi is the sum of k + 2 functions, as Fi[ 0 ] itself is the sum of an affine function and of the indicator function of Feas0, but there is no algorithmic reason for wanting to do that). Note that, analogously, each individual component may evaluate to +Infinity outside a convex set; in other words, Dom(Fi) is the intersection of Dom( Fi[ h ] ) for h = 0 .. k, where Dom( Fi[ 0 ] ) is Feas0. Also, note that Feas0 is contained in the hyper-rectangle 0 &lt;= Lambda[ i ] &lt;= u[ i ] for all variables i which have box constraints defined, if any.</p>
<p>If the oracle is capable of providing subgradients/constraints for each "component" Fi[ h ], NDO algorithms can exploit this structure by working with this "disaggregate" information rather than with the usual "aggregate" information</p>
<p>Gi( Lambda ) = b + { h = 1 .. k } Gi[ h ]( Lambda )</p>
<p>where Gi[ h ]() is the "subgradient function" for the h-th component of Fi, and Gi() is the "subgradient function" for the whole Fi. Note that, w.l.o.g., we can assume that the special "0-th component" of Fi is a linear (affine) function.</p>
<p>The NDO problem associated with Fi</p>
<p>(P) min{ Fi( Lambda ) }</p>
<p>has a dual problem (in the general case of a decomposable Fi)</p>
<p>(D) min { h = 1 .. k } Fi*[ h ]( z[ h ] ) + S( s ) </p><pre class="fragment">  s.t. \sum{ h = 1 .. k } z[ h ] + s + b = 0
</pre><p>where each Fi*[ h ] is the Fenchel's conjugate function of Fi[ h ], and S() is the support function of Feas0, i.e.</p>
<p>S( s ) = sup{ s * Lambda : Lambda  Feas0 }</p>
<p>(this actually being the Fenchel's conjugate function of the indicator function of Feas0). Note that if Feas0 is the whole space then S() is</p><ul>
<li>INF everythere except for s = 0, so (D) simplifies somewhat.</li>
</ul>
<p>Certifying the (epsilon-)optimality of a point Lambda for (P) means proving that 0 belongs to the (epsilon-)subdifferential of Fi in Lambda; this can be seen as constructing a solution z* of (D) such that Fi( Lambda ) = - Fi*[ h ][ z*[ h ] ]. z* is often constructed by taking convex combinations of the (epsilon-)subgradients found during the optimization process. This is particularly interesting when Fi is a Lagrangian function, that is, an "original problem"</p>
<p>(OP) sup{ c( x ) : A( x ) [&lt;]= b , x  X }</p>
<p>exists such that Fi is</p>
<p>Fi( Lambda ) = sup{ c( x ) - Lambda*A( x ) : x  X } + Lambda * b.</p>
<p>We will refere to this case as the "Lagrangian case", as the above problem, that must be solved by the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> in order to compute the value of Fi, is the Lagrangian relaxation of (OP) w.r.t. the constraints A( x ) [&lt;]= b. For any (epsilon-)optimal solution x( Lambda ) of the Lagrangian relaxation,</p>
<p>Gi( Lambda ) = b - A( x( Lambda ) )</p>
<p>is an epsilon-subgradient of Fi in Lambda. In this case, (P) is equivalent (if A() and c() are linear functions) to</p>
<p>(D) sup{ c( x ) : A( x ) [&lt;]= b , x  conv( X ) }.</p>
<p>Thus, in the Lagrangian case any convex combination of (epsilon-) subgradients corresponds to a point x  conv( X ), and in this way an optimal solution for the "convex relaxation" (D) of (OP) can be obtained. A similar interpretation holds for the information that the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> has to provide when a point Lambda outside of the domain of Fi is evaluated, i.e., a cutting plane separating Lambda from the domain; these cutting planes can be seen to be generated by extreme rays of the unbounded set X, so that any x  conv( X ) is given by the convex combination of feasible finite solutions of the Lagrangian relaxation plus the nonnegative combination of extreme rays of X.</p>
<p>The minimization of a (NonDifferentiable) convex function may be only one step of a more complicated process, which may require the (approximate) minimization of a family of related functions. For instance, if <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> is a Lagrangian function, one may want to solve a set of NDO problems corresponding to different restrictions of the same Lagrangian problem, e.g. to derive bounds within an implicit enumeration approach to the original problem (OP).</p>
<p>Since all the information about the function is "hidden" in the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>, changes in the function can be "triggered" by decisions that happen inside the oracle. However, these changes must then be communicated somehow to the solver that is using the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>, since typically the solver relies on information gathered during the optimization process to drive its subsequent decisions, and that information may have become unvalid. Pretty often, however, the previous information can be exploited, possibily after proper modifications, to "warm-start" the optimization of the new function.</p>
<p>Indeed, part of the interface of the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> class provides means for communicating these changes [see [Add/Remove]Variables(), ChgFiV() and ChgSbG() in <a class="el" href="NDOSlver_8h.html" title="Definition of the abstract base class NDOSolver, which defines the interface for convex minimization ...">NDOSlver.h</a>]; thus, even though the interaction between <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> and <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> is mostly a master-slave one, with the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> acting as the master, there can be times when it is the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> that impose changes to the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a>. Note that, in order to call the methods of the concerned <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a>, the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> must be given a pointer to the solver object [see SetNDOSOlver() below]. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a04867eec1c7917816fb94b85c12ba6db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classFiOracle.html#a04867eec1c7917816fb94b85c12ba6db">FiStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public enum describing the "status" of the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> as returned by <a class="el" href="classFiOracle.html#aad5c05cf616d9205ee6d83ecbc9fafc5" title="GetFiStatus() returns the internal status of the FiOracle object. ">GetFiStatus()</a> [see below]. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae6f8eccd8ffb760f2e13a6672dca6752"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFiOracle.html">FiOracle</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor of the class: takes no arguments, since everything that concerns the real evaluation of the function must be done in derived classes, which will have their parameters. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3a4ace42fe051de8bae0feccea1bce16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetNDOSolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNDOSolver.html">NDOSolver</a> *&#160;</td>
          <td class="paramname"><em>NwSlvr</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is meant to pass to the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> a pointer to the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> object that is using it, and that must be warned if the function Fi changes. </p>
<p>Passing 0 means that either no solver is currently using this <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> or that the solver does not want to know about the changes in the function. </p>

</div>
</div>
<a class="anchor" id="aaabfddb18251ec0f18a70f6d8f265e28"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetFiLog </td>
          <td>(</td>
          <td class="paramtype">ostream *&#160;</td>
          <td class="paramname"><em>outs</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>lvl</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The oracle should ouput any "log" information onto the ostream pointed by outs. </p>
<p>lvl controls the "level of verbosity" of the code: lvl == 0 means that nothing at all is printed, and values larger than 0 mean increasing amounts of information, the specific effect of each value being derived- class-dependent. outs == 0 implies lvl == 0. </p>

<p>Reimplemented in <a class="el" href="classFlwFiOrcl.html#ad188c78f5811dd712f6078a34b4ee123">FlwFiOrcl</a>, and <a class="el" href="classKnpsFiOrcl.html#ad188c78f5811dd712f6078a34b4ee123">KnpsFiOrcl</a>.</p>

</div>
</div>
<a class="anchor" id="ad2bdf88862022c6cd471546ddfeb602d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetFiTime </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>TimeIt</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classFiOracle.html#ad2bdf88862022c6cd471546ddfeb602d" title="SetFiTime() allocates an OPTtimers object [see OPTtypes.h] that should be used for timing the calls t...">SetFiTime()</a> allocates an OPTtimers object [see OPTtypes.h] that should be used for timing the calls to relevant methods of the class. </p>
<p>The time can be read with <a class="el" href="classFiOracle.html#a4e53341358998440f1d1d9436b6cdfec" title="As FiTime( double &amp; , double &amp; ) [see above], except that returns the total (system + user ) time...">FiTime()</a> [see below]. By default, or if SetFiTime( false ) is called, no timing is done. Note that, since all the relevant methods ot the class are pure virtual, <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> can only manage the OPTtimers object, but it is due to derived classes to actually implement the timing.</p>
<p>Note that time accumulates over the calls: calling <a class="el" href="classFiOracle.html#ad2bdf88862022c6cd471546ddfeb602d" title="SetFiTime() allocates an OPTtimers object [see OPTtypes.h] that should be used for timing the calls t...">SetFiTime()</a>, however, resets the counters, allowing to time specific groups of calls. </p>

</div>
</div>
<a class="anchor" id="a8a848c4b8e474ab60be98c6acca48ccf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetMaxName </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>MxNme</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In some cases, an optimal solution of the dual problem (D) [see the general notes] is a mostly welcome thing; typically, this solution is given in terms of convex (nonnegative) multipliers which form 0 out of a set of subgradients (linear constraints) generated during the run of a NDO algorithm [see ReadMult() in <a class="el" href="NDOSlver_8h.html" title="Definition of the abstract base class NDOSolver, which defines the interface for convex minimization ...">NDOSlver.h</a>]. </p>
<p>In the Lagrangian case, the corresponding convex combination of the corresponding points x  X gives an optimal solution for the "convex relaxation" (D) of the original problem (OP); this optimal solution may be a very interesting by-product of the optimization process (or even the real target of the whole approach).</p>
<p>Knowledge of the structure of X is confined in the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> class; thus, it is here that (some information about) the solutions x generated during the algorithm must be kept if an (approximately) optimal solution of (D) has evenctually to be produced. Also, a "naming protocol" is needed to ensure the identification between each subgradient/linear constraint and the corresponding x  X/extreme ray of X.</p>
<p>"Names" are associated with each item in the method <a class="el" href="classFiOracle.html#a2e53e0ca809a3be0075a6b8d53fd3b07" title="After that a new item has been produced, i.e., a call to NewGi() returned true, and that (possibly) G...">SetGiName()</a> [see below] for other purposes; these names are also used as labels for the dual solutions x. The maximum number of different names that will be used by the NDO algorithm corresponds to the maximum number of different dual solutions x/extreme rays that the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> may have to store; this method should be used to communicate this number to the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>, that can use it to properly dimension its internal data structures. The protected field `MaxName' of the base class <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> is provided for storing this information, as in the default implementation of the method.</p>
<p>Once SetMaxName( n ) has been called, the NDO solver is required to only use names 0 .. n - 1 in <a class="el" href="classFiOracle.html#a2e53e0ca809a3be0075a6b8d53fd3b07" title="After that a new item has been produced, i.e., a call to NewGi() returned true, and that (possibly) G...">SetGiName()</a>. <a class="el" href="classFiOracle.html#a8a848c4b8e474ab60be98c6acca48ccf" title="In some cases, an optimal solution of the dual problem (D) [see the general notes] is a mostly welcom...">SetMaxName()</a> can be called more than once to modify the setting, but this may be costly. Also, setting a max name smaller than the previous setting obviously discards all the dual information corresponding to items with names no longer allowed.</p>
<p>By default no dual information is kept by the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>, i.e., the maximum name is 0; in this case, the NDO solver need not use <a class="el" href="classFiOracle.html#a2e53e0ca809a3be0075a6b8d53fd3b07" title="After that a new item has been produced, i.e., a call to NewGi() returned true, and that (possibly) G...">SetGiName()</a>. SetMaxName( 0 ) brings back to this situation, typically making the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> to discard all the currently available x and deallocate some memory.</p>
<p>Other methods are related with handling of the names and the associated dual solutions x, see e.g. <a class="el" href="classFiOracle.html#a2b4d7bd37454c8023326b3668e4f4c27" title="Many NDO algorithms perform operations on the subgradients that they obtain from the FiOracle; the mo...">Aggregate()</a> or Unused() below. </p>

</div>
</div>
<a class="anchor" id="a9395fc2b1320d4e44be62366feec4e6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Index GetNumVar </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of variables of the function, i.e., the (maximum) size of the vectors to be passed to <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a> and <a class="el" href="classFiOracle.html#add9e2c034a2af960f3a794cad100bb26" title="The &quot;format&quot; of the vector Lambda set by SetLambda() [see above] depends on the argument LamB passed ...">SetLamBase()</a> [see below]. </p>
<p>A default implementation is given in the base class which just returns the content of the protected field "NumVar". </p>

</div>
</div>
<a class="anchor" id="a750898ca2374a3b61b4452034738a20d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Index GetMaxNumVar </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method provides the only explicit support &ndash; except for the return value `kFiChgd' of <a class="el" href="classFiOracle.html#aad5c05cf616d9205ee6d83ecbc9fafc5" title="GetFiStatus() returns the internal status of the FiOracle object. ">GetFiStatus()</a> [see below] &ndash; of the class <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> for the case where the function Fi changes over time. </p>
<p>In particular, if the number of variables of Fi may change, and a good estimate of the max number of variables that can ever appear is available, <a class="el" href="classFiOracle.html#a750898ca2374a3b61b4452034738a20d" title="This method provides the only explicit support  except for the return value `kFiChgd&#39; of GetFiStatu...">GetMaxNumVar()</a> can be used to return this information to NDO solver, which may then be able to manage its memory more efficiently. Some NDO solvers may even refuse to handle more variables than the maximum number declared by <a class="el" href="classFiOracle.html#a750898ca2374a3b61b4452034738a20d" title="This method provides the only explicit support  except for the return value `kFiChgd&#39; of GetFiStatu...">GetMaxNumVar()</a>.</p>
<p>No mechanism, however, is provided in the class <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> for changing the number of variables of Fi. Methods for adding and removing variables from the NDO problem [see [Add/Remove]Variables() in <a class="el" href="NDOSlver_8h.html" title="Definition of the abstract base class NDOSolver, which defines the interface for convex minimization ...">NDOSlver.h</a>] are provided by the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> class, and these methods can be properly invoked by the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> using the pointer provided by <a class="el" href="classFiOracle.html#a3a4ace42fe051de8bae0feccea1bce16" title="This method is meant to pass to the FiOracle a pointer to the NDOSolver object that is using it...">SetNDOSolver()</a> [see above]. </p>

</div>
</div>
<a class="anchor" id="ac06d81fcb88d9d630c6e16b0c1bed758"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Index GetNrFi </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> returns the number of independent components of <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a>; 1 is the minimum number, meaning that the function is not decomposable. </p>
<p>Note that even non-decomposable functions has a 0-th linear (affine) part: if <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> is a Lagrangian function, for instance, the linear part corresponds to the right hand side `b' of the relaxed constraints `A( x ) [&lt;]= b'. In general, every function has a linear part, possibly with all-zero coefficients (and, therefore, identically zero).</p>
<p>The return value of <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> allows to properly select the values of the parameter `wFi' in several methods, like <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> and ***Gi() [see below]; however, note that all the interface is carefully structured (by giving default values to the `wFi' parameters) in such a way that a NDO solver which can only deal with non-decomposable functions can easily ignore the information about the decomposability of <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a>, and always treat it like a unique function.</p>
<p>A standard implementation is given for non-decomposable oracles. </p>

</div>
</div>
<a class="anchor" id="ab23f3cd83a8888679a62a20aac916fd2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Index MaxNConst </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>GetMaxN() returns the number of constraints. </p>
<p>This number does not include the box constraints. </p>

</div>
</div>
<a class="anchor" id="ac9df04b1e885dafb6121783af2e575bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IsFiContinuous </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>NrFi</em> = <code>Inf&lt;Index&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the function is continuous. </p>
<p>If 1 &lt;= NrFi &lt;= <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> [see above] the return value is about the component NrFi, while if NrFi &gt; <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> then the return value is about the aggregated function (NrFi == 0 makes no sense since a linear function is continuous, so an oracle may as well decide to ignore it). Note that one would expect that the answer for the aggregated function is true if and only it is true for all the individual components, although in theory this may not be the case.</p>
<p>A standard implementation is given for oracles of continuous functions. </p>

</div>
</div>
<a class="anchor" id="a4298122bb8cdff6d17a26908af36fa42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IsFiConvex </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>NrFi</em> = <code>Inf&lt;Index&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the function is continuous. </p>
<p>If 1 &lt;= NrFi &lt;= <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> [see above] the return value is about the component NrFi, while if NrFi &gt; <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> then the return value is about the aggregated function (NrFi == 0 makes no sense since a linear function is convex, so an oracle may as well decide to ignore it). Note that one would expect that the answer for the aggregated function is true if and only it is true for all the individual components, although in theory this may not be the case.</p>
<p>A standard implementation is given for oracles of convex functions. </p>

</div>
</div>
<a class="anchor" id="a33ccfa71f5548ef17eb5cb51c2fd3531"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool HasGi </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>NrFi</em> = <code>Inf&lt;Index&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the oracle is able to provide first-order information about the function. </p>
<p>If 1 &lt;= NrFi &lt;= <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> [see above] the return value is about the component NrFi, while if NrFi &gt; <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> then the return value is about the aggregated function (NrFi == 0 makes no sense since for a linear function first-order information must clearly be available, so an oracle may as well decide to ignore it). Note that one would expect that the answer for the aggregated function is true if and only it is true for all the individual components, although in theory this may not be the case.</p>
<p>A standard implementation is given for oracles which are able to provide first-order information. </p>

</div>
</div>
<a class="anchor" id="a1ef271b80f24b25980d6b0ee4ff17edd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IsGiContinuous </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>NrFi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the first-order information of the function [see <a class="el" href="classFiOracle.html#a33ccfa71f5548ef17eb5cb51c2fd3531" title="Returns true if the oracle is able to provide first-order information about the function. ">HasGi()</a> above] is continuous, i.e., the function is differentiable. </p>
<p>If 1 &lt;= NrFi &lt;= <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> [see above] the return value is about the component NrFi, while if NrFi &gt; <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> then the return value is about the aggregated function (NrFi == 0 makes no sense since the first-order information of a linear function is constant, hence continuous, so an oracle may as well decide to ignore it). Note that one would expect that the answer for the aggregated function is true if and only it is true for all the individual components, although in theory this may not be the case. Also, note that one would expect this method to return true only if <a class="el" href="classFiOracle.html#a33ccfa71f5548ef17eb5cb51c2fd3531" title="Returns true if the oracle is able to provide first-order information about the function. ">HasGi()</a> (for the corresponding component) returns true; however, this need not necessarily be the case, as one may know that a function is differentiable but still be unable (or unwilling) to compute its gradient. Still, the information that the gradient is continuous is important, in that the solver can then compute approximate first-order information, e.g. by finite differences.</p>
<p>A standard implementation is given for those oracles which either do not provide first-order information, or have it not continuous. </p>

</div>
</div>
<a class="anchor" id="a622526f48706a50cc884e474c02a3ca6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool HasH </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>NrFi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the oracle is able to provide second-order information about the function; for this to happen, (the corresponding) <a class="el" href="classFiOracle.html#a33ccfa71f5548ef17eb5cb51c2fd3531" title="Returns true if the oracle is able to provide first-order information about the function. ">HasGi()</a> also has to return true, that is, an oracle being able to provide second-order information is also necessarily able to provide first-order information. </p>
<p>If 1 &lt;= NrFi &lt;= <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> [see above] the return value is about the component NrFi, while if NrFi &gt; <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> then the return value is about the aggregated function (NrFi == 0 makes no sense since for a linear function second-order information always is the null matrix, so an oracle may as well decide to ignore it). Note that one would expect that the answer for the aggregated function is true if and only it is true for all the individual components, although in theory this may not be the case.</p>
<p>A standard implementation is given for oracles which are not able to provide any form of second-order information. </p>

</div>
</div>
<a class="anchor" id="aaabe6e666a34157e78f2bb7b52862944"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IsHContinuous </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>NrFi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the second-order information of the function [see <a class="el" href="classFiOracle.html#a622526f48706a50cc884e474c02a3ca6" title="Returns true if the oracle is able to provide second-order information about the function; for this t...">HasH()</a> above] is continuous, i.e., the function is twice differentiable. </p>
<p>If 1 &lt;= NrFi &lt;= <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> [see above] the return value is about the component NrFi, while if NrFi &gt; <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> then the return value is about the aggregated function (NrFi == 0 makes no sense since the second-order information of a linear function is constantly equal to the null matrix, hence is continuous, so an oracle may as well decide to ignore it). Note that one would expect that the answer for the aggregated function is true if and only it is true for all the individual components, although in theory this may not be the case. Also, note that one would expect this method to return true only if <a class="el" href="classFiOracle.html#a622526f48706a50cc884e474c02a3ca6" title="Returns true if the oracle is able to provide second-order information about the function; for this t...">HasH()</a> (for the corresponding component) returns true; however, this need not necessarily be the case, as one may know that a function is twice differentiable but still be unable (or unwilling) to compute its Hessian. Still, the information that the Hessian is continuous is important, in that the solver can then compute approximate second-order information, e.g. by finite differences or via some form of quasi-Newton iteration.</p>
<p>A standard implementation is given for those oracles which either do not provide second-order information, or have it not continuous. </p>

</div>
</div>
<a class="anchor" id="a1c3bd9d923f86ecea4c63fdf599f2674"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Index GetMaxName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of dual information stored in the <a class="el" href="classFiOracle.html#ae6f8eccd8ffb760f2e13a6672dca6752" title="Constructor of the class: takes no arguments, since everything that concerns the real evaluation of t...">FiOracle()</a>, as set by the lastes call to <a class="el" href="classFiOracle.html#a8a848c4b8e474ab60be98c6acca48ccf" title="In some cases, an optimal solution of the dual problem (D) [see the general notes] is a mostly welcom...">SetMaxName()</a>. </p>
<p>A defualt implementation is provided which uses the protected field `MaxName'. </p>

</div>
</div>
<a class="anchor" id="a5deec7bb1a3f6dd38e937b1d10e302df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HpNum GetMinusInfinity </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function Fi to be minimized may be unbounded below, i.e., its infimum may be - INF. </p>
<p>In this case, many NDO algorithms will <em>never</em> stop, as there is no way of acheiving - INF by a finite number of finite improvements. However, there are cases where a "finite - INF" can be found, that is, a finite number such that if a smaller Fi-value is found, then Fi can be safely declared unbounded below. If Fi is a Lagrangian function for a problem (D) that is not known to have a feasible solution, a suitable value is any Lower Bound (note that (D) is a max-problem) on the value c( x ) of any feasible solution x (s.t. A( x ) [&lt;]= b and x  X).</p>
<p><a class="el" href="classFiOracle.html#a5deec7bb1a3f6dd38e937b1d10e302df" title="The function Fi to be minimized may be unbounded below, i.e., its infimum may be - INF...">GetMinusInfinity()</a> returns such a value, if it can be provided, and - INF otherwise. In most cases, such a bound is either available from the very beginning or it is not available at all, so calling this method more than once is not likely to provide different answers <em>unless <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> changes</em>. In fact, changes in <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> (number of variables etc.) may very well impact on the "finite - INF" value, so that this method should be called each time this happens. </p>

</div>
</div>
<a class="anchor" id="a0aa3c6db35753d8771cf7edfa91b4511"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Index GetMaxNZ </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>wFi</em> = <code>Inf&lt;Index&gt;()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The subgradients returned by the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> may happen to be very "sparse", i.e., containing very few nonzeroes; sometimes, the maximum number of nonzeroes is known in advance. </p>
<p>If available, this information may be very useful for the NDO solver, as it could save some memory by properly dimensioning its data structures.</p>
<p>GetMaxNZ( wFi ) should return an upper bound on the maximum number of nonzero elements in:</p>
<ul>
<li>the subgradient of the "linear part" of Fi if wFi == 0: this should always be possible, as that subgradient is constant.</li>
<li>the subgradient of the wFi-th component of Fi if 1 &lt;= wFi &lt;= <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a>;</li>
<li>the aggregated subgradient <em>excluding</em> the constant part, i.e. the sum of all the subgradients corresponding to wFi = 1 .. <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a>, if Inf&lt;Index&gt;() &gt; wFi &gt; <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a>;</li>
<li>the aggregated subgradient of Fi if wFi == Inf&lt;Index&gt;().</li>
</ul>
<p>Of course, returning the maximum number of variables is always legal.</p>
<p>Important note: by returning any number &lt; <a class="el" href="classFiOracle.html#a750898ca2374a3b61b4452034738a20d" title="This method provides the only explicit support  except for the return value `kFiChgd&#39; of GetFiStatu...">GetMaxNumVar()</a>, the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> gets an obligation to returning subgradients in a "sparse" form [see <a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a> below]. </p>

</div>
</div>
<a class="anchor" id="ac6cf4670f5890cccb12c2a29541476a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Index GetMaxCNZ </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>wFi</em> = <code>Inf&lt;Index&gt;()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method has the same meaning as <a class="el" href="classFiOracle.html#a0aa3c6db35753d8771cf7edfa91b4511" title="The subgradients returned by the FiOracle may happen to be very &quot;sparse&quot;, i.e., containing very few n...">GetMaxNZ()</a> [see above], but it is about the sparsity of constraints rather than subgradients, as the two may be different. </p>
<p>A constraint is returned when Fi [see below] returns + INF. Note that, how further specified in the comments to <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a>, even constraints are actually associated to the components of Fi.</p>
<p>GetMaxCNZ( wFi ) should return an upper bound on the maximum number of nonzero elements in:</p>
<ul>
<li>a "global" constraint (valid for Feas0 = Dom( Fi[ 0 ]) ) if wFi == 0;</li>
<li>a constraint corresponding to the wFi-th component of Fi (valid for Dom( Fi[ wFi ) ) if 1 &lt;= wFi &lt;= <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a>;</li>
<li>the maximum of the returned values for 1, ..., <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> if Inf&lt;Index&gt;() &gt; wFi &gt; <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a>, i.e., the maximum nonber of nonzeroes in a constraint valid for any Dom( Fi[ h ] ) for any nonzero h;</li>
<li>the maximum of all the above (i.e., any constraint valid for Dom( Fi )) if wFi == Inf&lt;Index&gt;().</li>
</ul>
<p>Of course, returning the maximum number of variables is always legal.</p>
<p>Important note: by returning any number &lt; <a class="el" href="classFiOracle.html#a750898ca2374a3b61b4452034738a20d" title="This method provides the only explicit support  except for the return value `kFiChgd&#39; of GetFiStatu...">GetMaxNumVar()</a>, the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> gets an obligation to returning constraints in a "sparse" form [see <a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a> below]. </p>

</div>
</div>
<a class="anchor" id="a179fff6118652ccec0be73c6be9392ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GetUC </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The variables of the function may be either constrained in sign, i.e., required to be nonnegative, or unconstrained; if Fi is a Lagrangian function, for instance, constrained variables correspond to inequality constraints while unconstrained variables correspond to equality constraints. </p>
<p>GetUC( i ) returns true if the variable i (0 &lt;= i &lt; <a class="el" href="classFiOracle.html#a9395fc2b1320d4e44be62366feec4e6e" title="Returns the number of variables of the function, i.e., the (maximum) size of the vectors to be passed...">GetNumVar()</a>) is unconstrained in sign, and it returns false if it is constrained to be nonnegative. The status of a variable is not assumed to change over time; at least, no support for this is offered by the base <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> class, but a variable can be deleted and re-created with a different status by using the methods [Add/Remove]Variables() of <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> [see <a class="el" href="NDOSlver_8h.html" title="Definition of the abstract base class NDOSolver, which defines the interface for convex minimization ...">NDOSlver.h</a>].</p>
<p>The default implementation of the method corresponds to all the variables being unconstrained. </p>

</div>
</div>
<a class="anchor" id="a7d98454a28ee04340a55e6eb74008344"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual LMNum GetUB </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For some of the variables of the function, an upper bound on the optimal value may be known. </p>
<p>If this happens for all the variables, and they are also all constrained in sign [see <a class="el" href="classFiOracle.html#a179fff6118652ccec0be73c6be9392ef" title="The variables of the function may be either constrained in sign, i.e., required to be nonnegative...">GetUC()</a> above], then a compact set to which any optimal solution belong is known a priori (this knowledge may be required* by some NDO solvers).</p>
<p>GetUB( i ) returns the upper bound on variable i; a return value of + INF says that variable i has no upper bound.</p>
<p>Note that a variable which is unconstrained in sign (see <a class="el" href="classFiOracle.html#a179fff6118652ccec0be73c6be9392ef" title="The variables of the function may be either constrained in sign, i.e., required to be nonnegative...">GetUC()</a> above) can have an upper bound, as well as a variable which is constrained in sign can have no upper bound. See the comments on <a class="el" href="classFiOracle.html#a179fff6118652ccec0be73c6be9392ef" title="The variables of the function may be either constrained in sign, i.e., required to be nonnegative...">GetUC()</a> above for the issue of changes over time of the "status" of a variable.</p>
<p>The default implementation of the method corresponds to no variable having upper bounds. </p>

</div>
</div>
<a class="anchor" id="a2d48adde3013240cedc4c12f7e849cf4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual LMNum GetBndEps </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When some of the variables are declared by the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> either to be nonnegative [see <a class="el" href="classFiOracle.html#a179fff6118652ccec0be73c6be9392ef" title="The variables of the function may be either constrained in sign, i.e., required to be nonnegative...">GetUC()</a> above] or to possess a finite upper bound [see <a class="el" href="classFiOracle.html#a7d98454a28ee04340a55e6eb74008344" title="For some of the variables of the function, an upper bound on the optimal value may be known...">GetUB()</a> above], the NDO algorithm should take care to only provide values for these variables which satisfy 0 &lt;= Lambda[ i ] &lt;= GetUB( i ) in the points it intends to probe the function in [see <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a> below]. </p>
<p>However, many FiOracles may resist to small violations to these bounds. <a class="el" href="classFiOracle.html#a2d48adde3013240cedc4c12f7e849cf4" title="When some of the variables are declared by the FiOracle either to be nonnegative [see GetUC() above] ...">GetBndEps()</a> returns a "small" number eps such that the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> is guaranteed to correctly perform its task as long as</p>
<ul>
<li>eps &lt;= Lambda[ i ] &lt;= ( 1 + eps ) * max( GetUB( i ) , 1 )</li>
</ul>
<p>while it may disbehave (e.g. enter in an infinite loop) if the bound constraints are more violated than that. The default implementation of the method is fine for FiOracles that cannot accept even the tiniest violation in the bound constraints they declare.</p>
<p>The information returned by <a class="el" href="classFiOracle.html#a2d48adde3013240cedc4c12f7e849cf4" title="When some of the variables are declared by the FiOracle either to be nonnegative [see GetUC() above] ...">GetBndEps()</a> is typically useful for another purpose, too: it basically says when is that a variable is "zero" for this particular <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>. Since an error of eps around zero is tolerated by the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>, each variable that has a(n absolute) value &lt;= eps can be safely assumed to be "zero". Note that the "zero" value for a variable has a special meaning for the functions, in particular when adding and deleting variables [see AddVariables() and RemoveVariables() in NDOSolver.h]. </p>

</div>
</div>
<a class="anchor" id="ac9bc426be37980f2cf9d1c43ac166f55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HpNum GetGlobalLipschitz </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>wFi</em> = <code>Inf&lt;Index&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Lipschitz constant. </p>
<p>If 1 &lt;= NrFi &lt;= <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> [see above] the return value is about the component NrFi, while if NrFi &gt; <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> then the return value is about the aggregated function. Note that two cases are special:</p>
<ul>
<li>Lipschitz constant of aggregated function is less or equal to the sum of constants of its components;</li>
<li>NrFi == 0 is a special case since norm of b is Lipschitz constant.</li>
</ul>
<p>A standard implementation is given for those oracles which either do not provide constant Lipschitz, or have it not Lipschitz continuous. </p>

<p>Referenced by <a class="el" href="classPrimalDual.html#aea8b2bb271a107761441b7529b31853e">PrimalDual::PrimalDual()</a>.</p>

</div>
</div>
<a class="anchor" id="a8cb2c48818819c88850c6a815440b76f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetLambda </td>
          <td>(</td>
          <td class="paramtype">cLMRow&#160;</td>
          <td class="paramname"><em>Lmbd</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pass to the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> the point where the function <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> has to be evaluated. </p>
<p>The vector Lmbd has to contain the values of all the variables in the new point (but it may be in "sparse" format, see <a class="el" href="classFiOracle.html#add9e2c034a2af960f3a794cad100bb26" title="The &quot;format&quot; of the vector Lambda set by SetLambda() [see above] depends on the argument LamB passed ...">SetLamBase()</a> below). Passing Lmbd == 0 is equivalent to passing an all-zero vector; this is also assumed as default if <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a> has not been called yet.</p>
<p>The <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> object is allowed <em>not</em> to copy the vector pointed by Lmbd in its own memory, but rather to keep a pointer to the original vector and keep working with it until a new Lmbd (possibly == 0) is set. However, the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> object is <em>not</em> allowed to assume that the "old" Lmbd is still valid <em>at the beginning</em> of the call to <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a> where it is changed. This also holds, for obvious reasons, for <a class="el" href="classFiOracle.html#add9e2c034a2af960f3a794cad100bb26" title="The &quot;format&quot; of the vector Lambda set by SetLambda() [see above] depends on the argument LamB passed ...">SetLamBase()</a> [see below].</p>
<p>An implementation is given in the base class for those oracles which only need to store the pointer in the corresponding protected data structure (and remember that it has changed). </p>

</div>
</div>
<a class="anchor" id="add9e2c034a2af960f3a794cad100bb26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetLamBase </td>
          <td>(</td>
          <td class="paramtype">cIndex_Set&#160;</td>
          <td class="paramname"><em>LmbdB</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>LmbdBD</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The "format" of the vector Lambda set by <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a> [see above] depends on the argument LamB passed to <a class="el" href="classFiOracle.html#add9e2c034a2af960f3a794cad100bb26" title="The &quot;format&quot; of the vector Lambda set by SetLambda() [see above] depends on the argument LamB passed ...">SetLamBase()</a>. </p>
<p>If LmbdB == 0, or <a class="el" href="classFiOracle.html#add9e2c034a2af960f3a794cad100bb26" title="The &quot;format&quot; of the vector Lambda set by SetLambda() [see above] depends on the argument LamB passed ...">SetLamBase()</a> is never called, then Lambda is assumed to be in "dense
format", i.e., the <a class="el" href="classFiOracle.html#a9395fc2b1320d4e44be62366feec4e6e" title="Returns the number of variables of the function, i.e., the (maximum) size of the vectors to be passed...">GetNumVar()</a>-vector of the variables. If LmbdB != 0 instead, then Lambda is in "sparse format", i.e., it contains only the nonzero entries* of the vector of variables. There are LmbdBD (&lt;= <a class="el" href="classFiOracle.html#a9395fc2b1320d4e44be62366feec4e6e" title="Returns the number of variables of the function, i.e., the (maximum) size of the vectors to be passed...">GetNumVar()</a>) such entries, their indices being contained in LmbdB; that is, the "real" Lambda[] is </p><pre class="fragment">           / Lambda[ j ]  if exists j &lt; LmbdBD s.t. LmbdB[ j ] = i
</pre><p> Lambda[ i ] = | \ 0 otherwise.</p>
<p>Note that while all variables whose indices are not in LmbdB[] surely have value 0 the converse may not be true, i.e., some of the Lambda[ j ] with j in LmbdB[] may be have value 0. LmbdB[] must be ordered in increasing sense and Inf&lt;Index&gt;()-terminated, i.e. LmbdB[ i ] &lt; LmbdB[ i + 1 ] for 0 &lt;= i &lt; LmbdBD and LmbdB[ LmbdBD ] == Inf&lt;Index&gt;().</p>
<p>Once that a "base" is set with <a class="el" href="classFiOracle.html#add9e2c034a2af960f3a794cad100bb26" title="The &quot;format&quot; of the vector Lambda set by SetLambda() [see above] depends on the argument LamB passed ...">SetLamBase()</a>, all the subsequent calls to <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a> will assume the same format for Lmbd, until the next call to <a class="el" href="classFiOracle.html#add9e2c034a2af960f3a794cad100bb26" title="The &quot;format&quot; of the vector Lambda set by SetLambda() [see above] depends on the argument LamB passed ...">SetLamBase()</a>. This means that if a "sparse" Lambda has to be passed to the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>, then <a class="el" href="classFiOracle.html#add9e2c034a2af960f3a794cad100bb26" title="The &quot;format&quot; of the vector Lambda set by SetLambda() [see above] depends on the argument LamB passed ...">SetLamBase()</a> has to be called <em>before</em> <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a>, for otherwise the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> will assume that Lambda is "dense" (or sparse with a wrong set of nonzeroes) and errors will occur. That is, when <a class="el" href="classFiOracle.html#add9e2c034a2af960f3a794cad100bb26" title="The &quot;format&quot; of the vector Lambda set by SetLambda() [see above] depends on the argument LamB passed ...">SetLamBase()</a> is called the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> is <em>not</em> allowed to assume that the previously set Lambda[] is still valid. However, as for <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a>, the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> is allowed <em>not to copy the vector pointed by LmbdB in its own memory</em>, but rather to keep a pointer to the original vector and keep working with it until a new LmbdB (possibly == 0) is set. As for Lambda[], the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> is <em>not</em> allowed to assume that the previously set LmbdB[] is still valid at the beginning of the call to <a class="el" href="classFiOracle.html#add9e2c034a2af960f3a794cad100bb26" title="The &quot;format&quot; of the vector Lambda set by SetLambda() [see above] depends on the argument LamB passed ...">SetLamBase()</a> where the base is changed. That means that the caller must ensure that it <em>will not change</em> the content of Lambda[] and LmbdB[] before calling <em>any other</em> method of the class but these two; however, it is allowed to change that vectors right before calling <a class="el" href="classFiOracle.html#add9e2c034a2af960f3a794cad100bb26" title="The &quot;format&quot; of the vector Lambda set by SetLambda() [see above] depends on the argument LamB passed ...">SetLamBase()</a> (or <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a> for the sole Lambda[]), i.e., at any time between the last call to another method of the class and a call to this.</p>
<p>An implementation is given in the base class for those oracles which only need to store the pointer (and lenght) in the corresponding protected data structures. </p>

</div>
</div>
<a class="anchor" id="a83893a59c6e60b15233ad9e368198015"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SetPrecision </td>
          <td>(</td>
          <td class="paramtype">HpNum&#160;</td>
          <td class="paramname"><em>Eps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The computation of the function Fi may be a costly task, e.g. </p>
<p>involving the solution of a possibly hard optimization problem, as in the Lagrangian case. Hence, it may not be always possible, or just smart, to compute the value of the function exactly.</p>
<p><a class="el" href="classFiOracle.html#a83893a59c6e60b15233ad9e368198015" title="The computation of the function Fi may be a costly task, e.g. ">SetPrecision()</a> tells the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> that the value of the function is only required with <em>relative</em> precision Eps (&gt;= 0): of course, the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> can always return values with an higher precision. If <a class="el" href="classFiOracle.html#a83893a59c6e60b15233ad9e368198015" title="The computation of the function Fi may be a costly task, e.g. ">SetPrecision()</a> is not called, 0 (that is, the best precision that the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> is capable of providing anyway) is assumed.</p>
<p>The return value of <a class="el" href="classFiOracle.html#a83893a59c6e60b15233ad9e368198015" title="The computation of the function Fi may be a costly task, e.g. ">SetPrecision()</a> tells the NDO solver whether or not the new required precision "changes the life" to the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>. A call to SetPrecision( Eps ) is equivalent to the question "Were you, the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>, giving me values affected by an absolute error larger than Eps? And, in this case, are you capable of providing me new values with a relative error smaller than Eps?".</p>
<p>Thus, the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> should return false if</p>
<ul>
<li>either it was already providing values with precision at least Eps;</li>
<li>or it was providing values less accurate than that, but this is just all that it can do: its "precision" in computing Fi cannot be taken down to the required value.</li>
</ul>
<p>A return value of false, therefore, informs the NDO solver that if more accurate values than those previously provided are necessary for continuing the optimization process, then it should be stopped because such values are not available. A return value of true, instead, tells that it is perhaps possible to produce more accurate values. In this case, the NDO solver can call again <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> [see below] <em>without</em> changing the point to retrieve the (hopefully) more accurate values; also, it can ask the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> for more (epsilon)-subgradients at the current point, even if it had previously declared that it had had enough [see <a class="el" href="classFiOracle.html#aec7d643acc6b898fe0cd91b8dd042d0f" title="This method must be called to ask the FiOracle whether it can produce a &quot;new&quot; item corresponding to t...">NewGi()</a> below]. However, the NDO solver is <em>not obliged</em> to verify the claim of the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>, that is it can avoid to ask for the values/subgradients in the current point.</p>
<p>Furthermore, note that a return value of true does not mean that the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> <em>must</em> be capable of returning more accurate values: it just means that it is <em>possible</em>. Thus, a <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> receiving a call to <a class="el" href="classFiOracle.html#a83893a59c6e60b15233ad9e368198015" title="The computation of the function Fi may be a costly task, e.g. ">SetPrecision()</a> <em>should not</em> try to calculate Fi with the higher precision (unless this is very inexpensive) and then answer true/false depending on the outcome: if there is a possibility, it should simply answer true and wait for the next move from the NDO solver. The reason is that the NDO solver may not ask for the values that the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> has computed, hence all that work may simply be wasted.</p>
<p>A final remark about the concept of "precision": there are actually two different ways in which a <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> can return "approximate" information about the function Fi when it is not capable of computing it exactly.</p>
<ul>
<li>The first case is when the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> cannot compute the real value of Fi, but it is capable of providing a vector that would be a 0-subgradient if the value were the one returned. The typical case it that of a Lagrangian function where the Lagrangian subproblem is not solved to optimality, but the suboptimal solution is treated as if it were optimal. In this case, a higher accuracy means that better solutions of the Lagrangian problem must be obtained, actually providing a different (higher) value of the function Fi in the same point (and, of course, new subgradients).</li>
<li>The second case is when the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> is capable of computing the real value of Fi, or a conveniently tight approximation, but it is not capable of providing any 0-subgradient corresponding to that value. An example is, again in the Lagrangian case, if a relaxation of the Lagrangian problem is solved to compute a (tight) upper bound on the value of Fi, but no feasible solution of the Lagrangian problem (x  X) can be found that attains such a value, and therefore no 0-subgradient is available. In this case, a higher accuracy does not change the returned value of Fi, but rather obtains epsilon-subgradients with smaller epsilons.</li>
</ul>
<p>These two cases have different meanings in practice: for instance, in the first case the value of Fi is not a valid upper bound on the optimal objective function value of (D), while in the second it is. Of course, NDO algorithms that need "exact" subgradients do not work in the second case, but apart from that here is usually no need to distinguish among the two outside the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>. </p>

</div>
</div>
<a class="anchor" id="aa90312f57c5be3fb8435a1f394c29533"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HpNum Fi </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>wFi</em> = <code>Inf&lt;&#160;Index&#160;&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method must return the value of the function Fi to be minimized in the point Lmbd set by <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a> and <a class="el" href="classFiOracle.html#add9e2c034a2af960f3a794cad100bb26" title="The &quot;format&quot; of the vector Lambda set by SetLambda() [see above] depends on the argument LamB passed ...">SetLamBase()</a> [see above]. </p>
<p>Usually, <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> has to be called <em>after</em> <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a>, the only exception being if Fi( &lt; all-zero vector &gt; ) is required, since Lambda == all-zero is the default assumed if <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a> is not called.</p>
<p>wFi tells the value of which of the components of <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> [see <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> above] has to be returned. Note that all functions, even those that are declared non-separable (<a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> == 1), are treated as the sum of a generic function Fi[ 1 ]( Lambda ) plus a linear function b * Lambda; this is always possible (b can be == 0). The meaning of wFi is:</p>
<ul>
<li>wFi == 0 requires the value of the linear (affine) 0-th component of Fi.</li>
<li>1 &lt;= wFi &lt;= <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> requires the value of the wFi-th component of Fi, which must not be an "easy" one [see <a class="el" href="group__EasyComp.html#gad5a82019520f11aeeed9501d044e5ee3" title="Returns the number of variables of the &quot;easy&quot; linear problem which describes Fi[ wFi ]...">GetBNC()</a> etc. above];</li>
<li>Inf&lt;Index&gt;() &gt; wFi &gt; <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> requires the value of the full function Fi except that of the "easy" components [see <a class="el" href="group__EasyComp.html#gad5a82019520f11aeeed9501d044e5ee3" title="Returns the number of variables of the &quot;easy&quot; linear problem which describes Fi[ wFi ]...">GetBNC()</a> etc. above] and of the linear part, i.e. Sum{h = 1 .. <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a>, h not easy} Fi( h ).</li>
<li>wFi == Inf&lt;Index&gt;() requires the value of the full function Fi except that of the "easy" components (...).</li>
</ul>
<p>In case an error occurs in the calculation of <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a>, this can be signalled immediately by returning - INF (a proper convex function never evaluates to - Infinity); if a "decent" value is available, an alternative is to use <a class="el" href="classFiOracle.html#aad5c05cf616d9205ee6d83ecbc9fafc5" title="GetFiStatus() returns the internal status of the FiOracle object. ">GetFiStatus()</a> [see below]. Note that an important special case exists when it may be reasonable for a <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> to return - INF; this is when (one component of) <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> is <em>not</em> a proper convex function, that is, it is identically equal to - Infinity*. In the Lagrangian case, this corresponds to the fact that (one of) the Lagrangian problem(s) actually is <em>empty</em>. It is for this reason that if <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> returns - INF, then the NDO solver has the right to declare <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> unbounded below.</p>
<p><a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> may also return + INF, meaning that the point set by <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a> is outside the feasible region (the domain of the function to be minimized). In this case, the information returned by <a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a> [see below] has a different meaning. However, note that, when Fi is separable, only some of its components may be undefined, while other may still give valid subgradients; in other words, the point set by <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a> may belong to Dom( Fi[ h ] ) for some h, and not for others. Thus, as for subgradients, when a constraint is generated the value of wFi in the call to <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> which returned INF allows the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> to distinguish to which component the constraint belongs to.</p>
<p>Usually, there will be only one call to <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> (for each component) for each call to <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a>; however, multiple calls are allowed if the "precision" changes [see <a class="el" href="classFiOracle.html#a83893a59c6e60b15233ad9e368198015" title="The computation of the function Fi may be a costly task, e.g. ">SetPrecision()</a> above]. </p>

</div>
</div>
<a class="anchor" id="aec7d643acc6b898fe0cd91b8dd042d0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool NewGi </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>wFi</em> = <code>Inf&lt;Index&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method must be called to ask the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> whether it can produce a "new" item corresponding to the point Lambda set by <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a> and <a class="el" href="classFiOracle.html#add9e2c034a2af960f3a794cad100bb26" title="The &quot;format&quot; of the vector Lambda set by SetLambda() [see above] depends on the argument LamB passed ...">SetLamBase()</a> [see above]. </p>
<p>The method can anly be called <em>after</em> that <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> (and, therefore, <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a>) has been called.</p>
<p>wFi tells to which of the components of <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> [see <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> above] the item should correspond. More precisely, if Fi( wFi ) &lt; INF,</p>
<ul>
<li>1 &lt;= wFi &lt;= <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> asks for an (epsilon-)subgradient of Fi[ wFi ], the wFi-th component of Fi, which must not be an "easy" one [see <a class="el" href="group__EasyComp.html#gad5a82019520f11aeeed9501d044e5ee3" title="Returns the number of variables of the &quot;easy&quot; linear problem which describes Fi[ wFi ]...">GetBNC()</a> etc. above];</li>
<li>Inf&lt;Index&gt;() &gt; wFi &gt; <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> asks for an aggregated (epsilon-)subgradient excluding the constant part and all the easy components, i.e., the sum of all the things that would be reported by calls with wFi going from 1 to <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> and avoiding the easy components;</li>
<li>wFi == Inf&lt;Index&gt;() requires the aggregated (epsilon-)subgradient of (the not-easy part of) Fi.</li>
</ul>
<p>If Fi( wFi ) == INF, what is required is rather a linear constraint separating Lmbd from the domain of Fi[ wFi ]. The method must return true if a such new item could be produced, and false otherwise. Note that in this case wFi == 0 <em>does</em> make sense, as "global" constraints are associated with the 0-th component.</p>
<dl class="section note"><dt>Note</dt><dd><em>Important</em>: in general, any oracle should be able to provide on e new item for <em>at least</em> one of the components of <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> for each point Lambda. Many NDO solvers actually require that the oracle is capable to provide a new item for <em>all</em> the components for each point Lambda.</dd>
<dd>
The NDO solver may, in principle, require a new "aggregated" subgradient (e.g. by a call NewGi( Inf&lt;Index&gt;() )) after having required some set, possibly not "covering" all the (not-easy) components of <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a>, of "disaggregated" ones. In this case, the intended behavior is that <a class="el" href="classFiOracle.html#aec7d643acc6b898fe0cd91b8dd042d0f" title="This method must be called to ask the FiOracle whether it can produce a &quot;new&quot; item corresponding to t...">NewGi()</a> should return true only if a new subgradient can be obtained for <em>all</em> components of <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a>, comprised those that already have produced some "disaggregated" one, so that an <em>entirely new</em> aggregated subgradient can be produced. The rationale is that if the NDO solver wants to produce an aggregated subgradient out of partly old and partly new information, it can do this by requiring new subgradients to some components individually and then "mix" it with those already obtained for other components.</dd></dl>
<p>Typically, when NewGi( wFi ) returns false, it will keep doing so until <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a> is called; however, new items could also be produced after a call to <a class="el" href="classFiOracle.html#a83893a59c6e60b15233ad9e368198015" title="The computation of the function Fi may be a costly task, e.g. ">SetPrecision()</a> [see above] which returns true.</p>
<p>An implementation is given in the base class for those oracles which can only provide a single subgradient for each different value of Lambda[]; note that LHasChgd has to be set to false in <a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a> [see below]*. </p>

</div>
</div>
<a class="anchor" id="a4bc17c68285be9171d126705efb15cdd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Index GetGi </td>
          <td>(</td>
          <td class="paramtype">SgRow&#160;</td>
          <td class="paramname"><em>SubG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cIndex_Set &amp;&#160;</td>
          <td class="paramname"><em>SGBse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>Name</em> = <code>Inf&lt;&#160;Index&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;&#160;Index&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a> [and <a class="el" href="classFiOracle.html#adf35d71a3d63ba31c64910bdbe650864" title="GetVal() [and GetGi(), see above] can be used to query information about the items. ">GetVal()</a>, see below] can be used to query information about the items. </p>
<p>The method allows to access both the newly produced item corresponding to the last call to <a class="el" href="classFiOracle.html#aec7d643acc6b898fe0cd91b8dd042d0f" title="This method must be called to ask the FiOracle whether it can produce a &quot;new&quot; item corresponding to t...">NewGi()</a> [see above], if it has not been "named" yet [see <a class="el" href="classFiOracle.html#a2e53e0ca809a3be0075a6b8d53fd3b07" title="After that a new item has been produced, i.e., a call to NewGi() returned true, and that (possibly) G...">SetGiName()</a> below], and all "named" items recorded in the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> memory, if any [see <a class="el" href="classFiOracle.html#a8a848c4b8e474ab60be98c6acca48ccf" title="In some cases, an optimal solution of the dual problem (D) [see the general notes] is a mostly welcom...">SetMaxName()</a> above]. This is specified by the value of Name. If Name &lt; n, where n is the max name set by the latest call to <a class="el" href="classFiOracle.html#a8a848c4b8e474ab60be98c6acca48ccf" title="In some cases, an optimal solution of the dual problem (D) [see the general notes] is a mostly welcom...">SetMaxName()</a>, then the required information is about the item Name. Note that Name must be a valid item name, i.e., a name that has been previously used in some call to <a class="el" href="classFiOracle.html#a2e53e0ca809a3be0075a6b8d53fd3b07" title="After that a new item has been produced, i.e., a call to NewGi() returned true, and that (possibly) G...">SetGiName()</a>, and not used in any call to <a class="el" href="classFiOracle.html#aa80f5c831464c830e75d9a86c18eb1e3" title="If so instructed by SetMaxName() [see above], the FiOracle should keep &quot;dual&quot; information attached to...">Deleted()</a> after the last call of <a class="el" href="classFiOracle.html#a2e53e0ca809a3be0075a6b8d53fd3b07" title="After that a new item has been produced, i.e., a call to NewGi() returned true, and that (possibly) G...">SetGiName()</a> where it was used. If Name == n, then the required information is about the constant subgradient of the linear 0-th component of Fi. Finally, if Name &gt; n then the required information is about the newly produced "unnamed" item. Note that, given Name, it is immediately known to which component of Fi the associated item belongs.</p>
<p><a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a> can be used to retrieve (part of) the linear <a class="el" href="classFiOracle.html#a9395fc2b1320d4e44be62366feec4e6e" title="Returns the number of variables of the function, i.e., the (maximum) size of the vectors to be passed...">GetNumVar()</a>-vector which carachterizes the item. SubG is a pointer to a vector of SgNum of appropriate lenght (see below) where the item have to be written. The indices strt and stp tell that what is required is the part of the vector corresponding to variables with "names" comprised between strt (included) and min{ stp , <a class="el" href="classFiOracle.html#a9395fc2b1320d4e44be62366feec4e6e" title="Returns the number of variables of the function, i.e., the (maximum) size of the vectors to be passed...">GetNumVar()</a> } (excluded); the name of a variable is just its position in the vector Lmbd. Upon return, the required information has to be written in SubG; the "format" of SubG depends on what is returned in the read-only pointer SGBse. If SGBse == 0, then SubG[] is in "dense" format, i.e., SubG[ i ] is the entry of the subgradient relative to variable strt + i for i in 0 .. min( GetNumVar() , stp ) - strt. If SGBse != 0, then it must point to the vector of indices of nonzero entries of the subgradient (ordered in increasing sense and Inf&lt;Index&gt;()-terminated). That is, for i = strt ... stp - 1, the "real" SubG is </p><pre class="fragment">            / SubG[ j ]    if exists j &lt; k s.t. SGBse[ j ] = i
</pre><p> SubG[ i ] = | \ 0 otherwise.</p>
<p>where k, the number of nonzeroes of SubG[], is returned by <a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a>. If SGBse == 0, then <a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a> should return min{ stp , <a class="el" href="classFiOracle.html#a9395fc2b1320d4e44be62366feec4e6e" title="Returns the number of variables of the function, i.e., the (maximum) size of the vectors to be passed...">GetNumVar()</a> } - strt, i.e., the lenght of the "dense" SubG[]. Note that, if SGBse != 0, the Indices in SGBse[] are in the range [strt, min{ stp , <a class="el" href="classFiOracle.html#a9395fc2b1320d4e44be62366feec4e6e" title="Returns the number of variables of the function, i.e., the (maximum) size of the vectors to be passed...">GetNumVar()</a> }).</p>
<p>According to whether the item is a subgradient or a constraint (which is revealed by the return value of <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a>), GetMaxNZ( wFi ) and GetMaxCNZ( wFi ) [see above] provide an upper bound on the maximum number of nonzeroes in the item; let us denote that by MxNZ. Then, the lenght of the vector SubG is required to be at least</p>
<p>min( MxNZ , min( GetNumVar() , stp ) - strt ) ,</p>
<p>i.e., the minimum possible amount that is guaranteed to contain all the possible nonzeroes. Hence, a non-0 SGBDim <em>must</em> always be returned if MxNZ &lt; min( GetNumVar() , stp ) - strt ), as in this case the vector SubG is <em>not</em> long enough to accommodate (the required part of) an item in "dense" format. Also, note that the memory for SGBase has to be provided by the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>, but the NDO solver is not allowed to keep the pointer and must copy the vector, if it so requires, because the content may change at the subsequent call to any method of the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>.</p>
<p>Allowing a NDO solver to query information about items "stored" in the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> [see <a class="el" href="classFiOracle.html#a2e53e0ca809a3be0075a6b8d53fd3b07" title="After that a new item has been produced, i.e., a call to NewGi() returned true, and that (possibly) G...">SetGiName()</a> below] has different uses. For instance, the NDO solver may use variables generation techniques which try to solve a NDO problem by restricting it to a (small) "active set" of the variables, minimizing the function in that subspace and possibly revising the active set. Thus, at some point the NDO solver may not need some of the information related to an item, but this information may still be required later. A possibly more important use, however, is tied to the handling of changes in the function, which may occur in applications as those alluded to in the general notes. The implementation of the methods AddVariables() and ChgSbG() of <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> [see <a class="el" href="NDOSlver_8h.html" title="Definition of the abstract base class NDOSolver, which defines the interface for convex minimization ...">NDOSlver.h</a>] typically require calls to <a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a> to get information about some components of the items "stored" in the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>. Note that these methods of class <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a>, in turn, can be called <em>by the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a></em> itself, e.g. in the method <a class="el" href="classFiOracle.html#aad5c05cf616d9205ee6d83ecbc9fafc5" title="GetFiStatus() returns the internal status of the FiOracle object. ">GetFiStatus()</a> [see below], so that the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> may well be "prepared" when a call occurs simply because the caller was, ultimately, itself. </p>

</div>
</div>
<a class="anchor" id="adf35d71a3d63ba31c64910bdbe650864"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HpNum GetVal </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>Name</em> = <code>Inf&lt;Index&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classFiOracle.html#adf35d71a3d63ba31c64910bdbe650864" title="GetVal() [and GetGi(), see above] can be used to query information about the items. ">GetVal()</a> [and <a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a>, see above] can be used to query information about the items. </p>
<p>The method allows to access both the newly produced item corresponding to the last call to <a class="el" href="classFiOracle.html#aec7d643acc6b898fe0cd91b8dd042d0f" title="This method must be called to ask the FiOracle whether it can produce a &quot;new&quot; item corresponding to t...">NewGi()</a> [see above], if it has not been "named" yet [see <a class="el" href="classFiOracle.html#a2e53e0ca809a3be0075a6b8d53fd3b07" title="After that a new item has been produced, i.e., a call to NewGi() returned true, and that (possibly) G...">SetGiName()</a> below], and all "named" items recorded in the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> memory, if any [see <a class="el" href="classFiOracle.html#a8a848c4b8e474ab60be98c6acca48ccf" title="In some cases, an optimal solution of the dual problem (D) [see the general notes] is a mostly welcom...">SetMaxName()</a> above]. This is specified by the value of Name. If Name &lt; n, where n is the max name set by the latest call to <a class="el" href="classFiOracle.html#a8a848c4b8e474ab60be98c6acca48ccf" title="In some cases, an optimal solution of the dual problem (D) [see the general notes] is a mostly welcom...">SetMaxName()</a>, then the required information is about the item Name. Note that Name must be a valid item name, i.e., a name that has been previously used in some call to <a class="el" href="classFiOracle.html#a2e53e0ca809a3be0075a6b8d53fd3b07" title="After that a new item has been produced, i.e., a call to NewGi() returned true, and that (possibly) G...">SetGiName()</a>, and not used in any call to <a class="el" href="classFiOracle.html#aa80f5c831464c830e75d9a86c18eb1e3" title="If so instructed by SetMaxName() [see above], the FiOracle should keep &quot;dual&quot; information attached to...">Deleted()</a> after the last call of <a class="el" href="classFiOracle.html#a2e53e0ca809a3be0075a6b8d53fd3b07" title="After that a new item has been produced, i.e., a call to NewGi() returned true, and that (possibly) G...">SetGiName()</a> where it was used. If Name == n, then the required information is about the constant subgradient of the linear 0-th component of Fi. Finally, if Name &gt; n then the required information is about the newly produced "unnamed" item. Note that, given Name, it is immediately known to which component of Fi the associated item belongs.</p>
<p>The meaning of the value returned by GetVal( Name ) is different if Name indicates a subgradient or a linear constraint.</p>
<p>If Name indicates a constraint, then it is</p>
<p>SubG * Lambda &lt;= GetVal( Name ),</p>
<p>i.e., <a class="el" href="classFiOracle.html#adf35d71a3d63ba31c64910bdbe650864" title="GetVal() [and GetGi(), see above] can be used to query information about the items. ">GetVal()</a> returns its right hand side.</p>
<p>If Name indicates an epsilon-subgradient, then <a class="el" href="classFiOracle.html#adf35d71a3d63ba31c64910bdbe650864" title="GetVal() [and GetGi(), see above] can be used to query information about the items. ">GetVal()</a> returns the value of the corresponding linearization of Fi in Lambda, that is, the smallest (known) value epsilon &gt;= 0 such that the item Name is an epsilon-subgradient of the wFi-th component of Fi. In the Lagrangian case, if x is the dual solution corresponding to the epsilon-subgradient Name, it is</p>
<p>epsilon = c[ wFi ]( x ) - Lambda * A[ wFi ]( x ) - Fi[ wFi ]()</p>
<p>i.e., how much "suboptimal" is the dual solution x for the wFi-th Lagrangian problem (x[ i ] is epsilon-optimal). A special case is when Name == n, i.e., the unique (sub)gradient of the linear 0-th component of Fi is queried; in this case, <a class="el" href="classFiOracle.html#adf35d71a3d63ba31c64910bdbe650864" title="GetVal() [and GetGi(), see above] can be used to query information about the items. ">GetVal()</a> returns the constant `b0'.</p>
<dl class="section note"><dt>Note</dt><dd>When querying the "new" item (Name &gt; n), both <a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a> and <a class="el" href="classFiOracle.html#adf35d71a3d63ba31c64910bdbe650864" title="GetVal() [and GetGi(), see above] can be used to query information about the items. ">GetVal()</a> must be called. Although in principle any order of the two calls would be possible, we require that <a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a> is always called (for the "new" item) <em>before</em> <a class="el" href="classFiOracle.html#adf35d71a3d63ba31c64910bdbe650864" title="GetVal() [and GetGi(), see above] can be used to query information about the items. ">GetVal()</a>; this may be convenient for the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>, so that, say, it knows without checking that some data structures have been already initialized.</dd></dl>
<p>Allowing a NDO solver to query information about items "stored" in the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> [see <a class="el" href="classFiOracle.html#a2e53e0ca809a3be0075a6b8d53fd3b07" title="After that a new item has been produced, i.e., a call to NewGi() returned true, and that (possibly) G...">SetGiName()</a> below] is fundamental for the handling of changes in the function, which may occur in applications as those alluded to in the general notes. The implementation of the method ChgFiV() of <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> [see <a class="el" href="NDOSlver_8h.html" title="Definition of the abstract base class NDOSolver, which defines the interface for convex minimization ...">NDOSlver.h</a>] typically requires calls to <a class="el" href="classFiOracle.html#adf35d71a3d63ba31c64910bdbe650864" title="GetVal() [and GetGi(), see above] can be used to query information about the items. ">GetVal()</a> to get the new Fi-values/right hand sides for subgradients/constraints "stored" in the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>. Note that, in this case, the special return value - INF for GetVal( Name ) tells that the item `Name' is no longer a valid one for the new function. Note that that method of class <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a>, in turn, can be called <em>by the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a></em> itself, e.g. in the method <a class="el" href="classFiOracle.html#aad5c05cf616d9205ee6d83ecbc9fafc5" title="GetFiStatus() returns the internal status of the FiOracle object. ">GetFiStatus()</a> [see below], so that the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> may well be "prepared" when a call occurs simply because the caller was, ultimately, itself.</p>
<p>An implementation is given in the base class for those oracles which only return "exact" subgradients and no constraints, and do not store past solutions. </p>

</div>
</div>
<a class="anchor" id="a2e53e0ca809a3be0075a6b8d53fd3b07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetGiName </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>Name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>After that a new item has been produced, i.e., a call to <a class="el" href="classFiOracle.html#aec7d643acc6b898fe0cd91b8dd042d0f" title="This method must be called to ask the FiOracle whether it can produce a &quot;new&quot; item corresponding to t...">NewGi()</a> returned true, and that (possibly) <a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a> / <a class="el" href="classFiOracle.html#adf35d71a3d63ba31c64910bdbe650864" title="GetVal() [and GetGi(), see above] can be used to query information about the items. ">GetVal()</a> have been used to retrieve information about it, the NDO solver can use <a class="el" href="classFiOracle.html#a2e53e0ca809a3be0075a6b8d53fd3b07" title="After that a new item has been produced, i.e., a call to NewGi() returned true, and that (possibly) G...">SetGiName()</a> to tell the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> that a "name" has been assigned to that new item by NDO solver. </p>
<p>This name can be used later in <a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a> and <a class="el" href="classFiOracle.html#adf35d71a3d63ba31c64910bdbe650864" title="GetVal() [and GetGi(), see above] can be used to query information about the items. ">GetVal()</a> to query information about the item - typically, information that was not obtained with the first call to <a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a> / <a class="el" href="classFiOracle.html#adf35d71a3d63ba31c64910bdbe650864" title="GetVal() [and GetGi(), see above] can be used to query information about the items. ">GetVal()</a> because the function has changed in the meantime. The name can also be used to identify the "dual" solution x / extreme ray associated to that item [see <a class="el" href="classFiOracle.html#a8a848c4b8e474ab60be98c6acca48ccf" title="In some cases, an optimal solution of the dual problem (D) [see the general notes] is a mostly welcom...">SetMaxName()</a> above] in order to construct a dual solution x  conv( X ). If <a class="el" href="classFiOracle.html#a2e53e0ca809a3be0075a6b8d53fd3b07" title="After that a new item has been produced, i.e., a call to NewGi() returned true, and that (possibly) G...">SetGiName()</a> is <em>not</em> called, the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> is authorized to "dump" the corresponding dual information, as this means that the item is not "interesting" for the NDO solver (exception to that is the constant subgradient of the linear 0-th component of Fi, which is not given a name but still the corresponding - unique - dual information may be needed).</p>
<p>Note that the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> can in principle disregard the "commands" issued by <a class="el" href="classFiOracle.html#a2e53e0ca809a3be0075a6b8d53fd3b07" title="After that a new item has been produced, i.e., a call to NewGi() returned true, and that (possibly) G...">SetGiName()</a>, for instance because it knows that no "dual" information will ever be required. In fact, this method is given a default implementation that does nothing.</p>
<p>It is possible that <a class="el" href="classFiOracle.html#a2e53e0ca809a3be0075a6b8d53fd3b07" title="After that a new item has been produced, i.e., a call to NewGi() returned true, and that (possibly) G...">SetGiName()</a> is called with a given name more than once even if the item has not been explicitly declared as unused [see <a class="el" href="classFiOracle.html#aa80f5c831464c830e75d9a86c18eb1e3" title="If so instructed by SetMaxName() [see above], the FiOracle should keep &quot;dual&quot; information attached to...">Deleted()</a> below]. When a name of an already existing item is re-used in <a class="el" href="classFiOracle.html#a2e53e0ca809a3be0075a6b8d53fd3b07" title="After that a new item has been produced, i.e., a call to NewGi() returned true, and that (possibly) G...">SetGiName()</a>, the dual information corresponding to the old item with that name must just be replaced with the dual information corresponding to the new item.</p>
<p>Note that, in the decomposable Lagrangian case, the choice of wFi in <a class="el" href="classFiOracle.html#aec7d643acc6b898fe0cd91b8dd042d0f" title="This method must be called to ask the FiOracle whether it can produce a &quot;new&quot; item corresponding to t...">NewGi()</a> influences how the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> has to treat the dual information associated to the items. In fact, a decomposable Fi corresponds to a feasible set X which is the cartesian product of <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> disjoint sets X[ h ], each being the feasible set of an independent Lagrangian problem, plus component-separable objective function</p>
<p>c( x ) = { i = 1 .. <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> } c[ i ]( x[ i ] )</p>
<p>and constraints</p>
<p>A( x ) = { i = 1 .. <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> } A[ i ]( x[ i ] )</p>
<p>Hence, Fi( Lmbd ) &lt; INF means that a dual solution x = [ x[ 1 ] .. x[ <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> ] ] is available where each x[ i ] is a (epsilon[ i ]-)optimal solution of the i-th Lagrangian subproblem. Hence, if <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> separate calls to <a class="el" href="classFiOracle.html#aec7d643acc6b898fe0cd91b8dd042d0f" title="This method must be called to ask the FiOracle whether it can produce a &quot;new&quot; item corresponding to t...">NewGi()</a> are issued, then each x[ i ] is used to produce an (epsilon[ i ]-)subgradient for its component, so that each x[ i ] will receive a different name. If wFi &gt; <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> instead, x will be considered as a unique dual object with an unique name. Analogously, a constraint for the h-th component of Fi corresponds to an unbounded ray for the feasible set X[ h ] of the h-th Lagrangian problem. Thus, if unbounded rays are generated for some components after a call to <a class="el" href="classFiOracle.html#aec7d643acc6b898fe0cd91b8dd042d0f" title="This method must be called to ask the FiOracle whether it can produce a &quot;new&quot; item corresponding to t...">NewGi()</a> with wFi &gt; <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a>, they will have to be considered as an unique unbounded ray for the whole X (this is always possible by padding the non-unbounded components with zeroes), while the same information will be considered as separate unbounded rays if separate calls to <a class="el" href="classFiOracle.html#aec7d643acc6b898fe0cd91b8dd042d0f" title="This method must be called to ask the FiOracle whether it can produce a &quot;new&quot; item corresponding to t...">NewGi()</a> are issued. Hence, with wFi </p><blockquote class="doxtable">
<p><a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> it may well happen that the constraint is in fact associated to </p>
</blockquote>
<p>just one of the components, but the caller just does not want to know which component this is. This is reasonable, since Fi (as a whole) is +Infinity whenever at least one of its components is; in other words, the domain of Fi is the intersection of the domains of all its components. Thus, although in fact attached to components, the constraints can be thought to be "global", as a feasible point Lmbd must satisfy all the constraints corresponding to all the components. </p>

</div>
</div>
<a class="anchor" id="acd48c1da81bbd115bd8e41e4abc8f936"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HpNum GetLowerBound </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>wFi</em> = <code>Inf&lt;Index&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In some cases, a Lower Bound on the minimal value of Fi is known; if Fi is a Lagrangian function, for instance, the objective function value c( x ) of any dual feasible solution x (s.t. </p>
<p>A( x ) [&lt;]= b and x  X) gives a valid lower bound. This value can be useful for NDO solver, especially if it is tight; for one thing, it ensures that the function is not unbounded below.</p>
<p><a class="el" href="classFiOracle.html#acd48c1da81bbd115bd8e41e4abc8f936" title="In some cases, a Lower Bound on the minimal value of Fi is known; if Fi is a Lagrangian function...">GetLowerBound()</a> allows to retrieve this value from the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>, which may return - INF to signal that no Lower Bound is known. Note that the value may change&mdash;typically, increase&mdash;over time, e.g. as better feasible solutions of the dual problem are generated, so that it may be worth to call <a class="el" href="classFiOracle.html#acd48c1da81bbd115bd8e41e4abc8f936" title="In some cases, a Lower Bound on the minimal value of Fi is known; if Fi is a Lagrangian function...">GetLowerBound()</a> after each call to <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> to check if a better bound has become available. Of course, the value returned by <a class="el" href="classFiOracle.html#acd48c1da81bbd115bd8e41e4abc8f936" title="In some cases, a Lower Bound on the minimal value of Fi is known; if Fi is a Lagrangian function...">GetLowerBound()</a> must be no smaller than that returned by <a class="el" href="classFiOracle.html#a5deec7bb1a3f6dd38e937b1d10e302df" title="The function Fi to be minimized may be unbounded below, i.e., its infimum may be - INF...">GetMinusInfinity()</a> [see above], altough the two can be equal.</p>
<p>Furthermore, changes in <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> (number of variables etc.) may possibly render any previously obtained Lower Bound invalid, so that this method should be called <em>at least</em> each time <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> changes; failure to do that could lead to early and incorrect termination of the optimization due to the use of an incorrect Lower Bound.</p>
<p>Lower Bounds may be available separatedly for the wFi-th component of Fi, 1 &lt;= wFi &lt;= <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a>; these are returned by GetLowerBound( wFi ). Note that if wFi is an "easy" component then it makes no sense to provide an explicit lower bound, since everything is known for that component and the Lower Bound, if any, is already implicit in the description; thus, GetLowerBound( wFi ) should always return - INF if wFi is "easy". GetLowerBound( 0 ) also makes no sense (i.e., - INF is again a good return value) while GetLowerBound( wFi ) for wFi &gt; NrFi must return a "global" Lower Bound for the whole Fi.</p>
<dl class="section note"><dt>Note</dt><dd>While "individual" Lower Bounds are not allowed for "easy" components, the "global" Lower Bound is to be intended as a bound on the <em>total</em> value of <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a>, that is, comprised the value of the "easy" components.</dd>
<dd>
The existence of a "global" Lower Bound does not imply the existence of "individual" Lower Bounds; consider the case of the 0-th linear component of Fi, which has no Lower Bound unless the domain of Fi is compact. Vice-versa, "individual" Lower Bounds imply a "global" one only if <em>every</em> component has one <em>comprised</em> the 0-th (i.e., the 0-th component is bounded on the domain, e.g. it is null or the domain is bounded). </dd></dl>

<p>Referenced by <a class="el" href="classColorTV.html#a4539b98684e6ddcb4395b034a8de0b38">ColorTV::ColorTV()</a>, and <a class="el" href="classFumeroTV.html#af079651b58c35f1a05d899b9d452e133">FumeroTV::FumeroTV()</a>.</p>

</div>
</div>
<a class="anchor" id="aad5c05cf616d9205ee6d83ecbc9fafc5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classFiOracle.html#a04867eec1c7917816fb94b85c12ba6db">FiStatus</a> GetFiStatus </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>wFi</em> = <code>Inf&lt;Index&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classFiOracle.html#aad5c05cf616d9205ee6d83ecbc9fafc5" title="GetFiStatus() returns the internal status of the FiOracle object. ">GetFiStatus()</a> returns the internal status of the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> object. </p>
<p>There are <em>two</em> envisioned uses for this method:</p>
<ul>
<li>The first is as a "hook" for the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> into the main loop of the NDO algorithm. That is, the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> can expect the NDO algorithm to call <a class="el" href="classFiOracle.html#aad5c05cf616d9205ee6d83ecbc9fafc5" title="GetFiStatus() returns the internal status of the FiOracle object. ">GetFiStatus()</a> at least once for each iteration, <em>before</em> checking for termination. This allows the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> to properly react to things happening, e.g. in the case where variables are being dynamically generated (see <a class="el" href="classFiOracle.html#a750898ca2374a3b61b4452034738a20d" title="This method provides the only explicit support  except for the return value `kFiChgd&#39; of GetFiStatu...">GetMaxNumVar()</a> and <a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a> above). A special setting of the wFi parameter is reserved for this use, see below.</li>
<li>The second is as a way for the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> to check whether or not the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> actually has computed the latest function value(s) with "enough precision" according to the current setting of <a class="el" href="classFiOracle.html#a83893a59c6e60b15233ad9e368198015" title="The computation of the function Fi may be a costly task, e.g. ">SetPrecision()</a> [see above].</li>
</ul>
<p>The two uses are told apart by the value of the parameter wFi, and in particular by the fact that wFi &gt; <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> or not. That is, the second usage correspond to the values</p>
<ul>
<li>wFi == 0 requires the status of the full function Fi except that of the "easy" components [see <a class="el" href="group__EasyComp.html#gad5a82019520f11aeeed9501d044e5ee3" title="Returns the number of variables of the &quot;easy&quot; linear problem which describes Fi[ wFi ]...">GetBNC()</a> etc. above]; this will return kFiNorm [see below] if all individual components return kFiNorm, kFiStop [see below] if at least one component returns kFiStop and none returns kFiError [see below], kFiError if any component returns kFiError; note that kFiChgd and kFiCont are not allowed as return values.</li>
<li>1 &lt;= wFi &lt;= <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> requires the status of Fi[ wFi ], which can be kFiNorm, kFiStop or kFiError, but not kFiChgd and kFiCont.</li>
</ul>
<p>Conversely, the first usage corresponds to any value wFi &gt; <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a>. This is analogous to wFi == 0, except that kFiChgd and kFiCont can be returned. This means that the function is not supposed to change during calls to <a class="el" href="classFiOracle.html#aad5c05cf616d9205ee6d83ecbc9fafc5" title="GetFiStatus() returns the internal status of the FiOracle object. ">GetFiStatus()</a> with wFi &lt;= <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a>, while it is allowed to during calls to <a class="el" href="classFiOracle.html#aad5c05cf616d9205ee6d83ecbc9fafc5" title="GetFiStatus() returns the internal status of the FiOracle object. ">GetFiStatus()</a> with wFi &gt; <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a>. A more detailed discussion of the meaning of the return status follows:</p>
<p>kFiNorm Everything is normal, the function (this particular component) has been correctly computed with the precision required by <a class="el" href="classFiOracle.html#a83893a59c6e60b15233ad9e368198015" title="The computation of the function Fi may be a costly task, e.g. ">SetPrecision()</a>.</p>
<p>kFiError There have been some problem in the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> that require to stop the optimization (the next results from the oracle may not be correct).</p>
<p>kFiStop The meaning of this return value is somwhow different for wFi &lt;= <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> and wFi &gt; <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a>. In the former case, it just means that the oracle is not sure to have computed the function value and/or subgradients "accurately enough", as required by the parameters set by the latest call to <a class="el" href="classFiOracle.html#a83893a59c6e60b15233ad9e368198015" title="The computation of the function Fi may be a costly task, e.g. ">SetPrecision()</a>; whether or not this is a problem depends on the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a>, since it may just choose to either ignore this, or call again <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a> to "give the FiOracle some more
 time to finish the job". When wFi &gt; <a class="el" href="classFiOracle.html#ac06d81fcb88d9d630c6e16b0c1bed758" title="GetNrFi() returns the number of independent components of Fi(); 1 is the minimum number, meaning that the function is not decomposable. ">GetNrFi()</a> instead, the return value instructs the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> to stop. This may happen e.g. because the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> has a mean for detecting near-optimality of the point Lmbd but it cannot provide an almost-zero subgradient to directly prove this to the NDO solver. Alternatively, optimization may be stopped because some resources (e.g., computation time) have been depleted, and one must live with the best solution found. Finally, this may just be a request for a "pause" in the optimization process, that may be restarted later; this can be useful if the minimization of Fi is &ndash; as it often happens &ndash; just a part of a more complex process.</p>
<p>kFiChgd Since the last call to <a class="el" href="classFiOracle.html#aad5c05cf616d9205ee6d83ecbc9fafc5" title="GetFiStatus() returns the internal status of the FiOracle object. ">GetFiStatus()</a>, something in the function Fi has changed; thus, the optimization process has to be restarted. Note that for several types of changes a <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> may be able to exploit the information acquired during the (interrupted) optimization of the previous function for "warm-starting" the optimization of the new function; such changes comprise increase and/or decrease of the number of variables [see [Add/Remove]Variables() in <a class="el" href="NDOSlver_8h.html" title="Definition of the abstract base class NDOSolver, which defines the interface for convex minimization ...">NDOSlver.h</a>] and some different kinds of changes in the function Fi, such as those handled by the methods ChgFiV() and ChgSbG() of class <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> [see <a class="el" href="NDOSlver_8h.html" title="Definition of the abstract base class NDOSolver, which defines the interface for convex minimization ...">NDOSlver.h</a>]. Note that <a class="el" href="classFiOracle.html#aad5c05cf616d9205ee6d83ecbc9fafc5" title="GetFiStatus() returns the internal status of the FiOracle object. ">GetFiStatus()</a> actually is one very good point where to <em>call</em> all the abovementioned methods of <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a>. In turn, those methods of <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> may call some other methods of <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> to get information about the changes, such as <a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a> and <a class="el" href="classFiOracle.html#adf35d71a3d63ba31c64910bdbe650864" title="GetVal() [and GetGi(), see above] can be used to query information about the items. ">GetVal()</a>, or Get[A/B]Desc() [see above].</p>
<p>kFiCont As opposed to kFiStop above, the optimization should be carried on even though, based on the current data, the NDO solver would have detected optimality; this is useful if the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> has chosen to hide some data (e.g., some variables) to the NDO solver that is planning to disclose later, but, for some reason, not at the current iteration. Note that this may well cause a NDO solver to cycle, depending on how its the stopping conditions are implemented. If <a class="el" href="classFiOracle.html#aad5c05cf616d9205ee6d83ecbc9fafc5" title="GetFiStatus() returns the internal status of the FiOracle object. ">GetFiStatus()</a> returns kFiCont, the NDO solver should not stop before having called <a class="el" href="classFiOracle.html#aad5c05cf616d9205ee6d83ecbc9fafc5" title="GetFiStatus() returns the internal status of the FiOracle object. ">GetFiStatus()</a> again (e.g., at the subsequent iteration) and having got a different return value.</p>
<p>The implementation provided by the base class does nothing. </p>

</div>
</div>
<a class="anchor" id="ae87131a6ed4539663f0406932bcfb007"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FiTime </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>t_us</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>t_ss</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If this method is called within any of the methods of the class that are "actively timed" (this depends on the subclasses), it returns the user and sistem time (in seconds) since the start of that method. </p>
<p>If methods that are actively timed call other methods that are actively timed, this method returns the (...) time since the beginning of the <em>outer</em> actively timed method. If this method is called outside of any actively timed method, it returns the (...) time spent in all the previous executions of all the actively timed methods of the class.</p>
<p>Implementing the proper calls to Fit-&gt;Start() and Fit-&gt;Stop() is due to derived classes; these should at least be placed at the beginning and at the end, respectively, of <a class="el" href="classFiOracle.html#aa90312f57c5be3fb8435a1f394c29533" title="This method must return the value of the function Fi to be minimized in the point Lmbd set by SetLamb...">Fi()</a>, <a class="el" href="classFiOracle.html#a8cb2c48818819c88850c6a815440b76f" title="Pass to the FiOracle the point where the function Fi() has to be evaluated. ">SetLambda()</a>, <a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a> and <a class="el" href="classFiOracle.html#adf35d71a3d63ba31c64910bdbe650864" title="GetVal() [and GetGi(), see above] can be used to query information about the items. ">GetVal()</a> - that is, at least these methods should be "actively timed". </p>

</div>
</div>
<a class="anchor" id="a4e53341358998440f1d1d9436b6cdfec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double FiTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>As <a class="el" href="classFiOracle.html#ae87131a6ed4539663f0406932bcfb007" title="If this method is called within any of the methods of the class that are &quot;actively timed&quot; (this depen...">FiTime( double &amp; , double &amp; )</a> [see above], except that returns the total (system + user ) time. </p>

</div>
</div>
<a class="anchor" id="aa80f5c831464c830e75d9a86c18eb1e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Deleted </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>i</em> = <code>Inf&lt;Index&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If so instructed by <a class="el" href="classFiOracle.html#a8a848c4b8e474ab60be98c6acca48ccf" title="In some cases, an optimal solution of the dual problem (D) [see the general notes] is a mostly welcom...">SetMaxName()</a> [see above], the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> should keep "dual" information attached to the subgradients/constraints produced [see <a class="el" href="classFiOracle.html#a4bc17c68285be9171d126705efb15cdd" title="GetGi() [and GetVal(), see below] can be used to query information about the items. ">GetGi()</a> above]. </p>
<p>As items become useless for the NDO algorithm, the corresponding dual information can be discarded. If called with 0 &lt;= i &lt; n, where n is the maximum item name set by the latest call to <a class="el" href="classFiOracle.html#a8a848c4b8e474ab60be98c6acca48ccf" title="In some cases, an optimal solution of the dual problem (D) [see the general notes] is a mostly welcom...">SetMaxName()</a> [see above], Deleted( i ) tells the <a class="el" href="classFiOracle.html#ae6f8eccd8ffb760f2e13a6672dca6752" title="Constructor of the class: takes no arguments, since everything that concerns the real evaluation of t...">FiOracle()</a> that the dual information corresponding to the item named `i' can be discared; if i &gt; n, then the information corresponding to <em>all items</em> can be discarded. The <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> may not need to do nothing in response to a call to <a class="el" href="classFiOracle.html#aa80f5c831464c830e75d9a86c18eb1e3" title="If so instructed by SetMaxName() [see above], the FiOracle should keep &quot;dual&quot; information attached to...">Deleted()</a>, as in the default implementation.</p>
<p>Note that there is another way for the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> to discover that a certain dual information is outdated, which is simply when its "name" is re-used in <a class="el" href="classFiOracle.html#a2e53e0ca809a3be0075a6b8d53fd3b07" title="After that a new item has been produced, i.e., a call to NewGi() returned true, and that (possibly) G...">SetGiName()</a> [see above]; at that point, the dual information corresponding to the old item with that name must be replaced with the dual information corresponding to the new item. </p>

</div>
</div>
<a class="anchor" id="a2b4d7bd37454c8023326b3668e4f4c27"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Aggregate </td>
          <td>(</td>
          <td class="paramtype">cHpRow&#160;</td>
          <td class="paramname"><em>Mlt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cIndex_Set&#160;</td>
          <td class="paramname"><em>NmSt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>Dm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>NwNm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Many NDO algorithms perform operations on the subgradients that they obtain from the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>; the most common operation is taking linear or convex combinations of some subgradients/constraints. </p>
<p>In the Lagrangian case, this corresponds to taking linear or convex combinations of the corresponding points/extreme rays, generating new points/extreme rays. These new dual objects may have to be stored together with the "original" ones, if a dual solution is to be obtained in the end.</p>
<p>This is precisely the meaning of this method; a new dual object must be computed by taking a linear combination of Dm dual objects, using as multipliers those found in the first Dm positions of Mlt[]. Which dual objects have to be used depends on NmSt: if NmSt == 0 then Mlt[ i ] is the multiplier of the dual object with name i, for i = 0, ..., Dm - 1, otherwise Mlt[ i ] is the multiplier of the dual object with name NmSt[ i ], for i = 0, ..., Dm - 1. NmSt[] must be ordered in increasing sense and Inf&lt;Index&gt;()-terminated. The new dual object must be given name NwNm. Note that <em>NwNm can be among the names in NmSt[]</em> (be &lt; Dm if NmSt == 0), that is, the NDO solver may want to substitute one existing dual object with its linear combination with other dual objects. This method can be called several times consecutively, possibly using dual objects previously obtained by linear combination as the basis for computing new dual objects. Typically, the linear combination is in fact a convex one, so that, in the Lagrangian case, the newly obtained dual object is in conv( X ). When X is separable in a cartesian product (Fi is decomposable), convex combinations usually combine only points belonging to the same component.</p>
<p>Note that the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> may refuse to take care of the dual information without warning the NDO solver about it; in fact, an "empty" implementation is given by default to all the methods dealing with dual stuff. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a17f7311fea45f493699851bcee1c0628"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cIndex_Set LamBase</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(pointer to) the set of indices of nonzeroes if Lambda[] is in "sparse" format. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classFiOracle.html">FiOracle</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
