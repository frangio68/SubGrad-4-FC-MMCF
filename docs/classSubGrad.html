<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>CNDSM: SubGrad Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CNDSM
   &#160;<span id="projectnumber">1.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSubGrad.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classSubGrad-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SubGrad Class Reference<div class="ingroups"><a class="el" href="group__SubGrad__CLASSES.html">Classes in SubGrad.h</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The <code><a class="el" href="classSubGrad.html" title="The SubGrad class implements the NDOSolver interface for NonDifferentiable Optimization Solvers [see ...">SubGrad</a></code> class implements the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> interface for NonDifferentiable Optimization Solvers [see <a class="el" href="NDOSlver_8h.html" title="Definition of the abstract base class NDOSolver, which defines the interface for convex minimization ...">NDOSlver.h</a>], using a unified subgradient-type algorithm as described in:  
 <a href="classSubGrad.html#details">More...</a></p>

<p><code>#include &lt;SubGrad.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SubGrad:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classSubGrad.png" usemap="#SubGrad_map" alt=""/>
  <map id="SubGrad_map" name="SubGrad_map">
<area href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv..." alt="NDOSolver" shape="rect" coords="0,0,77,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Types</div></td></tr>
<tr class="inherit_header pub_types_classNDOSolver"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classNDOSolver')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classNDOSolver.html">NDOSolver</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructor</div></td></tr>
<tr class="memitem:ab0b8fa974c1e889b7106eb7dca69cd6b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#ab0b8fa974c1e889b7106eb7dca69cd6b">SubGrad</a> (istream *iStrm=0)</td></tr>
<tr class="memdesc:ab0b8fa974c1e889b7106eb7dca69cd6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the class.  <a href="#ab0b8fa974c1e889b7106eb7dca69cd6b">More...</a><br /></td></tr>
<tr class="separator:ab0b8fa974c1e889b7106eb7dca69cd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Other initializations</div></td></tr>
<tr class="memitem:a90b1859cfc4994dd5989175e22c53f4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a90b1859cfc4994dd5989175e22c53f4e">SetStepsize</a> (<a class="el" href="classStepsize.html">Stepsize</a> *STP=0)</td></tr>
<tr class="memdesc:a90b1859cfc4994dd5989175e22c53f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives to the <code><a class="el" href="classSubGrad.html" title="The SubGrad class implements the NDOSolver interface for NonDifferentiable Optimization Solvers [see ...">SubGrad</a></code> object a pointer to an object of class <code><a class="el" href="classStepsize.html" title="The class Stepsize provides an interface for the stepsize rule, to be used in the SubGrad solver [see...">Stepsize</a></code> that will be used to provide <img class="formulaInl" alt="$\nu_i$" src="form_42.png"/> during the subgradient algorithm.  <a href="#a90b1859cfc4994dd5989175e22c53f4e">More...</a><br /></td></tr>
<tr class="separator:a90b1859cfc4994dd5989175e22c53f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98144b7732469933ebc2bb86bef49308"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a98144b7732469933ebc2bb86bef49308">SetDeflection</a> (<a class="el" href="classDeflection.html">Deflection</a> *Vol=0)</td></tr>
<tr class="memdesc:a98144b7732469933ebc2bb86bef49308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives to the <code><a class="el" href="classSubGrad.html" title="The SubGrad class implements the NDOSolver interface for NonDifferentiable Optimization Solvers [see ...">SubGrad</a></code> object a pointer to an object of class <code><a class="el" href="classDeflection.html" title="The class Deflection provides an interface for the deflection rule (DR), to be used in the SubGrad so...">Deflection</a></code> that will be used to provide a deflection coefficient <img class="formulaInl" alt="$ \alpha_i$" src="form_74.png"/> .  <a href="#a98144b7732469933ebc2bb86bef49308">More...</a><br /></td></tr>
<tr class="separator:a98144b7732469933ebc2bb86bef49308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad242ca0d8c2e8d21342d2057bdfca3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a6ad242ca0d8c2e8d21342d2057bdfca3">SetQKNP</a> (<a class="el" href="classCQKnPClass__di__unipi__it_1_1CQKnPClass.html">CQKnPClass</a> *KNP=0)</td></tr>
<tr class="memdesc:a6ad242ca0d8c2e8d21342d2057bdfca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives to the <a class="el" href="classSubGrad.html" title="The SubGrad class implements the NDOSolver interface for NonDifferentiable Optimization Solvers [see ...">SubGrad</a> object a pointer to an object of class CQKnPClass that will be used as quadratic knapsack solver during the subgradient algorithm.  <a href="#a6ad242ca0d8c2e8d21342d2057bdfca3">More...</a><br /></td></tr>
<tr class="separator:a6ad242ca0d8c2e8d21342d2057bdfca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa531dee5e4b43e8d0b04856bff072b77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa531dee5e4b43e8d0b04856bff072b77"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetFiOracle</b> (<a class="el" href="classFiOracle.html">FiOracle</a> *Fi=0)</td></tr>
<tr class="separator:aa531dee5e4b43e8d0b04856bff072b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104f6f8bddc9865ef35631a832fb8bd9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a104f6f8bddc9865ef35631a832fb8bd9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetLambda</b> (cLMRow tLambda=0)</td></tr>
<tr class="separator:a104f6f8bddc9865ef35631a832fb8bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d2e8e4a19a5b7454b49be2bef6dbee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95d2e8e4a19a5b7454b49be2bef6dbee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>KeepBestLambda</b> (const bool KBL=true)</td></tr>
<tr class="separator:a95d2e8e4a19a5b7454b49be2bef6dbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23766f6f13e9580b2ec69f429788a1a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a23766f6f13e9580b2ec69f429788a1a6">SetPar</a> (const int wp, const int value)</td></tr>
<tr class="memdesc:a23766f6f13e9580b2ec69f429788a1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends NDOSolver::SetPar( , cIndex ) for handling the SubGrad-specific parameters; the enum SGParam is used (in the obvious way) for selecting the parameter to be set.  <a href="#a23766f6f13e9580b2ec69f429788a1a6">More...</a><br /></td></tr>
<tr class="separator:a23766f6f13e9580b2ec69f429788a1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7952ff5bfa959618fbb24cfe598b889a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a7952ff5bfa959618fbb24cfe598b889a">SetPar</a> (const int wp, cHpNum value)</td></tr>
<tr class="memdesc:a7952ff5bfa959618fbb24cfe598b889a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends NDOSolver::SetPar( , cHpNum ) for handling the SubGrad-specific parameters; the enum SGParam is used (in the obvious way) for selecting the parameter to be set.  <a href="#a7952ff5bfa959618fbb24cfe598b889a">More...</a><br /></td></tr>
<tr class="separator:a7952ff5bfa959618fbb24cfe598b889a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25c49ef56af4e6166110cdf324f6b53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#ac25c49ef56af4e6166110cdf324f6b53">SetPar</a> (const int wp, const bool value)</td></tr>
<tr class="memdesc:ac25c49ef56af4e6166110cdf324f6b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change boolean algorithmic parameters of the <a class="el" href="classSubGrad.html" title="The SubGrad class implements the NDOSolver interface for NonDifferentiable Optimization Solvers [see ...">SubGrad</a> solver.  <a href="#ac25c49ef56af4e6166110cdf324f6b53">More...</a><br /></td></tr>
<tr class="separator:ac25c49ef56af4e6166110cdf324f6b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe58ac2f9c5ebae521b801c95beb8a3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#abe58ac2f9c5ebae521b801c95beb8a3b">SetNDOLog</a> (ostream *outs=0, const char lvl=0)</td></tr>
<tr class="memdesc:abe58ac2f9c5ebae521b801c95beb8a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">lvl controls the "level of verbosity" of the code.  <a href="#abe58ac2f9c5ebae521b801c95beb8a3b">More...</a><br /></td></tr>
<tr class="separator:abe58ac2f9c5ebae521b801c95beb8a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Solving the problem</div></td></tr>
<tr class="memitem:a4abf45f1d94e4e30cdad148af0d69e71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNDOSolver.html#a3028873c2d546da98905c33628e01442">NDOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a4abf45f1d94e4e30cdad148af0d69e71">Solve</a> (void)</td></tr>
<tr class="memdesc:a4abf45f1d94e4e30cdad148af0d69e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to minimize the function [see <a class="el" href="NDOSlver_8h.html" title="Definition of the abstract base class NDOSolver, which defines the interface for convex minimization ...">NDOSlver.h</a>].  <a href="#a4abf45f1d94e4e30cdad148af0d69e71">More...</a><br /></td></tr>
<tr class="separator:a4abf45f1d94e4e30cdad148af0d69e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad42200b126f5251c20490db5b6e06a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a1ad42200b126f5251c20490db5b6e06a">ReSetAlg</a> (unsigned char RstLvl=0)</td></tr>
<tr class="memdesc:a1ad42200b126f5251c20490db5b6e06a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the internal state of the Subgradient algorithm.  <a href="#a1ad42200b126f5251c20490db5b6e06a">More...</a><br /></td></tr>
<tr class="separator:a1ad42200b126f5251c20490db5b6e06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading the solution</div></td></tr>
<tr class="memitem:ad214f4b3502ca5dd35f513eec1cd6251"><td class="memItemLeft" align="right" valign="top">cLMRow&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#ad214f4b3502ca5dd35f513eec1cd6251">ReadBestSol</a> (cIndex_Set &amp;I, Index &amp;D)</td></tr>
<tr class="memdesc:ad214f4b3502ca5dd35f513eec1cd6251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only pointer to the point having the lowest <img class="formulaInl" alt="$f$" src="form_72.png"/> value found so far [see below].  <a href="#ad214f4b3502ca5dd35f513eec1cd6251">More...</a><br /></td></tr>
<tr class="separator:ad214f4b3502ca5dd35f513eec1cd6251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845913d16e9747aa92aff33076b22c15"><td class="memItemLeft" align="right" valign="top">HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a845913d16e9747aa92aff33076b22c15">ReadBestFiVal</a> (cIndex wFi=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:a845913d16e9747aa92aff33076b22c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the best <img class="formulaInl" alt="$f$" src="form_72.png"/> value found so far.  <a href="#a845913d16e9747aa92aff33076b22c15">More...</a><br /></td></tr>
<tr class="separator:a845913d16e9747aa92aff33076b22c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0efcd2dbcac404c154a9a25c17cb2cb"><td class="memItemLeft" align="right" valign="top">cLMRow&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#ad0efcd2dbcac404c154a9a25c17cb2cb">ReadSol</a> (cIndex_Set &amp;I, Index &amp;D)</td></tr>
<tr class="memdesc:ad0efcd2dbcac404c154a9a25c17cb2cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only pointer to the <em>stability center</em> <img class="formulaInl" alt="$\bar{\lambda}_i$" src="form_63.png"/>.  <a href="#ad0efcd2dbcac404c154a9a25c17cb2cb">More...</a><br /></td></tr>
<tr class="separator:ad0efcd2dbcac404c154a9a25c17cb2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3551945ff40b2aea9cea17184b48dc0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3551945ff40b2aea9cea17184b48dc0a"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a3551945ff40b2aea9cea17184b48dc0a">ReadFiVal</a> (cIndex wFi=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:a3551945ff40b2aea9cea17184b48dc0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Independently from which "component" of Fi() is chosen, it returns the full function Fi at the <em> stability center </em> <img class="formulaInl" alt="$\bar{\lambda}_i$" src="form_63.png"/>. <br /></td></tr>
<tr class="separator:a3551945ff40b2aea9cea17184b48dc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be83d27ffbe363a589dd29a86a492a4"><td class="memItemLeft" align="right" valign="top">HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a5be83d27ffbe363a589dd29a86a492a4">ReadHatFiVal</a> (void)</td></tr>
<tr class="memdesc:a5be83d27ffbe363a589dd29a86a492a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <img class="formulaInl" alt="$\hat{f}$" src="form_79.png"/>, if <img class="formulaInl" alt="$ \hat{\lambda}_i $" src="form_80.png"/> is kept in memory.  <a href="#a5be83d27ffbe363a589dd29a86a492a4">More...</a><br /></td></tr>
<tr class="separator:a5be83d27ffbe363a589dd29a86a492a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ed499a9e05bdc04d3d6d00c2ad82c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a39ed499a9e05bdc04d3d6d00c2ad82c7">IsOptimal</a> (HpNum eps=0)</td></tr>
<tr class="memdesc:a39ed499a9e05bdc04d3d6d00c2ad82c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the solution <img class="formulaInl" alt="$\bar{\lambda}_i$" src="form_63.png"/> is <img class="formulaInl" alt="$\epsilon$" src="form_78.png"/>-optimal (relative), being <img class="formulaInl" alt="$\epsilon $" src="form_81.png"/> set to EpsLin.  <a href="#a39ed499a9e05bdc04d3d6d00c2ad82c7">More...</a><br /></td></tr>
<tr class="separator:a39ed499a9e05bdc04d3d6d00c2ad82c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c74fb20337066d3ebd91d6376ff3cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89c74fb20337066d3ebd91d6376ff3cf"></a>
cHpRow&#160;</td><td class="memItemRight" valign="bottom"><b>ReadMult</b> (cIndex_Set &amp;I, Index &amp;D, cIndex wFi=Inf&lt; Index &gt;())</td></tr>
<tr class="separator:a89c74fb20337066d3ebd91d6376ff3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25d02b6d7a33da48686f453496bfc93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac25d02b6d7a33da48686f453496bfc93"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><b>ReadLBMult</b> (cIndex wFi=Inf&lt; Index &gt;())</td></tr>
<tr class="separator:ac25d02b6d7a33da48686f453496bfc93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading the data of the problem</div></td></tr>
<tr class="memitem:a62e19d31ccc41dfa45cc83b9bc765e17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62e19d31ccc41dfa45cc83b9bc765e17"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GetPar</b> (const int wp, int &amp;value)</td></tr>
<tr class="separator:a62e19d31ccc41dfa45cc83b9bc765e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bd71859182dbc717132696636014e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5bd71859182dbc717132696636014e4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GetPar</b> (const int wp, HpNum &amp;value)</td></tr>
<tr class="separator:ab5bd71859182dbc717132696636014e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ff442d7df1412f96dcfe97660f6451"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39ff442d7df1412f96dcfe97660f6451"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GetPar</b> (const int wp, bool &amp;value)</td></tr>
<tr class="separator:a39ff442d7df1412f96dcfe97660f6451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Adding / removing / changing data</div></td></tr>
<tr class="memitem:ad2ce9dd0e1d37977c641246fd6e33d5a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2ce9dd0e1d37977c641246fd6e33d5a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AddVariables</b> (Index NNwVrs, cLMRow IVs=0)</td></tr>
<tr class="separator:ad2ce9dd0e1d37977c641246fd6e33d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9a9118ec825f30531d08c6df8c4769"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b9a9118ec825f30531d08c6df8c4769"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveVariables</b> (cIndex_Set whch=0, Index hwmny=0)</td></tr>
<tr class="separator:a6b9a9118ec825f30531d08c6df8c4769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70d67c7f3854bb0b9ea33eefbd805e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af70d67c7f3854bb0b9ea33eefbd805e0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ChgFiV</b> (cIndex wFi=Inf&lt; Index &gt;())</td></tr>
<tr class="separator:af70d67c7f3854bb0b9ea33eefbd805e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366d80aa446decf0ce29366df66af0be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a366d80aa446decf0ce29366df66af0be"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ChgSbG</b> (cIndex strt=0, Index stp=Inf&lt; Index &gt;(), cIndex wFi=Inf&lt; Index &gt;())</td></tr>
<tr class="separator:a366d80aa446decf0ce29366df66af0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destructor</div></td></tr>
<tr class="memitem:a8d74304c00415c603f244e50550b0861"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d74304c00415c603f244e50550b0861"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~SubGrad</b> ()</td></tr>
<tr class="separator:a8d74304c00415c603f244e50550b0861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classNDOSolver"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classNDOSolver')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classNDOSolver.html">NDOSolver</a></td></tr>
<tr class="memitem:ac6c93e6fbfe2940568ce6e4a70f1f7a9 inherit pub_methods_classNDOSolver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#ac6c93e6fbfe2940568ce6e4a70f1f7a9">IsOptimal</a> (HpNum eps=0) const </td></tr>
<tr class="memdesc:ac6c93e6fbfe2940568ce6e4a70f1f7a9 inherit pub_methods_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method should return true if the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> believes that the current solution [see <a class="el" href="classNDOSolver.html#ac7dbf4642c4b4f22bff6dcf5e8d67264" title="Returns a read-only pointer to the &quot;current point&quot; of the NDO algorithm, which is usually the &quot;best e...">ReadSol()</a> above] is eps-optimal (relative).  <a href="#ac6c93e6fbfe2940568ce6e4a70f1f7a9">More...</a><br /></td></tr>
<tr class="separator:ac6c93e6fbfe2940568ce6e4a70f1f7a9 inherit pub_methods_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c23b71f41deb617a84474d4265ab25 inherit pub_methods_classNDOSolver"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a94c23b71f41deb617a84474d4265ab25">FiEval</a> (void) const </td></tr>
<tr class="memdesc:a94c23b71f41deb617a84474d4265ab25 inherit pub_methods_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of times that Fi() has been called; if called from within Fi(), the present call should be excluded.  <a href="#a94c23b71f41deb617a84474d4265ab25">More...</a><br /></td></tr>
<tr class="separator:a94c23b71f41deb617a84474d4265ab25 inherit pub_methods_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f41276807360c8498840a654b08f09 inherit pub_methods_classNDOSolver"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a90f41276807360c8498840a654b08f09">GiEval</a> (void) const </td></tr>
<tr class="memdesc:a90f41276807360c8498840a654b08f09 inherit pub_methods_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of times that NewGi() has been called; if called from within NewGi(), the present call should be excluded.  <a href="#a90f41276807360c8498840a654b08f09">More...</a><br /></td></tr>
<tr class="separator:a90f41276807360c8498840a654b08f09 inherit pub_methods_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819a706181b0260f915fe1a3b1a842e7 inherit pub_methods_classNDOSolver"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a819a706181b0260f915fe1a3b1a842e7">NrCalls</a> (void) const </td></tr>
<tr class="memdesc:a819a706181b0260f915fe1a3b1a842e7 inherit pub_methods_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of times that <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a> has been called; if called from within <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a>, the present call should be included.  <a href="#a819a706181b0260f915fe1a3b1a842e7">More...</a><br /></td></tr>
<tr class="separator:a819a706181b0260f915fe1a3b1a842e7 inherit pub_methods_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41b23a17bbf7618a8675e89804b12cd inherit pub_methods_classNDOSolver"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#aa41b23a17bbf7618a8675e89804b12cd">NrIter</a> (void) const </td></tr>
<tr class="memdesc:aa41b23a17bbf7618a8675e89804b12cd inherit pub_methods_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of iterations.  <a href="#aa41b23a17bbf7618a8675e89804b12cd">More...</a><br /></td></tr>
<tr class="separator:aa41b23a17bbf7618a8675e89804b12cd inherit pub_methods_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd18260065df78d013735d5c9a520225 inherit pub_methods_classNDOSolver"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#afd18260065df78d013735d5c9a520225">NDOTime</a> (double &amp;t_us, double &amp;t_ss)</td></tr>
<tr class="memdesc:afd18260065df78d013735d5c9a520225 inherit pub_methods_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this method is called within any of the methods of the class that are "actively timed" (this depends on the subclasses), it returns the user and sistem time (in seconds) since the start of that method.  <a href="#afd18260065df78d013735d5c9a520225">More...</a><br /></td></tr>
<tr class="separator:afd18260065df78d013735d5c9a520225 inherit pub_methods_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ce9c84ab221296e0fd52b68e052153 inherit pub_methods_classNDOSolver"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a77ce9c84ab221296e0fd52b68e052153">NDOTime</a> (void)</td></tr>
<tr class="memdesc:a77ce9c84ab221296e0fd52b68e052153 inherit pub_methods_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">As <a class="el" href="classNDOSolver.html#afd18260065df78d013735d5c9a520225" title="If this method is called within any of the methods of the class that are &quot;actively timed&quot; (this depen...">NDOTime( double &amp; , double &amp; )</a> [see above], except that returns the total (system + user ) time.  <a href="#a77ce9c84ab221296e0fd52b68e052153">More...</a><br /></td></tr>
<tr class="separator:a77ce9c84ab221296e0fd52b68e052153 inherit pub_methods_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121fd9711d1724922d62153c7ead5231 inherit pub_methods_classNDOSolver"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a121fd9711d1724922d62153c7ead5231">NDOSolver</a> (istream *iStrm=0)</td></tr>
<tr class="memdesc:a121fd9711d1724922d62153c7ead5231 inherit pub_methods_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the class.  <a href="#a121fd9711d1724922d62153c7ead5231">More...</a><br /></td></tr>
<tr class="separator:a121fd9711d1724922d62153c7ead5231 inherit pub_methods_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b7996bf9fb1013f70df1d82d1b735c inherit pub_methods_classNDOSolver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a24b7996bf9fb1013f70df1d82d1b735c">SetNDOTime</a> (const bool TimeIt=true)</td></tr>
<tr class="memdesc:a24b7996bf9fb1013f70df1d82d1b735c inherit pub_methods_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classNDOSolver.html#a24b7996bf9fb1013f70df1d82d1b735c" title="SetNDOTime() allocates an OPTtimers object [see OPTUtils.h] that should be used for timing the calls ...">SetNDOTime()</a> allocates an OPTtimers object [see OPTUtils.h] that should be used for timing the calls to relevant methods of the class.  <a href="#a24b7996bf9fb1013f70df1d82d1b735c">More...</a><br /></td></tr>
<tr class="separator:a24b7996bf9fb1013f70df1d82d1b735c inherit pub_methods_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0e2f538b282f9fc50403bb6a66efb9 inherit pub_methods_classNDOSolver"><td class="memItemLeft" align="right" valign="top">Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a1b0e2f538b282f9fc50403bb6a66efb9">GetNumVar</a> (void) const </td></tr>
<tr class="memdesc:a1b0e2f538b282f9fc50403bb6a66efb9 inherit pub_methods_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of variables of the function; a protected field is offered by the base class to keep this information.  <a href="#a1b0e2f538b282f9fc50403bb6a66efb9">More...</a><br /></td></tr>
<tr class="separator:a1b0e2f538b282f9fc50403bb6a66efb9 inherit pub_methods_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cfef60a0c4d08e63b5315236253b59 inherit pub_methods_classNDOSolver"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a43cfef60a0c4d08e63b5315236253b59">~NDOSolver</a> ()</td></tr>
<tr class="memdesc:a43cfef60a0c4d08e63b5315236253b59 inherit pub_methods_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of the class.  <a href="#a43cfef60a0c4d08e63b5315236253b59">More...</a><br /></td></tr>
<tr class="separator:a43cfef60a0c4d08e63b5315236253b59 inherit pub_methods_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ada9fae89db1844e478bfee044c021b2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#ada9fae89db1844e478bfee044c021b2c">FiAndGi</a> (cIndex wFi=Inf&lt; Index &gt;())</td></tr>
<tr class="memdesc:ada9fae89db1844e478bfee044c021b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the function at the new point <img class="formulaInl" alt="$\lambda_{i+1}$" src="form_85.png"/>, i.e., <img class="formulaInl" alt="$f(\lambda_{i+1})$" src="form_86.png"/>, and it either computes a subgradient <img class="formulaInl" alt="$g_{i+1} \in \partial f(\lambda_{i+1})$" src="form_87.png"/>, or, if the point is infeasible, a constraint.  <a href="#ada9fae89db1844e478bfee044c021b2c">More...</a><br /></td></tr>
<tr class="separator:ada9fae89db1844e478bfee044c021b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237e3a167830fdb29a3f0fff486c0109"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a237e3a167830fdb29a3f0fff486c0109">FormD</a> (void)</td></tr>
<tr class="memdesc:a237e3a167830fdb29a3f0fff486c0109"><td class="mdescLeft">&#160;</td><td class="mdescRight">The method is used within <a class="el" href="classSubGrad.html#a4abf45f1d94e4e30cdad148af0d69e71" title="Tries to minimize the function [see NDOSlver.h]. ">Solve()</a> [see above], and its job is to compute the direction <img class="formulaInl" alt="$d_i$" src="form_59.png"/> that appears in the formula of <img class="formulaInl" alt="$\lambda_{i+1}$" src="form_85.png"/>.  <a href="#a237e3a167830fdb29a3f0fff486c0109">More...</a><br /></td></tr>
<tr class="separator:a237e3a167830fdb29a3f0fff486c0109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83d20499268fe44df92a9908f4f5fde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#ae83d20499268fe44df92a9908f4f5fde">SaveDir</a> (void)</td></tr>
<tr class="memdesc:ae83d20499268fe44df92a9908f4f5fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">The method is combined with <a class="el" href="classSubGrad.html#a237e3a167830fdb29a3f0fff486c0109" title="The method is used within Solve() [see above], and its job is to compute the direction  that appears ...">FormD()</a> [see above] to carry out the direction computation.  <a href="#ae83d20499268fe44df92a9908f4f5fde">More...</a><br /></td></tr>
<tr class="separator:ae83d20499268fe44df92a9908f4f5fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7b43879f08b120019fc698eb71fdbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#abe7b43879f08b120019fc698eb71fdbc">GotoLambda1</a> (void)</td></tr>
<tr class="memdesc:abe7b43879f08b120019fc698eb71fdbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the current point to <img class="formulaInl" alt="$\lambda_{i+1}$" src="form_85.png"/>.  <a href="#abe7b43879f08b120019fc698eb71fdbc">More...</a><br /></td></tr>
<tr class="separator:abe7b43879f08b120019fc698eb71fdbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eeda37b978781a055c191f8de5a3f2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a8eeda37b978781a055c191f8de5a3f2d">FormLambda1</a> (void)</td></tr>
<tr class="memdesc:a8eeda37b978781a055c191f8de5a3f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">After a (succesfull) call to <a class="el" href="classSubGrad.html#a237e3a167830fdb29a3f0fff486c0109" title="The method is used within Solve() [see above], and its job is to compute the direction  that appears ...">FormD()</a>, sets the new (unprojected) tentative point <img class="formulaInl" alt="$\breve{\lambda}_{i+1}$" src="form_88.png"/> as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \breve{\lambda}_{i+1} = \lambda_i - \nu_i d_i \,. \]" src="form_89.png"/>
</p>
<p> Remark that the point <img class="formulaInl" alt="$\breve{\lambda}_{i+1}$" src="form_88.png"/> must be projected before calling FiandGi() [see above], i.e., <img class="formulaInl" alt="$ \lambda_{i+1} = {\rm P}_{\Lambda} ( \breve{\lambda}_{i+1} ) $" src="form_90.png"/>.  <a href="#a8eeda37b978781a055c191f8de5a3f2d">More...</a><br /></td></tr>
<tr class="separator:a8eeda37b978781a055c191f8de5a3f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae16d34612e7a30c5eac5346ef305d943"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae16d34612e7a30c5eac5346ef305d943"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#ae16d34612e7a30c5eac5346ef305d943">SGPar1</a></td></tr>
<tr class="memdesc:ae16d34612e7a30c5eac5346ef305d943"><td class="mdescLeft">&#160;</td><td class="mdescRight">projection-strategy parameters <br /></td></tr>
<tr class="separator:ae16d34612e7a30c5eac5346ef305d943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16fc0e0cc1809cf728e3b3de0ccf8867"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16fc0e0cc1809cf728e3b3de0ccf8867"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a16fc0e0cc1809cf728e3b3de0ccf8867">SGPar2</a></td></tr>
<tr class="memdesc:a16fc0e0cc1809cf728e3b3de0ccf8867"><td class="mdescLeft">&#160;</td><td class="mdescRight">incremental factor <br /></td></tr>
<tr class="separator:a16fc0e0cc1809cf728e3b3de0ccf8867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa16a05c66d09b1cffd58c1a2a3c6b7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa16a05c66d09b1cffd58c1a2a3c6b7e"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#afa16a05c66d09b1cffd58c1a2a3c6b7e">SGPar3</a></td></tr>
<tr class="memdesc:afa16a05c66d09b1cffd58c1a2a3c6b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">scheme: stepsize(deflection)-restricted <br /></td></tr>
<tr class="separator:afa16a05c66d09b1cffd58c1a2a3c6b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d2e7b97b1a81b3b1509b85b63e6791"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86d2e7b97b1a81b3b1509b85b63e6791"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a86d2e7b97b1a81b3b1509b85b63e6791">SGPar4</a></td></tr>
<tr class="memdesc:a86d2e7b97b1a81b3b1509b85b63e6791"><td class="mdescLeft">&#160;</td><td class="mdescRight">control if <img class="formulaInl" alt="$ \hat{\lambda}_i $" src="form_80.png"/> is kept <br /></td></tr>
<tr class="separator:a86d2e7b97b1a81b3b1509b85b63e6791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ddde066aee450bf5cb63f9d41ade9d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4ddde066aee450bf5cb63f9d41ade9d"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#aa4ddde066aee450bf5cb63f9d41ade9d">SGPar5</a></td></tr>
<tr class="memdesc:aa4ddde066aee450bf5cb63f9d41ade9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">seed <br /></td></tr>
<tr class="separator:aa4ddde066aee450bf5cb63f9d41ade9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b860cf724bf395f37e7779d24cf77f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b860cf724bf395f37e7779d24cf77f5"></a>
<a class="el" href="classStepsize.html">Stepsize</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a5b860cf724bf395f37e7779d24cf77f5">stepsize</a></td></tr>
<tr class="memdesc:a5b860cf724bf395f37e7779d24cf77f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the <a class="el" href="classStepsize.html" title="The class Stepsize provides an interface for the stepsize rule, to be used in the SubGrad solver [see...">Stepsize</a> class <br /></td></tr>
<tr class="separator:a5b860cf724bf395f37e7779d24cf77f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf3d85908a2f88c645724123e8cb82c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebf3d85908a2f88c645724123e8cb82c"></a>
<a class="el" href="classDeflection.html">Deflection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#aebf3d85908a2f88c645724123e8cb82c">deflection</a></td></tr>
<tr class="memdesc:aebf3d85908a2f88c645724123e8cb82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the <a class="el" href="classDeflection.html" title="The class Deflection provides an interface for the deflection rule (DR), to be used in the SubGrad so...">Deflection</a> class <br /></td></tr>
<tr class="separator:aebf3d85908a2f88c645724123e8cb82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b6f7dda440670d6781d8979020876d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80b6f7dda440670d6781d8979020876d"></a>
<a class="el" href="classCQKnPClass__di__unipi__it_1_1CQKnPClass.html">CQKnPClass</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a80b6f7dda440670d6781d8979020876d">Q2KNP</a></td></tr>
<tr class="memdesc:a80b6f7dda440670d6781d8979020876d"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the quadratic knapsack solver <br /></td></tr>
<tr class="separator:a80b6f7dda440670d6781d8979020876d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eafc63ded0de4be42a8c99695bb9908"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2eafc63ded0de4be42a8c99695bb9908"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a2eafc63ded0de4be42a8c99695bb9908">MaxNumVar</a></td></tr>
<tr class="memdesc:a2eafc63ded0de4be42a8c99695bb9908"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of variables <br /></td></tr>
<tr class="separator:a2eafc63ded0de4be42a8c99695bb9908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac365cfd59e7334dcb587f7ecd53cd2bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac365cfd59e7334dcb587f7ecd53cd2bd"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#ac365cfd59e7334dcb587f7ecd53cd2bd">MaxNConst</a></td></tr>
<tr class="memdesc:ac365cfd59e7334dcb587f7ecd53cd2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of simplex constraints <br /></td></tr>
<tr class="separator:ac365cfd59e7334dcb587f7ecd53cd2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049e41028433ee40189ac5b5660f95fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a049e41028433ee40189ac5b5660f95fd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a049e41028433ee40189ac5b5660f95fd">BoxConst</a></td></tr>
<tr class="memdesc:a049e41028433ee40189ac5b5660f95fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">true, if there are some box constraints <br /></td></tr>
<tr class="separator:a049e41028433ee40189ac5b5660f95fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a38ef0c08bb6c1046ae335ceb319619"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a38ef0c08bb6c1046ae335ceb319619"></a>
LMRow&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a2a38ef0c08bb6c1046ae335ceb319619">LambdaBar</a></td></tr>
<tr class="memdesc:a2a38ef0c08bb6c1046ae335ceb319619"><td class="mdescLeft">&#160;</td><td class="mdescRight">the stability center <img class="formulaInl" alt="$\bar{\lambda}_i$" src="form_63.png"/> <br /></td></tr>
<tr class="separator:a2a38ef0c08bb6c1046ae335ceb319619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6108fff45cd16241d7c84fcbc1dc90ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6108fff45cd16241d7c84fcbc1dc90ae"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a6108fff45cd16241d7c84fcbc1dc90ae">FiBar</a></td></tr>
<tr class="memdesc:a6108fff45cd16241d7c84fcbc1dc90ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">full function value at <em>LambdaBar</em> <br /></td></tr>
<tr class="separator:a6108fff45cd16241d7c84fcbc1dc90ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbbea6f72b5d26ec9a3fce20e0f3fd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cbbea6f72b5d26ec9a3fce20e0f3fd6"></a>
LMRow&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a9cbbea6f72b5d26ec9a3fce20e0f3fd6">Lambda</a></td></tr>
<tr class="memdesc:a9cbbea6f72b5d26ec9a3fce20e0f3fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">the current point <img class="formulaInl" alt="$ \lambda_i $" src="form_91.png"/> or the trial point <img class="formulaInl" alt="$ \lambda_{i+1} $" src="form_92.png"/> <br /></td></tr>
<tr class="separator:a9cbbea6f72b5d26ec9a3fce20e0f3fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b73f0dbdcd7d715e4fdf3d9f6946412"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b73f0dbdcd7d715e4fdf3d9f6946412"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a2b73f0dbdcd7d715e4fdf3d9f6946412">FiLambda</a></td></tr>
<tr class="memdesc:a2b73f0dbdcd7d715e4fdf3d9f6946412"><td class="mdescLeft">&#160;</td><td class="mdescRight">full function value at <em>Lambda</em> <br /></td></tr>
<tr class="separator:a2b73f0dbdcd7d715e4fdf3d9f6946412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350dc616d2c19471dd90428e567b20ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a350dc616d2c19471dd90428e567b20ea"></a>
LMRow&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a350dc616d2c19471dd90428e567b20ea">LambdaHat</a></td></tr>
<tr class="memdesc:a350dc616d2c19471dd90428e567b20ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">the point <img class="formulaInl" alt="$ \hat{\lambda}_i $" src="form_80.png"/> <br /></td></tr>
<tr class="separator:a350dc616d2c19471dd90428e567b20ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b6ed57cee2309f7da9b3afe4d7cbae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2b6ed57cee2309f7da9b3afe4d7cbae"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#af2b6ed57cee2309f7da9b3afe4d7cbae">FiHat</a></td></tr>
<tr class="memdesc:af2b6ed57cee2309f7da9b3afe4d7cbae"><td class="mdescLeft">&#160;</td><td class="mdescRight">full function value at <em>HLmb</em> <br /></td></tr>
<tr class="separator:af2b6ed57cee2309f7da9b3afe4d7cbae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb1cfdeeaec516bdc172e485e6a4753"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bb1cfdeeaec516bdc172e485e6a4753"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a1bb1cfdeeaec516bdc172e485e6a4753">LHasChgd</a></td></tr>
<tr class="memdesc:a1bb1cfdeeaec516bdc172e485e6a4753"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if Lambda has changed since the latest call to <a class="el" href="classSubGrad.html#ada9fae89db1844e478bfee044c021b2c" title="Evaluates the function at the new point , i.e., , and it either computes a subgradient ...">FiAndGi()</a> <br /></td></tr>
<tr class="separator:a1bb1cfdeeaec516bdc172e485e6a4753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f26a74995b8f4aa49bf62ab997e4236"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f26a74995b8f4aa49bf62ab997e4236"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a3f26a74995b8f4aa49bf62ab997e4236">LHasProj</a></td></tr>
<tr class="memdesc:a3f26a74995b8f4aa49bf62ab997e4236"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if <em>Lambda</em> has projected in the current iteration <br /></td></tr>
<tr class="separator:a3f26a74995b8f4aa49bf62ab997e4236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a2740788c61c265b1631fddd95836e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7a2740788c61c265b1631fddd95836e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#ac7a2740788c61c265b1631fddd95836e">KpBstL</a></td></tr>
<tr class="memdesc:ac7a2740788c61c265b1631fddd95836e"><td class="mdescLeft">&#160;</td><td class="mdescRight">if LambdaBest has to be kept <br /></td></tr>
<tr class="separator:ac7a2740788c61c265b1631fddd95836e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4850219d46507cf28bb795f41e745a7c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4850219d46507cf28bb795f41e745a7c"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a4850219d46507cf28bb795f41e745a7c">FiBest</a></td></tr>
<tr class="memdesc:a4850219d46507cf28bb795f41e745a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">the best value of <img class="formulaInl" alt="$f$" src="form_72.png"/> found so far <br /></td></tr>
<tr class="separator:a4850219d46507cf28bb795f41e745a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7a424d4e296c99b4ca1bbfefb11521"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a7a424d4e296c99b4ca1bbfefb11521"></a>
LMRow&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a0a7a424d4e296c99b4ca1bbfefb11521">LambdaBest</a></td></tr>
<tr class="memdesc:a0a7a424d4e296c99b4ca1bbfefb11521"><td class="mdescLeft">&#160;</td><td class="mdescRight">the best point found so far <br /></td></tr>
<tr class="separator:a0a7a424d4e296c99b4ca1bbfefb11521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87df88cd01480859ba973cdc4c51a3f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87df88cd01480859ba973cdc4c51a3f3"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a87df88cd01480859ba973cdc4c51a3f3">LowerBound</a></td></tr>
<tr class="memdesc:a87df88cd01480859ba973cdc4c51a3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower Bound over the full function <img class="formulaInl" alt="$f$" src="form_72.png"/>. <br /></td></tr>
<tr class="separator:a87df88cd01480859ba973cdc4c51a3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace99e8209ec0aba72bd2835208853ae7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace99e8209ec0aba72bd2835208853ae7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#ace99e8209ec0aba72bd2835208853ae7">TrueLB</a></td></tr>
<tr class="memdesc:ace99e8209ec0aba72bd2835208853ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if LowerBound is a "true" lower bound rather than just the "minus infinity" <br /></td></tr>
<tr class="separator:ace99e8209ec0aba72bd2835208853ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b17530a14462c1673a6c41d6bb0a8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75b17530a14462c1673a6c41d6bb0a8d"></a>
SgRow&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a75b17530a14462c1673a6c41d6bb0a8d">Gi</a></td></tr>
<tr class="memdesc:a75b17530a14462c1673a6c41d6bb0a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gi[ wFi ]( Lambda ), the subgradient. <br /></td></tr>
<tr class="separator:a75b17530a14462c1673a6c41d6bb0a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d80e390f5c7d2bdce2b6a1161727d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69d80e390f5c7d2bdce2b6a1161727d2"></a>
SgRow&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a69d80e390f5c7d2bdce2b6a1161727d2">dir</a></td></tr>
<tr class="memdesc:a69d80e390f5c7d2bdce2b6a1161727d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">the direction <img class="formulaInl" alt="$ d_i $" src="form_23.png"/> <br /></td></tr>
<tr class="separator:a69d80e390f5c7d2bdce2b6a1161727d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba4c55441c1944f3b0696d367152e04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abba4c55441c1944f3b0696d367152e04"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#abba4c55441c1944f3b0696d367152e04">alpha</a></td></tr>
<tr class="memdesc:abba4c55441c1944f3b0696d367152e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">the deflection parameter <img class="formulaInl" alt="$ \alpha_i $" src="form_38.png"/> <br /></td></tr>
<tr class="separator:abba4c55441c1944f3b0696d367152e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d47f9e1d5bf9925a1b391914fbc3f9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d47f9e1d5bf9925a1b391914fbc3f9f"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a0d47f9e1d5bf9925a1b391914fbc3f9f">step</a></td></tr>
<tr class="memdesc:a0d47f9e1d5bf9925a1b391914fbc3f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">the stepsize <img class="formulaInl" alt="$ \nu_i $" src="form_93.png"/> <br /></td></tr>
<tr class="separator:a0d47f9e1d5bf9925a1b391914fbc3f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a26d76cd3298911127b6ca589e92fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29a26d76cd3298911127b6ca589e92fb"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a29a26d76cd3298911127b6ca589e92fb">Sigma</a></td></tr>
<tr class="memdesc:a29a26d76cd3298911127b6ca589e92fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">the linearization error <img class="formulaInl" alt="$ \sigma_i$" src="form_94.png"/> of <img class="formulaInl" alt="$ g_i$" src="form_95.png"/> at <img class="formulaInl" alt="$\bar{\lambda}_{i}$" src="form_64.png"/> <br /></td></tr>
<tr class="separator:a29a26d76cd3298911127b6ca589e92fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55edd23df1860c49304063d244167e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac55edd23df1860c49304063d244167e1"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#ac55edd23df1860c49304063d244167e1">Epsilon</a></td></tr>
<tr class="memdesc:ac55edd23df1860c49304063d244167e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">the linearization error <img class="formulaInl" alt="$\epsilon_i$" src="form_96.png"/> of <img class="formulaInl" alt="$d_i$" src="form_59.png"/> at <img class="formulaInl" alt="$\bar{\lambda}_i$" src="form_63.png"/> <br /></td></tr>
<tr class="separator:ac55edd23df1860c49304063d244167e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf2fdc61fc9cf8683027b7ca2591d6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cf2fdc61fc9cf8683027b7ca2591d6b"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a2cf2fdc61fc9cf8683027b7ca2591d6b">SigmaHat</a></td></tr>
<tr class="memdesc:a2cf2fdc61fc9cf8683027b7ca2591d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">the linearization error <img class="formulaInl" alt="$ \hat{\alpha}_i $" src="form_97.png"/> of <img class="formulaInl" alt="$g_i$" src="form_67.png"/> with respect to <img class="formulaInl" alt="$\hat{\lambda}_i$" src="form_98.png"/> <br /></td></tr>
<tr class="separator:a2cf2fdc61fc9cf8683027b7ca2591d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d45bb8add429ee1663016e4e022be5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8d45bb8add429ee1663016e4e022be5"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#ad8d45bb8add429ee1663016e4e022be5">HatEpsilon</a></td></tr>
<tr class="memdesc:ad8d45bb8add429ee1663016e4e022be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">the linearization error <img class="formulaInl" alt="$ \hat{\epsilon}_i $" src="form_99.png"/> of <img class="formulaInl" alt="$d_i$" src="form_59.png"/> with respect to <img class="formulaInl" alt="$\hat{\lambda}_i$" src="form_98.png"/> <br /></td></tr>
<tr class="separator:ad8d45bb8add429ee1663016e4e022be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604169e6e8d30e16deaf7d28a89eb44e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a604169e6e8d30e16deaf7d28a89eb44e"></a>
Index_Set&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a604169e6e8d30e16deaf7d28a89eb44e">SGBase</a></td></tr>
<tr class="memdesc:a604169e6e8d30e16deaf7d28a89eb44e"><td class="mdescLeft">&#160;</td><td class="mdescRight">the set of indices of Gi[ wFi ]( Lambda ) <br /></td></tr>
<tr class="separator:a604169e6e8d30e16deaf7d28a89eb44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221ac7d18f33270b4ef7f4586f5ebc50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a221ac7d18f33270b4ef7f4586f5ebc50"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a221ac7d18f33270b4ef7f4586f5ebc50">MaxName</a></td></tr>
<tr class="memdesc:a221ac7d18f33270b4ef7f4586f5ebc50"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum name to be used in FiOracle-&gt;SetGiName() <br /></td></tr>
<tr class="separator:a221ac7d18f33270b4ef7f4586f5ebc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc14d9071a092880378d86843d829252"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc14d9071a092880378d86843d829252"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#afc14d9071a092880378d86843d829252">NrmGi</a></td></tr>
<tr class="memdesc:afc14d9071a092880378d86843d829252"><td class="mdescLeft">&#160;</td><td class="mdescRight">the (squared) subgradient's norm <br /></td></tr>
<tr class="separator:afc14d9071a092880378d86843d829252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a2909d4ca285c1ae305a2002ea6e4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83a2909d4ca285c1ae305a2002ea6e4e"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a83a2909d4ca285c1ae305a2002ea6e4e">NrmDir</a></td></tr>
<tr class="memdesc:a83a2909d4ca285c1ae305a2002ea6e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">the (squared) direction's norm <br /></td></tr>
<tr class="separator:a83a2909d4ca285c1ae305a2002ea6e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcc51ad17362aa7a7bedd34dc33eb6e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affcc51ad17362aa7a7bedd34dc33eb6e"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#affcc51ad17362aa7a7bedd34dc33eb6e">dGk</a></td></tr>
<tr class="memdesc:affcc51ad17362aa7a7bedd34dc33eb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">scalar product between <img class="formulaInl" alt="$d_i$" src="form_59.png"/> and <img class="formulaInl" alt="$g_i$" src="form_67.png"/> <br /></td></tr>
<tr class="separator:affcc51ad17362aa7a7bedd34dc33eb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39757987fa50984a045584405f345fef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39757987fa50984a045584405f345fef"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a39757987fa50984a045584405f345fef">dM1Gk</a></td></tr>
<tr class="memdesc:a39757987fa50984a045584405f345fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">scalar product between <img class="formulaInl" alt="$d_{i-1}$" src="form_68.png"/> and <img class="formulaInl" alt="$g_i$" src="form_67.png"/> <br /></td></tr>
<tr class="separator:a39757987fa50984a045584405f345fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566285d3c7a54180fe19b96ef5e48741"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a566285d3c7a54180fe19b96ef5e48741"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a566285d3c7a54180fe19b96ef5e48741">dM1GkDone</a></td></tr>
<tr class="memdesc:a566285d3c7a54180fe19b96ef5e48741"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if the scalar product <img class="formulaInl" alt="$d_{i-1}^{\top} g_i$" src="form_100.png"/> has been computed <br /></td></tr>
<tr class="separator:a566285d3c7a54180fe19b96ef5e48741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5327c3bb05a165beac89fe10d9cddc7f"><td class="memItemLeft" align="right" valign="top">Index_Set&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a5327c3bb05a165beac89fe10d9cddc7f">CnstBeg</a></td></tr>
<tr class="memdesc:a5327c3bb05a165beac89fe10d9cddc7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">CnstBeg and CnstVol point respectively to a MaxNConst-vector of Index and HpNum, while CnstNxt is a MaxNumVar-vector of SIndex.  <a href="#a5327c3bb05a165beac89fe10d9cddc7f">More...</a><br /></td></tr>
<tr class="separator:a5327c3bb05a165beac89fe10d9cddc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac508b5c9944a8df030a590dcc80341"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ac508b5c9944a8df030a590dcc80341"></a>
HpRow&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a3ac508b5c9944a8df030a590dcc80341">CnstVol</a></td></tr>
<tr class="memdesc:a3ac508b5c9944a8df030a590dcc80341"><td class="mdescLeft">&#160;</td><td class="mdescRight">the MaxNConst-vector of HpNum containing the rhs of the knapsack Constraints <br /></td></tr>
<tr class="separator:a3ac508b5c9944a8df030a590dcc80341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a01fd0b5b16c545294104b3937bbdce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a01fd0b5b16c545294104b3937bbdce"></a>
SIndex_Set&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a4a01fd0b5b16c545294104b3937bbdce">CnstNxt</a></td></tr>
<tr class="memdesc:a4a01fd0b5b16c545294104b3937bbdce"><td class="mdescLeft">&#160;</td><td class="mdescRight">the MaxNumVar-vector of SIndex saying the next variable appearing in a knapsack constraint [see above] <br /></td></tr>
<tr class="separator:a4a01fd0b5b16c545294104b3937bbdce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924facbcb433400b60b936589e614165"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a924facbcb433400b60b936589e614165"></a>
LMRow&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a924facbcb433400b60b936589e614165">ub</a></td></tr>
<tr class="memdesc:a924facbcb433400b60b936589e614165"><td class="mdescLeft">&#160;</td><td class="mdescRight">upper bounds on the variables <br /></td></tr>
<tr class="separator:a924facbcb433400b60b936589e614165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df01bca884258d749202f11ed80e995"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0df01bca884258d749202f11ed80e995"></a>
LMRow&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a0df01bca884258d749202f11ed80e995">lb</a></td></tr>
<tr class="memdesc:a0df01bca884258d749202f11ed80e995"><td class="mdescLeft">&#160;</td><td class="mdescRight">lower bounds on the variables <br /></td></tr>
<tr class="separator:a0df01bca884258d749202f11ed80e995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0992b4726dbf5981c592043b081d4556"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0992b4726dbf5981c592043b081d4556"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a0992b4726dbf5981c592043b081d4556">ZeroComp</a></td></tr>
<tr class="memdesc:a0992b4726dbf5981c592043b081d4556"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if Fi() comes with the 0-th component <br /></td></tr>
<tr class="separator:a0992b4726dbf5981c592043b081d4556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cefcf56ad995dec414934ca0698947d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cefcf56ad995dec414934ca0698947d"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a4cefcf56ad995dec414934ca0698947d">NItIncr</a></td></tr>
<tr class="memdesc:a4cefcf56ad995dec414934ca0698947d"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of incremental iterations after an outer iteration <br /></td></tr>
<tr class="separator:a4cefcf56ad995dec414934ca0698947d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef37011e059f0be80e12f10a590f6e29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef37011e059f0be80e12f10a590f6e29"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#aef37011e059f0be80e12f10a590f6e29">InnIter</a></td></tr>
<tr class="memdesc:aef37011e059f0be80e12f10a590f6e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">if true, the current iteration is an inner one <br /></td></tr>
<tr class="separator:aef37011e059f0be80e12f10a590f6e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69e3c00709b6085d1e1a3ef4eaed54c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af69e3c00709b6085d1e1a3ef4eaed54c"></a>
vector&lt; Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#af69e3c00709b6085d1e1a3ef4eaed54c">Seq</a></td></tr>
<tr class="memdesc:af69e3c00709b6085d1e1a3ef4eaed54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector containing the randomly shuffled components of the function <img class="formulaInl" alt="$f$" src="form_72.png"/> <br /></td></tr>
<tr class="separator:af69e3c00709b6085d1e1a3ef4eaed54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30290cf64fe12c1d416a28ac492ae4bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30290cf64fe12c1d416a28ac492ae4bf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a30290cf64fe12c1d416a28ac492ae4bf">DirPos</a></td></tr>
<tr class="memdesc:a30290cf64fe12c1d416a28ac492ae4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicates where the direction <img class="formulaInl" alt="$d_i$" src="form_59.png"/> in located in the oracle <br /></td></tr>
<tr class="separator:a30290cf64fe12c1d416a28ac492ae4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f9fe93370b98d040bb276472ac31fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3f9fe93370b98d040bb276472ac31fe"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#aa3f9fe93370b98d040bb276472ac31fe">CSSCntr</a></td></tr>
<tr class="memdesc:aa3f9fe93370b98d040bb276472ac31fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">counter of consecutive SS <br /></td></tr>
<tr class="separator:aa3f9fe93370b98d040bb276472ac31fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88aec9e8a8a8a6ce8e228260f1ad2e3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88aec9e8a8a8a6ce8e228260f1ad2e3c"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a88aec9e8a8a8a6ce8e228260f1ad2e3c">CNSCntr</a></td></tr>
<tr class="memdesc:a88aec9e8a8a8a6ce8e228260f1ad2e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">counter of consecutive NS <br /></td></tr>
<tr class="separator:a88aec9e8a8a8a6ce8e228260f1ad2e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58061d8ad7109350badd2562c23bd24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af58061d8ad7109350badd2562c23bd24"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#af58061d8ad7109350badd2562c23bd24">CSmallStep</a></td></tr>
<tr class="memdesc:af58061d8ad7109350badd2562c23bd24"><td class="mdescLeft">&#160;</td><td class="mdescRight">counter of consecutive <em>short</em> step <br /></td></tr>
<tr class="separator:af58061d8ad7109350badd2562c23bd24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a51cf4a1bb9a39e8ac6927d013ae2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09a51cf4a1bb9a39e8ac6927d013ae2d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a09a51cf4a1bb9a39e8ac6927d013ae2d">DoSS</a></td></tr>
<tr class="memdesc:a09a51cf4a1bb9a39e8ac6927d013ae2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SS vs NS. <br /></td></tr>
<tr class="separator:a09a51cf4a1bb9a39e8ac6927d013ae2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9040eafef7472ddeab108e810e1a057e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9040eafef7472ddeab108e810e1a057e"></a>
<a class="el" href="classFiOracle.html#a04867eec1c7917816fb94b85c12ba6db">FiOracle::FiStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a9040eafef7472ddeab108e810e1a057e">fs</a></td></tr>
<tr class="memdesc:a9040eafef7472ddeab108e810e1a057e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> status. <br /></td></tr>
<tr class="separator:a9040eafef7472ddeab108e810e1a057e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7deac8450a4464bb5a5790a6d0e4a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c7deac8450a4464bb5a5790a6d0e4a2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a6c7deac8450a4464bb5a5790a6d0e4a2">EmptySet</a></td></tr>
<tr class="memdesc:a6c7deac8450a4464bb5a5790a6d0e4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">true, if the feasible set is empty <br /></td></tr>
<tr class="separator:a6c7deac8450a4464bb5a5790a6d0e4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classNDOSolver"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classNDOSolver')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classNDOSolver.html">NDOSolver</a></td></tr>
<tr class="memitem:a7351bcdcd41c5758e4298658a78b444f inherit pro_attribs_classNDOSolver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7351bcdcd41c5758e4298658a78b444f"></a>
<a class="el" href="classFiOracle.html">FiOracle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a7351bcdcd41c5758e4298658a78b444f">Oracle</a></td></tr>
<tr class="memdesc:a7351bcdcd41c5758e4298658a78b444f inherit pro_attribs_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">(pointer to) the oracle for Fi <br /></td></tr>
<tr class="separator:a7351bcdcd41c5758e4298658a78b444f inherit pro_attribs_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036194ebd68cb26950274df64cd45628 inherit pro_attribs_classNDOSolver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a036194ebd68cb26950274df64cd45628"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a036194ebd68cb26950274df64cd45628">MaxIter</a></td></tr>
<tr class="memdesc:a036194ebd68cb26950274df64cd45628 inherit pro_attribs_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of iterations <br /></td></tr>
<tr class="separator:a036194ebd68cb26950274df64cd45628 inherit pro_attribs_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac907ffee42fdc8aaf6b31784ecc5a3e7 inherit pro_attribs_classNDOSolver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac907ffee42fdc8aaf6b31784ecc5a3e7"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#ac907ffee42fdc8aaf6b31784ecc5a3e7">MaxTime</a></td></tr>
<tr class="memdesc:ac907ffee42fdc8aaf6b31784ecc5a3e7 inherit pro_attribs_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum time (in seconds) for each call to <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a> <br /></td></tr>
<tr class="separator:ac907ffee42fdc8aaf6b31784ecc5a3e7 inherit pro_attribs_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4fd0fd9cda5b9f4570d098b146dd11 inherit pro_attribs_classNDOSolver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf4fd0fd9cda5b9f4570d098b146dd11"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#aaf4fd0fd9cda5b9f4570d098b146dd11">tStar</a></td></tr>
<tr class="memdesc:aaf4fd0fd9cda5b9f4570d098b146dd11 inherit pro_attribs_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">optimality related parameter: "scaling" of Fi <br /></td></tr>
<tr class="separator:aaf4fd0fd9cda5b9f4570d098b146dd11 inherit pro_attribs_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6602ddb4e1219bc0ea9816ff87138e inherit pro_attribs_classNDOSolver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b6602ddb4e1219bc0ea9816ff87138e"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a8b6602ddb4e1219bc0ea9816ff87138e">EpsLin</a></td></tr>
<tr class="memdesc:a8b6602ddb4e1219bc0ea9816ff87138e inherit pro_attribs_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">optimality related parameter: relative precision <br /></td></tr>
<tr class="separator:a8b6602ddb4e1219bc0ea9816ff87138e inherit pro_attribs_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885fdb020437994e0cc2a7681bcafe95 inherit pro_attribs_classNDOSolver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a885fdb020437994e0cc2a7681bcafe95"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a885fdb020437994e0cc2a7681bcafe95">EInit</a></td></tr>
<tr class="memdesc:a885fdb020437994e0cc2a7681bcafe95 inherit pro_attribs_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">precision-related parameter: initial precision <br /></td></tr>
<tr class="separator:a885fdb020437994e0cc2a7681bcafe95 inherit pro_attribs_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc932a683e4b168be22383a2f04f68e inherit pro_attribs_classNDOSolver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacc932a683e4b168be22383a2f04f68e"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#aacc932a683e4b168be22383a2f04f68e">EFnal</a></td></tr>
<tr class="memdesc:aacc932a683e4b168be22383a2f04f68e inherit pro_attribs_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">precision-related parameter: final precision <br /></td></tr>
<tr class="separator:aacc932a683e4b168be22383a2f04f68e inherit pro_attribs_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7209661fab2496b25571dffb49253edc inherit pro_attribs_classNDOSolver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7209661fab2496b25571dffb49253edc"></a>
HpNum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a7209661fab2496b25571dffb49253edc">EDcrs</a></td></tr>
<tr class="memdesc:a7209661fab2496b25571dffb49253edc inherit pro_attribs_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">precision-related parameter: rate of decrease <br /></td></tr>
<tr class="separator:a7209661fab2496b25571dffb49253edc inherit pro_attribs_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40380e77353e860fde1eaf0061053d46 inherit pro_attribs_classNDOSolver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40380e77353e860fde1eaf0061053d46"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a40380e77353e860fde1eaf0061053d46">EStps</a></td></tr>
<tr class="memdesc:a40380e77353e860fde1eaf0061053d46 inherit pro_attribs_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">precision-related parameter: number of steps <br /></td></tr>
<tr class="separator:a40380e77353e860fde1eaf0061053d46 inherit pro_attribs_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefea06e4a67c014c2f107bec27479021 inherit pro_attribs_classNDOSolver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefea06e4a67c014c2f107bec27479021"></a>
<a class="el" href="classNDOSolver.html#a3028873c2d546da98905c33628e01442">NDOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#aefea06e4a67c014c2f107bec27479021">Result</a></td></tr>
<tr class="memdesc:aefea06e4a67c014c2f107bec27479021 inherit pro_attribs_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">result of the latest call to <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a> <br /></td></tr>
<tr class="separator:aefea06e4a67c014c2f107bec27479021 inherit pro_attribs_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8543193099c64b041d5ad1cc2ace45 inherit pro_attribs_classNDOSolver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa8543193099c64b041d5ad1cc2ace45"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#afa8543193099c64b041d5ad1cc2ace45">NumVar</a></td></tr>
<tr class="memdesc:afa8543193099c64b041d5ad1cc2ace45 inherit pro_attribs_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">(current) number of variables <br /></td></tr>
<tr class="separator:afa8543193099c64b041d5ad1cc2ace45 inherit pro_attribs_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec8d60a9d34695b3b410f3aeb37ff22 inherit pro_attribs_classNDOSolver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ec8d60a9d34695b3b410f3aeb37ff22"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a2ec8d60a9d34695b3b410f3aeb37ff22">NrFi</a></td></tr>
<tr class="memdesc:a2ec8d60a9d34695b3b410f3aeb37ff22 inherit pro_attribs_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of components of Fi() <br /></td></tr>
<tr class="separator:a2ec8d60a9d34695b3b410f3aeb37ff22 inherit pro_attribs_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55215bb952726160569746ad047260c2 inherit pro_attribs_classNDOSolver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55215bb952726160569746ad047260c2"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a55215bb952726160569746ad047260c2">SCalls</a></td></tr>
<tr class="memdesc:a55215bb952726160569746ad047260c2 inherit pro_attribs_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">nuber of calls to <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff" title="Tries to minimize the function provided by the FiOracle. ">Solve()</a> (the current included) <br /></td></tr>
<tr class="separator:a55215bb952726160569746ad047260c2 inherit pro_attribs_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9716eb40fc916cad7d66d31cb22be80 inherit pro_attribs_classNDOSolver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9716eb40fc916cad7d66d31cb22be80"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#ac9716eb40fc916cad7d66d31cb22be80">ParIter</a></td></tr>
<tr class="memdesc:ac9716eb40fc916cad7d66d31cb22be80 inherit pro_attribs_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">nuber of iterations in this run <br /></td></tr>
<tr class="separator:ac9716eb40fc916cad7d66d31cb22be80 inherit pro_attribs_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668f46932f6eff896863aa0adeb69e63 inherit pro_attribs_classNDOSolver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a668f46932f6eff896863aa0adeb69e63"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a668f46932f6eff896863aa0adeb69e63">FiEvaltns</a></td></tr>
<tr class="memdesc:a668f46932f6eff896863aa0adeb69e63 inherit pro_attribs_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of Fi() calls <br /></td></tr>
<tr class="separator:a668f46932f6eff896863aa0adeb69e63 inherit pro_attribs_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7550cf091be6c4eb82484037ea3d3cd6 inherit pro_attribs_classNDOSolver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7550cf091be6c4eb82484037ea3d3cd6"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a7550cf091be6c4eb82484037ea3d3cd6">GiEvaltns</a></td></tr>
<tr class="memdesc:a7550cf091be6c4eb82484037ea3d3cd6 inherit pro_attribs_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of Gi() calls <br /></td></tr>
<tr class="separator:a7550cf091be6c4eb82484037ea3d3cd6 inherit pro_attribs_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51cd6e17405ebbcefa509e43584d04a inherit pro_attribs_classNDOSolver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad51cd6e17405ebbcefa509e43584d04a"></a>
ostream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#ad51cd6e17405ebbcefa509e43584d04a">NDOLog</a></td></tr>
<tr class="memdesc:ad51cd6e17405ebbcefa509e43584d04a inherit pro_attribs_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">the output stream object for log purposes <br /></td></tr>
<tr class="separator:ad51cd6e17405ebbcefa509e43584d04a inherit pro_attribs_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe5747970ad355d24d3b732b3d962ae inherit pro_attribs_classNDOSolver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fe5747970ad355d24d3b732b3d962ae"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#a6fe5747970ad355d24d3b732b3d962ae">NDOLLvl</a></td></tr>
<tr class="memdesc:a6fe5747970ad355d24d3b732b3d962ae inherit pro_attribs_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">the "level of verbosity" of the log <br /></td></tr>
<tr class="separator:a6fe5747970ad355d24d3b732b3d962ae inherit pro_attribs_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccb3e3e5514571e76e8bf5d87b104a4 inherit pro_attribs_classNDOSolver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adccb3e3e5514571e76e8bf5d87b104a4"></a>
OPTtimers *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNDOSolver.html#adccb3e3e5514571e76e8bf5d87b104a4">NDOt</a></td></tr>
<tr class="memdesc:adccb3e3e5514571e76e8bf5d87b104a4 inherit pro_attribs_classNDOSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">OPTtimer for timing purposes. <br /></td></tr>
<tr class="separator:adccb3e3e5514571e76e8bf5d87b104a4 inherit pro_attribs_classNDOSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Friend classes</div></td></tr>
<tr class="memitem:a72e6f2cda99bb107508fe1f30daf354c"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubGrad.html#a72e6f2cda99bb107508fe1f30daf354c">Stepsize</a></td></tr>
<tr class="memdesc:a72e6f2cda99bb107508fe1f30daf354c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The classes <a class="el" href="classStepsize.html" title="The class Stepsize provides an interface for the stepsize rule, to be used in the SubGrad solver [see...">Stepsize</a> and <a class="el" href="classDeflection.html" title="The class Deflection provides an interface for the deflection rule (DR), to be used in the SubGrad so...">Deflection</a> are "friends" of <a class="el" href="classSubGrad.html" title="The SubGrad class implements the NDOSolver interface for NonDifferentiable Optimization Solvers [see ...">SubGrad</a>.  <a href="#a72e6f2cda99bb107508fe1f30daf354c">More...</a><br /></td></tr>
<tr class="separator:a72e6f2cda99bb107508fe1f30daf354c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209ea14177543d6416c78e0a2997081d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a209ea14177543d6416c78e0a2997081d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Deflection</b></td></tr>
<tr class="separator:a209ea14177543d6416c78e0a2997081d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <code><a class="el" href="classSubGrad.html" title="The SubGrad class implements the NDOSolver interface for NonDifferentiable Optimization Solvers [see ...">SubGrad</a></code> class implements the <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> interface for NonDifferentiable Optimization Solvers [see <a class="el" href="NDOSlver_8h.html" title="Definition of the abstract base class NDOSolver, which defines the interface for convex minimization ...">NDOSlver.h</a>], using a unified subgradient-type algorithm as described in: </p>
<p>A. Frangioni, E. Gorgone, B. Gendron. <em>On the Computational Efficiency of Subgradient Methods: A Case Study in Combinatorial Optimization</em>. Technical Report CIRRELT- 2015-41, Interuniversity Research Centre on Enterprise Networks, Logistics and Transportation (CIRRELT), Montreal, Canada, 2015</p>
<p>This is in fact a subgradient method (SM) based on abstract rules for the computation of both the <em>stepsize</em> <img class="formulaInl" alt="$\nu_i$" src="form_42.png"/> and the <em>direction</em> <img class="formulaInl" alt="$d_i$" src="form_59.png"/>. The algorithm in employs the simple recurrence formula: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \breve{\lambda}_{i+1} \gets \bar{\lambda}_i - \nu_i d_i \quad , \quad \lambda_{i+1} \gets {\rm P}_{\Lambda}( \, \breve{\lambda}_{i+1} \, ) \]" src="form_60.png"/>
</p>
<p> where <img class="formulaInl" alt="${\rm P}$" src="form_61.png"/> denotes the <em>orthogonal projection</em> on <img class="formulaInl" alt="$\bar{\Lambda}$" src="form_62.png"/>. The point <img class="formulaInl" alt="$\bar{\lambda}_i$" src="form_63.png"/> is not necessarily the current iterate. For instance, it could be required that <img class="formulaInl" alt="$\bar{\lambda}_{i}$" src="form_64.png"/> remains unchanged if an ascent direction occurs. It recalls somehow the <em>stability center</em> of the bundle methods.</p>
<p>The class relies on the objects of the friend classes <code><a class="el" href="classStepsize.html" title="The class Stepsize provides an interface for the stepsize rule, to be used in the SubGrad solver [see...">Stepsize</a></code> and <code><a class="el" href="classDeflection.html" title="The class Deflection provides an interface for the deflection rule (DR), to be used in the SubGrad so...">Deflection</a></code>, which have to return, respectively, the stepsize <img class="formulaInl" alt="$\nu_i$" src="form_42.png"/> and the deflection coefficient <img class="formulaInl" alt="$\alpha_i$" src="form_56.png"/>. The latter scalar number defines in turn the direction <img class="formulaInl" alt="$d_i$" src="form_59.png"/>, i.e.. <img class="formulaInl" alt="$ d_i = \alpha_i g_i + (1-\alpha_i)d_{i-1} $" src="form_65.png"/>. These abstract classes allow us to derive several variants of the method. For the sake of simplicity, the original SM characterized by <img class="formulaInl" alt="$\alpha_i = 1$" src="form_66.png"/> is performed setting the pointer to the object <a class="el" href="classDeflection.html" title="The class Deflection provides an interface for the deflection rule (DR), to be used in the SubGrad so...">Deflection</a> to NULL.</p>
<p>The class also includes the <em>incremental</em> variant for when the function to be maximized is composed by a sum of different functions. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a88e436c6ce2370166c6b7f5e23db6079"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSubGrad.html#a88e436c6ce2370166c6b7f5e23db6079">SGParam</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public enum which "extends" the enum <a class="el" href="classNDOSolver.html#a3e2b890b8fa2e3dcf9cff9b973b81108" title="Public enum which is used in (the two overloaded versions of) SetPar() [see below]. ">NDOSolver::NDOParam</a> for handling the SubGrad-specific algorithmic parameters in (the two overloaded versions of) <a class="el" href="classSubGrad.html#a23766f6f13e9580b2ec69f429788a1a6" title="Extends NDOSolver::SetPar( , cIndex ) for handling the SubGrad-specific parameters; the enum SGParam ...">SubGrad::SetPar()</a> [see below]. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab0b8fa974c1e889b7106eb7dca69cd6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSubGrad.html">SubGrad</a> </td>
          <td>(</td>
          <td class="paramtype">istream *&#160;</td>
          <td class="paramname"><em>iStrm</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor of the class. </p>
<p>The parameter `iStrm', if provided, is taken as a pointer to a istream from which the algorithmic parameters for the subgradient algorithm are sequentially read in the following order. Each parameter must be placed at the beginning of a separate line, max 255 characters long, with all the rest of the line up to the first newline character (apart from a separating whitespace) being available for comments. Any line whose first character is '#' and any blank line is ignored. If 0 is passed, the file ends before reaching a given parameter, or some parameter is in the wrong format, each non-specified parameter is given a default value, shown in [] below.</p>
<p>`iStrm' is passed to the constructor of <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a> [see NDOSolver.h], which reads the general algorithmic parameters out of it; since the constructor <a class="el" href="classSubGrad.html" title="The SubGrad class implements the NDOSolver interface for NonDifferentiable Optimization Solvers [see ...">SubGrad</a> is executed after the one of <a class="el" href="classNDOSolver.html" title="The class NDOSolver provides a general interface between convex (NonDifferentiable) optimization solv...">NDOSolver</a>, the following parameters specific for the <a class="el" href="classSubGrad.html" title="The SubGrad class implements the NDOSolver interface for NonDifferentiable Optimization Solvers [see ...">SubGrad</a> have to be found in the stream <em>after</em> those of the base class:</p>
<ol type="1">
<li><p class="startli">Index SGPar1 [0] The direction <img class="formulaInl" alt="$d_i$" src="form_59.png"/> is assumed to be such a convex combination of the subgradient <img class="formulaInl" alt="$g_i$" src="form_67.png"/> and the direction <img class="formulaInl" alt="$d_{i-1}$" src="form_68.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ d_i = \alpha_i g_i + ( 1 - \alpha_i ) d_{i-1} \]" src="form_69.png"/>
</p>
<p> SGPar1 selects among <img class="formulaInl" alt="$\{d_i,d_{i-1},g_i\} $" src="form_70.png"/> the vector(s) to be projected over the tangent cone at <img class="formulaInl" alt="$\bar{\lambda}_i$" src="form_63.png"/>. The field SGPar1 is coded bit-wise, in the following way:</p><ul>
<li>bit 0: if 1 the subgradient <img class="formulaInl" alt="$g_i$" src="form_67.png"/> is projected, 0 otherwise;</li>
<li>bit 1: if 1 the direction <img class="formulaInl" alt="$d_{i-1}$" src="form_68.png"/> is projected, 0 otherwise;</li>
<li>bit 2: if 1 the <img class="formulaInl" alt="$d_{i}$" src="form_71.png"/> is projected, 0 otherwise;</li>
</ul>
<p class="startli">The setting (+7) is redundant. In fact, it is equivalent to (+3) because <img class="formulaInl" alt="$d_i$" src="form_59.png"/>, being a (convex) combination of <img class="formulaInl" alt="$g_i$" src="form_67.png"/> and <img class="formulaInl" alt="$d_{i-1}$" src="form_68.png"/>, coincides with its projection.</p>
</li>
<li>HpNum SGPar2 [0] To manage the incremental iterations. A sequence of incremental (or inner) iterations NItIncr performed along single-component subgradients could occur before a full (or normal, or outer) iteration. The number NItIncr is obtained as NItIncr = ceil( &lt;Number of components of <img class="formulaInl" alt="$f$" src="form_72.png"/>&gt; * SGPar2 ), where the number of components of <img class="formulaInl" alt="$f$" src="form_72.png"/> includes the 0-th component, and then not necessarily coincides with NrFi. Finally, the incremental variant only works with no deflection object, i.e setting deflection = NULL, because we do not manage with the sum of subgradients of different components.</li>
<li>Index SGPar3 [1] The convergence scheme. This field is coded bit-wise in the following way:<ul>
<li>bit 0: 1 if the safe rule is used, 0 otherwise</li>
<li>bit 1: 1 for the stepsize-restricted scheme, 0 for the deflection-restricted scheme.</li>
</ul>
</li>
<li>bool SGPar4 [true] SGPar4 enables the use of <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hat{\lambda}_{i+1} = \alpha_{i+1}\lambda_i + ( 1 - \alpha_{i+1} ) \hat{\lambda}_i \]" src="form_73.png"/>
</p>
 which could have a certain influence on the stopping test [see <a class="el" href="classSubGrad.html#a39ed499a9e05bdc04d3d6d00c2ad82c7" title="Returns true if the solution  is -optimal (relative), being  set to EpsLin. ">IsOptimal()</a>].</li>
<li>Index SGPar5 [0] The seed value used in a call to srand. The components are re-shuffled in the incrmental variant, and a random number generator is used. </li>
</ol>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a90b1859cfc4994dd5989175e22c53f4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetStepsize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classStepsize.html">Stepsize</a> *&#160;</td>
          <td class="paramname"><em>STP</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives to the <code><a class="el" href="classSubGrad.html" title="The SubGrad class implements the NDOSolver interface for NonDifferentiable Optimization Solvers [see ...">SubGrad</a></code> object a pointer to an object of class <code><a class="el" href="classStepsize.html" title="The class Stepsize provides an interface for the stepsize rule, to be used in the SubGrad solver [see...">Stepsize</a></code> that will be used to provide <img class="formulaInl" alt="$\nu_i$" src="form_42.png"/> during the subgradient algorithm. </p>
<p>The <a class="el" href="classStepsize.html" title="The class Stepsize provides an interface for the stepsize rule, to be used in the SubGrad solver [see...">Stepsize</a> object can be changed during the life of a <a class="el" href="classSubGrad.html" title="The SubGrad class implements the NDOSolver interface for NonDifferentiable Optimization Solvers [see ...">SubGrad</a> object, but this change clearly forces the reset of all the information about the function accumulated so far. Passing a 0 pointer does exactly this job. </p>

</div>
</div>
<a class="anchor" id="a98144b7732469933ebc2bb86bef49308"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetDeflection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDeflection.html">Deflection</a> *&#160;</td>
          <td class="paramname"><em>Vol</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives to the <code><a class="el" href="classSubGrad.html" title="The SubGrad class implements the NDOSolver interface for NonDifferentiable Optimization Solvers [see ...">SubGrad</a></code> object a pointer to an object of class <code><a class="el" href="classDeflection.html" title="The class Deflection provides an interface for the deflection rule (DR), to be used in the SubGrad so...">Deflection</a></code> that will be used to provide a deflection coefficient <img class="formulaInl" alt="$ \alpha_i$" src="form_74.png"/> . </p>
<p>The <a class="el" href="classDeflection.html" title="The class Deflection provides an interface for the deflection rule (DR), to be used in the SubGrad so...">Deflection</a> object can be changed during the life of a <a class="el" href="classSubGrad.html" title="The SubGrad class implements the NDOSolver interface for NonDifferentiable Optimization Solvers [see ...">SubGrad</a> object, but this change clearly forces the reset of all the information about the function accumulated so far. Passing a 0 pointer does exactly this job.</p>
<p>In addition, 0 pointer means that the deflection coefficient is kept to 1, namely <img class="formulaInl" alt="$\alpha_i = 1$" src="form_66.png"/>. </p>

</div>
</div>
<a class="anchor" id="a6ad242ca0d8c2e8d21342d2057bdfca3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetQKNP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCQKnPClass__di__unipi__it_1_1CQKnPClass.html">CQKnPClass</a> *&#160;</td>
          <td class="paramname"><em>KNP</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives to the <a class="el" href="classSubGrad.html" title="The SubGrad class implements the NDOSolver interface for NonDifferentiable Optimization Solvers [see ...">SubGrad</a> object a pointer to an object of class CQKnPClass that will be used as quadratic knapsack solver during the subgradient algorithm. </p>
<p>CQKnPClass object is employed to project the subgradient/direction when the projection problem is a continuous quadratic knapsack one. Moreover, the data of the problem are fixed just before the projection, hence no information is kept in the Subgradient method.</p>
<p>The CQKnPClass object can be changed during the life of a <a class="el" href="classSubGrad.html" title="The SubGrad class implements the NDOSolver interface for NonDifferentiable Optimization Solvers [see ...">SubGrad</a> object, but this change clearly implies that the prior object must be discharged. Passing a 0 pointer does exactly this job.</p>
<p>The default implementation assigns zero to the pointer of the CQKnPClass object directly in the constructor. In fact, CQKnPClass solver comes be helpful whenever in the feasible set the knapsack constraints appear. In contrast to what happens in both <a class="el" href="classSubGrad.html#a90b1859cfc4994dd5989175e22c53f4e" title="Gives to the SubGrad object a pointer to an object of class Stepsize that will be used to provide  du...">SetStepsize()</a> and <a class="el" href="classSubGrad.html#a98144b7732469933ebc2bb86bef49308" title="Gives to the SubGrad object a pointer to an object of class Deflection that will be used to provide a...">SetDeflection()</a>, the call to the function <a class="el" href="classSubGrad.html#a6ad242ca0d8c2e8d21342d2057bdfca3" title="Gives to the SubGrad object a pointer to an object of class CQKnPClass that will be used as quadratic...">SetQKNP()</a> is mandatory only if knapsack constraints take place in the feasible set. </p>

</div>
</div>
<a class="anchor" id="a23766f6f13e9580b2ec69f429788a1a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetPar </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>wp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extends NDOSolver::SetPar( , cIndex ) for handling the SubGrad-specific parameters; the enum SGParam is used (in the obvious way) for selecting the parameter to be set. </p>

<p>Reimplemented from <a class="el" href="classNDOSolver.html#a23766f6f13e9580b2ec69f429788a1a6">NDOSolver</a>.</p>

</div>
</div>
<a class="anchor" id="a7952ff5bfa959618fbb24cfe598b889a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetPar </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>wp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cHpNum&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extends NDOSolver::SetPar( , cHpNum ) for handling the SubGrad-specific parameters; the enum SGParam is used (in the obvious way) for selecting the parameter to be set. </p>

<p>Reimplemented from <a class="el" href="classNDOSolver.html#a7952ff5bfa959618fbb24cfe598b889a">NDOSolver</a>.</p>

</div>
</div>
<a class="anchor" id="ac25c49ef56af4e6166110cdf324f6b53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetPar </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>wp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change boolean algorithmic parameters of the <a class="el" href="classSubGrad.html" title="The SubGrad class implements the NDOSolver interface for NonDifferentiable Optimization Solvers [see ...">SubGrad</a> solver. </p>
<p>The enum SGParam [see above] is used for selecting the parameter to be set. </p>

</div>
</div>
<a class="anchor" id="abe58ac2f9c5ebae521b801c95beb8a3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetNDOLog </td>
          <td>(</td>
          <td class="paramtype">ostream *&#160;</td>
          <td class="paramname"><em>outs</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>lvl</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>lvl controls the "level of verbosity" of the code. </p>
<p>The first four bits of lvl have the following meaning:</p>
<ul>
<li>0 =&gt; no log at all (also assumed if log = 0);</li>
<li>1 =&gt; "basic" log: only the errors are reported;</li>
<li>2 =&gt; a detailed step-by-step log of the algorithm is displayed;</li>
<li>4 .. 15 unused, available to derived classes; </li>
</ul>

<p>Reimplemented from <a class="el" href="classNDOSolver.html#aa4834ac19cd934272935fccc6cebc207">NDOSolver</a>.</p>

</div>
</div>
<a class="anchor" id="a4abf45f1d94e4e30cdad148af0d69e71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNDOSolver.html#a3028873c2d546da98905c33628e01442">NDOStatus</a> Solve </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to minimize the function [see <a class="el" href="NDOSlver_8h.html" title="Definition of the abstract base class NDOSolver, which defines the interface for convex minimization ...">NDOSlver.h</a>]. </p>
<p>It implements the subgradient algorithm exploiting the protected methods <a class="el" href="classSubGrad.html#a237e3a167830fdb29a3f0fff486c0109" title="The method is used within Solve() [see above], and its job is to compute the direction  that appears ...">FormD()</a>, <a class="el" href="classSubGrad.html#ae83d20499268fe44df92a9908f4f5fde" title="The method is combined with FormD() [see above] to carry out the direction computation. ">SaveDir()</a>, <a class="el" href="classSubGrad.html#a8eeda37b978781a055c191f8de5a3f2d" title="After a (succesfull) call to FormD(), sets the new (unprojected) tentative point  as  Remark that the...">FormLambda1()</a>, <a class="el" href="classSubGrad.html#ada9fae89db1844e478bfee044c021b2c" title="Evaluates the function at the new point , i.e., , and it either computes a subgradient ...">FiAndGi()</a>, <a class="el" href="classSubGrad.html#abe7b43879f08b120019fc698eb71fdbc" title="Move the current point to . ">GotoLambda1()</a> [see below].</p>
<p>Returns if</p>
<ul>
<li>kOK optimization has been succesful: a solution that is "optimal" (w.r.t. the current parameters settings) has been found;</li>
<li>kUnbndd there has been an error in the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a>, i.e. Fi() has returned -HpINF, or the function is unbounded below: the latter case can be detected only if a lower bound on the min. value of <img class="formulaInl" alt="$f$" src="form_72.png"/> is available [see <a class="el" href="classFiOracle.html#a5deec7bb1a3f6dd38e937b1d10e302df" title="The function Fi to be minimized may be unbounded below, i.e., its infimum may be - INF...">FiOracle::GetMinusInfinity()</a>];</li>
<li>kUnfsbl the polyhedral set defined by the constraints is empty: in this case, the primal optimal solution is an unbounded <em>extreme ray</em> for the dual problem;</li>
<li>kStopped <a class="el" href="classSubGrad.html#a4abf45f1d94e4e30cdad148af0d69e71" title="Tries to minimize the function [see NDOSlver.h]. ">Solve()</a> has been stopped, either by <a class="el" href="classFiOracle.html#aad5c05cf616d9205ee6d83ecbc9fafc5" title="GetFiStatus() returns the internal status of the FiOracle object. ">FiOracle::GetFiStatus()</a> or because the stepsize has been "too small" during 100 consecutive outer iterations [or 100 * NrFi consecutive inner iterations];</li>
<li>kStpIter the max. number of iterations has been exhausted;</li>
<li>kStpTime the max. running time has been reached;</li>
<li>kError There have been some problem in the <a class="el" href="classFiOracle.html" title="The class FiOracle provides a standard interface between NDO solvers and the functions that they have...">FiOracle</a> that require to stop the optimization.</li>
</ul>
<p>As for kStopped, "too small" means that <img class="formulaInl" alt="$ \nu_i \leq 1e-8 * t^*$" src="form_75.png"/>, where <img class="formulaInl" alt="$ t^* $" src="form_76.png"/> is the optimality related parameter scaling Fi() [see <a class="el" href="NDOSlver_8h.html" title="Definition of the abstract base class NDOSolver, which defines the interface for convex minimization ...">NDOSlver.h</a>]. There is no reason, in principle, why we couldn't replace <img class="formulaInl" alt="$1e-8$" src="form_77.png"/> by a parameter, but in order to make the test easier this parameter has been fixed to <img class="formulaInl" alt="$1e-8$" src="form_77.png"/>. We also decided to replace by 100 the parameter saying how many outer iterations of consecutive small stepsizes are sufficient to stop the algorithm.</p>
<p>Note that, whatever the exit condition be, the current point is always available by calling <a class="el" href="classSubGrad.html#ad0efcd2dbcac404c154a9a25c17cb2cb" title="Returns a read-only pointer to the stability center . ">ReadSol()</a>, and its Fi() value by calling <a class="el" href="classSubGrad.html#a3551945ff40b2aea9cea17184b48dc0a" title="Independently from which &quot;component&quot; of Fi() is chosen, it returns the full function Fi at the  stabi...">ReadFiVal()</a> [see below]. </p>

<p>Implements <a class="el" href="classNDOSolver.html#a9739939325d67b1833dea468308451ff">NDOSolver</a>.</p>

</div>
</div>
<a class="anchor" id="a1ad42200b126f5251c20490db5b6e06a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ReSetAlg </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>RstLvl</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the internal state of the Subgradient algorithm. </p>
<p>Since several different things can be reset independently, RstLvl is coded bit-wise:</p>
<ul>
<li>bit 0: if 0 all the algorithmic parameters are reset to the default values read by the stream/set by <a class="el" href="classSubGrad.html#a23766f6f13e9580b2ec69f429788a1a6" title="Extends NDOSolver::SetPar( , cIndex ) for handling the SubGrad-specific parameters; the enum SGParam ...">SetPar()</a>, while if 1 they are left untouched;</li>
<li>bit 1: if 0 the current point is reset to the all-0 vector, while if 1 it is left untouched;</li>
<li>bit 2: if 0 the direction and the subgradient are removed, while if 1 they are left there;</li>
<li>bit 3: if 0 all the constraints are removed, while if 1 all of them are left there.</li>
<li>bit 4: if 0 the value of Fi() in the stability center is reset to INF (i.e., unknown), while if 1 it is left untouched. </li>
</ul>

<p>Reimplemented from <a class="el" href="classNDOSolver.html#aabda99af5786f0d0784342fa8b358bcb">NDOSolver</a>.</p>

</div>
</div>
<a class="anchor" id="ad214f4b3502ca5dd35f513eec1cd6251"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cLMRow ReadBestSol </td>
          <td>(</td>
          <td class="paramtype">cIndex_Set &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only pointer to the point having the lowest <img class="formulaInl" alt="$f$" src="form_72.png"/> value found so far [see below]. </p>

<p>Reimplemented from <a class="el" href="classNDOSolver.html#a257e10d1ab48238456040b025d55f3ea">NDOSolver</a>.</p>

</div>
</div>
<a class="anchor" id="a845913d16e9747aa92aff33076b22c15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HpNum ReadBestFiVal </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>wFi</em> = <code>Inf&lt;&#160;Index&#160;&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the best <img class="formulaInl" alt="$f$" src="form_72.png"/> value found so far. </p>
<p>Independently from which "component" of Fi() is chosen, it returns the full function. </p>

<p>Reimplemented from <a class="el" href="classNDOSolver.html#a2671fd0e3b342ab772548065e7a0e467">NDOSolver</a>.</p>

<p>Referenced by <a class="el" href="classColorTV.html#a4539b98684e6ddcb4395b034a8de0b38">ColorTV::ColorTV()</a>.</p>

</div>
</div>
<a class="anchor" id="ad0efcd2dbcac404c154a9a25c17cb2cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cLMRow ReadSol </td>
          <td>(</td>
          <td class="paramtype">cIndex_Set &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only pointer to the <em>stability center</em> <img class="formulaInl" alt="$\bar{\lambda}_i$" src="form_63.png"/>. </p>
<p>If <a class="el" href="classSubGrad.html#a4abf45f1d94e4e30cdad148af0d69e71" title="Tries to minimize the function [see NDOSlver.h]. ">Solve()</a> has returned a kOK and the tStar has been properly set, the point returned by <a class="el" href="classSubGrad.html#ad0efcd2dbcac404c154a9a25c17cb2cb" title="Returns a read-only pointer to the stability center . ">ReadSol()</a> - and, a fortiori, the one returned by <a class="el" href="classSubGrad.html#ad214f4b3502ca5dd35f513eec1cd6251" title="Returns a read-only pointer to the point having the lowest  value found so far [see below]...">ReadBestSol()</a> - is <img class="formulaInl" alt="$\epsilon$" src="form_78.png"/>-optimal. </p>

<p>Implements <a class="el" href="classNDOSolver.html#ac7dbf4642c4b4f22bff6dcf5e8d67264">NDOSolver</a>.</p>

</div>
</div>
<a class="anchor" id="a5be83d27ffbe363a589dd29a86a492a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HpNum ReadHatFiVal </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <img class="formulaInl" alt="$\hat{f}$" src="form_79.png"/>, if <img class="formulaInl" alt="$ \hat{\lambda}_i $" src="form_80.png"/> is kept in memory. </p>
<p>Otherwise it returns Inf&lt;HpNum&gt;(). </p>

</div>
</div>
<a class="anchor" id="a39ed499a9e05bdc04d3d6d00c2ad82c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsOptimal </td>
          <td>(</td>
          <td class="paramtype">HpNum&#160;</td>
          <td class="paramname"><em>eps</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the solution <img class="formulaInl" alt="$\bar{\lambda}_i$" src="form_63.png"/> is <img class="formulaInl" alt="$\epsilon$" src="form_78.png"/>-optimal (relative), being <img class="formulaInl" alt="$\epsilon $" src="form_81.png"/> set to EpsLin. </p>
<p>The parameter SGPar4 controls the linearization error to be used in the stopping condition:</p>
<ol type="1">
<li>SGPar4 = true: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ t^* \|d_i\| + \max\{ \hat{\epsilon}_i , \epsilon_i \} &lt;= \epsilon * max( 1 , |f_i^{rec}| ) \]" src="form_82.png"/>
</p>
</li>
<li><p class="startli">SGPar4 = false: The criteria is just </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ t^* \|d_i\| + \epsilon_i &lt;= \epsilon * max( 1 , |f_i^{rec}| ) \]" src="form_83.png"/>
</p>
<p class="startli">where <img class="formulaInl" alt="$ f^{rec}_i = \min \{ \, f_l \,:\, l = 1, \ldots, i \, \}$" src="form_84.png"/>, i.e. the <em> record value </em> on the optimum $f_*$ </p>
</li>
</ol>

</div>
</div>
<a class="anchor" id="ada9fae89db1844e478bfee044c021b2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FiAndGi </td>
          <td>(</td>
          <td class="paramtype">cIndex&#160;</td>
          <td class="paramname"><em>wFi</em> = <code>Inf&lt;&#160;Index&#160;&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the function at the new point <img class="formulaInl" alt="$\lambda_{i+1}$" src="form_85.png"/>, i.e., <img class="formulaInl" alt="$f(\lambda_{i+1})$" src="form_86.png"/>, and it either computes a subgradient <img class="formulaInl" alt="$g_{i+1} \in \partial f(\lambda_{i+1})$" src="form_87.png"/>, or, if the point is infeasible, a constraint. </p>

</div>
</div>
<a class="anchor" id="a237e3a167830fdb29a3f0fff486c0109"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FormD </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The method is used within <a class="el" href="classSubGrad.html#a4abf45f1d94e4e30cdad148af0d69e71" title="Tries to minimize the function [see NDOSlver.h]. ">Solve()</a> [see above], and its job is to compute the direction <img class="formulaInl" alt="$d_i$" src="form_59.png"/> that appears in the formula of <img class="formulaInl" alt="$\lambda_{i+1}$" src="form_85.png"/>. </p>
<p>The direction is actually saved after the variables generation because (i) the subgradient keeps in memory just the current direction (ii) by generating/removing variables the direction may quickly come to be deteriorated. When the variables generation is ended [see GetFiStatus() in <a class="el" href="FiOracle_8h.html" title="Definition of the abstract base class FiOracle, which sets the interface for the &quot;black boxes&quot; (oracl...">FiOracle.h</a>], <a class="el" href="classSubGrad.html#ae83d20499268fe44df92a9908f4f5fde" title="The method is combined with FormD() [see above] to carry out the direction computation. ">SaveDir()</a> must be called in order to update the direction.</p>
<p>In addition, the deflection coefficient is computed inside <a class="el" href="classSubGrad.html#a237e3a167830fdb29a3f0fff486c0109" title="The method is used within Solve() [see above], and its job is to compute the direction  that appears ...">FormD()</a>. As for the stepsize, the computation is performed within <a class="el" href="classSubGrad.html#a237e3a167830fdb29a3f0fff486c0109" title="The method is used within Solve() [see above], and its job is to compute the direction  that appears ...">FormD()</a> only if the scheme is <em>deflection-restricted</em>. </p>

</div>
</div>
<a class="anchor" id="ae83d20499268fe44df92a9908f4f5fde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SaveDir </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The method is combined with <a class="el" href="classSubGrad.html#a237e3a167830fdb29a3f0fff486c0109" title="The method is used within Solve() [see above], and its job is to compute the direction  that appears ...">FormD()</a> [see above] to carry out the direction computation. </p>
<p>Moreover, the stepsize is determined into <a class="el" href="classSubGrad.html#ae83d20499268fe44df92a9908f4f5fde" title="The method is combined with FormD() [see above] to carry out the direction computation. ">SaveDir()</a> when the adopted scheme is <em>stepsize-restricted</em>. </p>

</div>
</div>
<a class="anchor" id="abe7b43879f08b120019fc698eb71fdbc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GotoLambda1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move the current point to <img class="formulaInl" alt="$\lambda_{i+1}$" src="form_85.png"/>. </p>

</div>
</div>
<a class="anchor" id="a8eeda37b978781a055c191f8de5a3f2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FormLambda1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>After a (succesfull) call to <a class="el" href="classSubGrad.html#a237e3a167830fdb29a3f0fff486c0109" title="The method is used within Solve() [see above], and its job is to compute the direction  that appears ...">FormD()</a>, sets the new (unprojected) tentative point <img class="formulaInl" alt="$\breve{\lambda}_{i+1}$" src="form_88.png"/> as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \breve{\lambda}_{i+1} = \lambda_i - \nu_i d_i \,. \]" src="form_89.png"/>
</p>
<p> Remark that the point <img class="formulaInl" alt="$\breve{\lambda}_{i+1}$" src="form_88.png"/> must be projected before calling FiandGi() [see above], i.e., <img class="formulaInl" alt="$ \lambda_{i+1} = {\rm P}_{\Lambda} ( \breve{\lambda}_{i+1} ) $" src="form_90.png"/>. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a72e6f2cda99bb107508fe1f30daf354c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classStepsize.html">Stepsize</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The classes <a class="el" href="classStepsize.html" title="The class Stepsize provides an interface for the stepsize rule, to be used in the SubGrad solver [see...">Stepsize</a> and <a class="el" href="classDeflection.html" title="The class Deflection provides an interface for the deflection rule (DR), to be used in the SubGrad so...">Deflection</a> are "friends" of <a class="el" href="classSubGrad.html" title="The SubGrad class implements the NDOSolver interface for NonDifferentiable Optimization Solvers [see ...">SubGrad</a>. </p>
<p>This is done because <a class="el" href="classStepsize.html" title="The class Stepsize provides an interface for the stepsize rule, to be used in the SubGrad solver [see...">Stepsize</a> and <a class="el" href="classDeflection.html" title="The class Deflection provides an interface for the deflection rule (DR), to be used in the SubGrad so...">Deflection</a> objects may need some protected data to work. An issue, however, is that derived classes from friend classes are not friend, and therefore actual implementations of <a class="el" href="classStepsize.html" title="The class Stepsize provides an interface for the stepsize rule, to be used in the SubGrad solver [see...">Stepsize</a> and <a class="el" href="classDeflection.html" title="The class Deflection provides an interface for the deflection rule (DR), to be used in the SubGrad so...">Deflection</a> cannot access data of <a class="el" href="classSubGrad.html" title="The SubGrad class implements the NDOSolver interface for NonDifferentiable Optimization Solvers [see ...">SubGrad</a> unless this capability is explicitly provided by the base classes, who are friends. This is why <a class="el" href="classStepsize.html" title="The class Stepsize provides an interface for the stepsize rule, to be used in the SubGrad solver [see...">Stepsize</a> and <a class="el" href="classDeflection.html" title="The class Deflection provides an interface for the deflection rule (DR), to be used in the SubGrad so...">Deflection</a> define a few methods that allow to read protected data of <a class="el" href="classSubGrad.html" title="The SubGrad class implements the NDOSolver interface for NonDifferentiable Optimization Solvers [see ...">SubGrad</a>: so that any derived class can use them to access to these data. These methods are, in fact, implemented at the end of SubGrad.C. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a5327c3bb05a165beac89fe10d9cddc7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Index_Set CnstBeg</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>CnstBeg and CnstVol point respectively to a MaxNConst-vector of Index and HpNum, while CnstNxt is a MaxNumVar-vector of SIndex. </p>
<p>Each variable is associated to one and only knapsack constraint. CnstVol[ i ] is the volume of the i-th knapsack constraint. CnstBeg[ i ] supplies the starting of the i-th constraint, i.e. the first variable entering the i-th knpasack constraint. CnstNxt[ j ] says the name of the next variable to j entering the same knapsack constraint. If CnstNxt[ j ] == MaxNumVar, then no other variable enters that knapsack constraint, and if CnstNxt[ j ] == -1, the variable does not belong to any knapsack constraint. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classSubGrad.html">SubGrad</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
