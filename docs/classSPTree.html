<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>CNDSM: SPTree Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CNDSM
   &#160;<span id="projectnumber">1.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSPTree.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSPTree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SPTree Class Reference<div class="ingroups"><a class="el" href="group__SPTREE__CLASSES.html">Classes in SPTree.h</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classSPTree.html" title="The SPTree class derives from the abstract base class MCFClass, thus sharing its (standard) interface...">SPTree</a> class derives from the abstract base class <a class="el" href="classMCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a>, thus sharing its (standard) interface, and implements Shortest Path Tree algorithms for solving "uncapacitated" (Linear) Min Cost Flow problems with one source node.  
 <a href="classSPTree.html#details">More...</a></p>

<p><code>#include &lt;SPTree.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SPTree:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classSPTree.png" usemap="#SPTree_map" alt=""/>
  <map id="SPTree_map" name="SPTree_map">
<area href="classMCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ..." alt="MCFClass" shape="rect" coords="0,0,71,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaeb17eda40b01161160b996e7e0f7f23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPTree.html#aaeb17eda40b01161160b996e7e0f7f23">SPTree</a> (<a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> nmx=0, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> mmx=0, bool Drctd=true)</td></tr>
<tr class="memdesc:aaeb17eda40b01161160b996e7e0f7f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the class.  <a href="#aaeb17eda40b01161160b996e7e0f7f23">More...</a><br /></td></tr>
<tr class="separator:aaeb17eda40b01161160b996e7e0f7f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee7fae5fcb2871d38e1195c17580453"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPTree.html#afee7fae5fcb2871d38e1195c17580453">LoadNet</a> (<a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> nmx=0, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> mmx=0, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> pn=0, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> pm=0, <a class="el" href="classMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> pU=0, <a class="el" href="classMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a> pC=0, <a class="el" href="classMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a> pDfct=0, <a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> pSn=0, <a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> pEn=0)</td></tr>
<tr class="memdesc:afee7fae5fcb2871d38e1195c17580453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inputs a new network, as in <a class="el" href="classMCFClass.html#a8d82d26f7845eb69081c860e14c3dc4c" title="Inputs a new network. ">MCFClass::LoadNet()</a>.  <a href="#afee7fae5fcb2871d38e1195c17580453">More...</a><br /></td></tr>
<tr class="separator:afee7fae5fcb2871d38e1195c17580453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07861fb1e1053c6a1ff21ba680f2810c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPTree.html#a07861fb1e1053c6a1ff21ba680f2810c">MCFGetPi</a> (void)</td></tr>
<tr class="memdesc:a07861fb1e1053c6a1ff21ba680f2810c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same meaning as <a class="el" href="classMCFClass.html#a8f1a95d5c707f83ffc6aecba1e7e0e10" title="Return a read-only pointer to an internal data structure containing the node potentials. ">MCFClass::MCFGetPi()</a>.  <a href="#a07861fb1e1053c6a1ff21ba680f2810c">More...</a><br /></td></tr>
<tr class="separator:a07861fb1e1053c6a1ff21ba680f2810c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58a51dc42bfec6c9776cc2ebbd98842"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">SPTree::FONumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPTree.html#ad58a51dc42bfec6c9776cc2ebbd98842">MCFGetFO</a> (void)</td></tr>
<tr class="memdesc:ad58a51dc42bfec6c9776cc2ebbd98842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same meaning as <a class="el" href="classMCFClass.html#a109d7c021feda837d8ca5051fc24b6ea" title="Return the objective function value of the primal solution currently returned by MCFGetX(). ">MCFClass::MCFGetFO()</a>.  <a href="#ad58a51dc42bfec6c9776cc2ebbd98842">More...</a><br /></td></tr>
<tr class="separator:ad58a51dc42bfec6c9776cc2ebbd98842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e377a946e5a08dba5172117eaf68a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPTree.html#a76e377a946e5a08dba5172117eaf68a8">ShortestPathTree</a> (void)</td></tr>
<tr class="memdesc:a76e377a946e5a08dba5172117eaf68a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver of the Shortest Path Tree Problem from the current Origin.  <a href="#a76e377a946e5a08dba5172117eaf68a8">More...</a><br /></td></tr>
<tr class="separator:a76e377a946e5a08dba5172117eaf68a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90071ff5bdcd7e73fe156180fe7ffcee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPTree.html#a90071ff5bdcd7e73fe156180fe7ffcee">SetOrigin</a> (<a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> NewOrg)</td></tr>
<tr class="memdesc:a90071ff5bdcd7e73fe156180fe7ffcee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the Origin from which Shortest Paths are computed.  <a href="#a90071ff5bdcd7e73fe156180fe7ffcee">More...</a><br /></td></tr>
<tr class="separator:a90071ff5bdcd7e73fe156180fe7ffcee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fad8461dbf04f0981f698a4d1b9fbd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPTree.html#a1fad8461dbf04f0981f698a4d1b9fbd9">SetDest</a> (<a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> NewDst)</td></tr>
<tr class="memdesc:a1fad8461dbf04f0981f698a4d1b9fbd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the Destination node of Shotest Paths.  <a href="#a1fad8461dbf04f0981f698a4d1b9fbd9">More...</a><br /></td></tr>
<tr class="separator:a1fad8461dbf04f0981f698a4d1b9fbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1dba1878b1ac62056bbba3368e23f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPTree.html#afe1dba1878b1ac62056bbba3368e23f6">MCFGetX</a> (<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> ND, <a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> DB, <a class="el" href="classMCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a> F, <a class="el" href="classMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> nms=0, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=Inf&lt; <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())</td></tr>
<tr class="memdesc:afe1dba1878b1ac62056bbba3368e23f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like SPTree::MCFGetX( FRow , Index_Set , cIndex , Index ), except that the primal solution that is returned is relative only to the subset of destinations whose names are contained in the first ND entries of the vector DB.  <a href="#afe1dba1878b1ac62056bbba3368e23f6">More...</a><br /></td></tr>
<tr class="separator:afe1dba1878b1ac62056bbba3368e23f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412b2a0ccb6e2faacb7c2e5081d4e016"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">SPTree::FONumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPTree.html#a412b2a0ccb6e2faacb7c2e5081d4e016">MCFGetFO</a> (<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> ND, <a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> DB)</td></tr>
<tr class="memdesc:a412b2a0ccb6e2faacb7c2e5081d4e016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classSPTree.html#ad58a51dc42bfec6c9776cc2ebbd98842" title="Same meaning as MCFClass::MCFGetFO(). ">SPTree::MCFGetFO( void )</a>, except that the cost that is returned is that of the primal solution relative only to the subset of destinations whose names are contained in the first ND entries of the vector DB.  <a href="#a412b2a0ccb6e2faacb7c2e5081d4e016">More...</a><br /></td></tr>
<tr class="separator:a412b2a0ccb6e2faacb7c2e5081d4e016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451041eba0632676692f2de798bea4d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPTree.html#a451041eba0632676692f2de798bea4d7">Reached</a> (<a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> i)</td></tr>
<tr class="memdesc:a451041eba0632676692f2de798bea4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if a shortest path from Origin to i have already been computed; this can be used when LABEL_SETTING == 1 to determine if a shortest from Origin to i have been obtained as a by-product of the calculation of the shortest path between Origin and some other Dest.  <a href="#a451041eba0632676692f2de798bea4d7">More...</a><br /></td></tr>
<tr class="separator:a451041eba0632676692f2de798bea4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95a85d44e57ab53fe2b565355f6c054"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPTree.html#af95a85d44e57ab53fe2b565355f6c054">Predecessors</a> (void)</td></tr>
<tr class="memdesc:af95a85d44e57ab53fe2b565355f6c054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a cIndex* vector p[] such that p[ i ] is the predecessor of node i in the shortest path tree.  <a href="#af95a85d44e57ab53fe2b565355f6c054">More...</a><br /></td></tr>
<tr class="separator:af95a85d44e57ab53fe2b565355f6c054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaccf9d3766b10881f0b92387e3a9f914"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPTree.html#aaccf9d3766b10881f0b92387e3a9f914">ArcPredecessors</a> (void)</td></tr>
<tr class="memdesc:aaccf9d3766b10881f0b92387e3a9f914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a cIndex* vector a[] such that a[ i ] is the index of the arc ( p[ i ] , i ), being p[] the vector returned by the above method, and with the same structure.  <a href="#aaccf9d3766b10881f0b92387e3a9f914">More...</a><br /></td></tr>
<tr class="separator:aaccf9d3766b10881f0b92387e3a9f914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75a8a94d994b6a98934b241c969bdc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPTree.html#ae75a8a94d994b6a98934b241c969bdc6">Orig</a> (void)</td></tr>
<tr class="memdesc:ae75a8a94d994b6a98934b241c969bdc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the root of the SPT problem.  <a href="#ae75a8a94d994b6a98934b241c969bdc6">More...</a><br /></td></tr>
<tr class="separator:ae75a8a94d994b6a98934b241c969bdc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfad352a13e6be066a344f09b34148da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPTree.html#adfad352a13e6be066a344f09b34148da">DestN</a> (void)</td></tr>
<tr class="memdesc:adfad352a13e6be066a344f09b34148da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of destination nodes in the SPT problem.  <a href="#adfad352a13e6be066a344f09b34148da">More...</a><br /></td></tr>
<tr class="separator:adfad352a13e6be066a344f09b34148da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4139e9f19c46099f798ec496faca2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPTree.html#a0c4139e9f19c46099f798ec496faca2c">Dests</a> (void)</td></tr>
<tr class="memdesc:a0c4139e9f19c46099f798ec496faca2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classSPTree.html#adfad352a13e6be066a344f09b34148da" title="Return the number of destination nodes in the SPT problem. ">DestN()</a>-vector containig the names of destination nodes in the SPT problem; the names are in increasing order and INF-terminated.  <a href="#a0c4139e9f19c46099f798ec496faca2c">More...</a><br /></td></tr>
<tr class="separator:a0c4139e9f19c46099f798ec496faca2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae131faa3f8901f33f24617a4e61f601b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPTree.html#ae131faa3f8901f33f24617a4e61f601b">LenFS</a> (<a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> i)</td></tr>
<tr class="memdesc:ae131faa3f8901f33f24617a4e61f601b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the Forward Star of node i.  <a href="#ae131faa3f8901f33f24617a4e61f601b">More...</a><br /></td></tr>
<tr class="separator:ae131faa3f8901f33f24617a4e61f601b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd79f2ffc8ffb4e444fa60a6bb4ebbe1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSPTree.html#afd79f2ffc8ffb4e444fa60a6bb4ebbe1">ReadFS</a> (<a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> i, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> h)</td></tr>
<tr class="memdesc:afd79f2ffc8ffb4e444fa60a6bb4ebbe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the h-th arc in FS( i ) for h = 0, ...  <a href="#afd79f2ffc8ffb4e444fa60a6bb4ebbe1">More...</a><br /></td></tr>
<tr class="separator:afd79f2ffc8ffb4e444fa60a6bb4ebbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classMCFClass"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classMCFClass')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classMCFClass.html">MCFClass</a></td></tr>
<tr class="memitem:ac598fb1a423b3b722414a53c8549953c inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ac598fb1a423b3b722414a53c8549953c">MCFClass</a> (<a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> nmx=0, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> mmx=0)</td></tr>
<tr class="memdesc:ac598fb1a423b3b722414a53c8549953c inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the class.  <a href="#ac598fb1a423b3b722414a53c8549953c">More...</a><br /></td></tr>
<tr class="separator:ac598fb1a423b3b722414a53c8549953c inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d79a2f00cf8a2416b2b3e41552e843 inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a34d79a2f00cf8a2416b2b3e41552e843">LoadDMX</a> (istream &amp;DMXs, bool IsQuad=false)</td></tr>
<tr class="memdesc:a34d79a2f00cf8a2416b2b3e41552e843 inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a MCF instance in DIMACS standard format from the istream.  <a href="#a34d79a2f00cf8a2416b2b3e41552e843">More...</a><br /></td></tr>
<tr class="separator:a34d79a2f00cf8a2416b2b3e41552e843 inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0554708d9abb0e079a8d6f073def9bab inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a0554708d9abb0e079a8d6f073def9bab">PreProcess</a> (void)</td></tr>
<tr class="memdesc:a0554708d9abb0e079a8d6f073def9bab inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a smaller/easier equivalent MCF problem.  <a href="#a0554708d9abb0e079a8d6f073def9bab">More...</a><br /></td></tr>
<tr class="separator:a0554708d9abb0e079a8d6f073def9bab inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e162715d8454f30679c10372db4db8 inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ab8e162715d8454f30679c10372db4db8">SetPar</a> (int par, int val)</td></tr>
<tr class="memdesc:ab8e162715d8454f30679c10372db4db8 inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set integer parameters of the algorithm.  <a href="#ab8e162715d8454f30679c10372db4db8">More...</a><br /></td></tr>
<tr class="separator:ab8e162715d8454f30679c10372db4db8 inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4acd81f913880873c577de03a4fa1959 inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a4acd81f913880873c577de03a4fa1959">SetPar</a> (int par, double val)</td></tr>
<tr class="memdesc:a4acd81f913880873c577de03a4fa1959 inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set float parameters of the algorithm.  <a href="#a4acd81f913880873c577de03a4fa1959">More...</a><br /></td></tr>
<tr class="separator:a4acd81f913880873c577de03a4fa1959 inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ecae015d37862488819d24c47a1dc7 inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a14ecae015d37862488819d24c47a1dc7">GetPar</a> (int par, int &amp;val)</td></tr>
<tr class="memdesc:a14ecae015d37862488819d24c47a1dc7 inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns one of the integer parameter of the algorithm.  <a href="#a14ecae015d37862488819d24c47a1dc7">More...</a><br /></td></tr>
<tr class="separator:a14ecae015d37862488819d24c47a1dc7 inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846e3d15859bb0a97b848e5d56104b86 inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a846e3d15859bb0a97b848e5d56104b86">GetPar</a> (int par, double &amp;val)</td></tr>
<tr class="memdesc:a846e3d15859bb0a97b848e5d56104b86 inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns one of the integer parameter of the algorithm.  <a href="#a846e3d15859bb0a97b848e5d56104b86">More...</a><br /></td></tr>
<tr class="separator:a846e3d15859bb0a97b848e5d56104b86 inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5441232979a0ac98410d765b04830eeb inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a5441232979a0ac98410d765b04830eeb">SetMCFTime</a> (bool TimeIt=true)</td></tr>
<tr class="memdesc:a5441232979a0ac98410d765b04830eeb inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an OPTtimers object [see OPTtypes.h] to be used for timing the methods of the class.  <a href="#a5441232979a0ac98410d765b04830eeb">More...</a><br /></td></tr>
<tr class="separator:a5441232979a0ac98410d765b04830eeb inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333e27ad7a73779b096cb70829cbe8be inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a333e27ad7a73779b096cb70829cbe8be">MCFGetStatus</a> (void)</td></tr>
<tr class="memdesc:a333e27ad7a73779b096cb70829cbe8be inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an int describing the current status of the MCF solver.  <a href="#a333e27ad7a73779b096cb70829cbe8be">More...</a><br /></td></tr>
<tr class="separator:a333e27ad7a73779b096cb70829cbe8be inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb307e0707adaef99bb0e08c9e10eb8 inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a4eb307e0707adaef99bb0e08c9e10eb8">MCFGetX</a> (void)</td></tr>
<tr class="memdesc:a4eb307e0707adaef99bb0e08c9e10eb8 inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only pointer to an internal data structure containing the flow solution in "dense" format.  <a href="#a4eb307e0707adaef99bb0e08c9e10eb8">More...</a><br /></td></tr>
<tr class="separator:a4eb307e0707adaef99bb0e08c9e10eb8 inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4966a98c7ffa909057064beb4507a5 inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a7a4966a98c7ffa909057064beb4507a5">HaveNewX</a> (void)</td></tr>
<tr class="memdesc:a7a4966a98c7ffa909057064beb4507a5 inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if a different (approximately) optimal primal solution is available.  <a href="#a7a4966a98c7ffa909057064beb4507a5">More...</a><br /></td></tr>
<tr class="separator:a7a4966a98c7ffa909057064beb4507a5 inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b2b6516a7874ac55145312bd2d55bb inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a87b2b6516a7874ac55145312bd2d55bb">HaveNewPi</a> (void)</td></tr>
<tr class="memdesc:a87b2b6516a7874ac55145312bd2d55bb inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if a different (approximately) optimal dual solution is available.  <a href="#a87b2b6516a7874ac55145312bd2d55bb">More...</a><br /></td></tr>
<tr class="separator:a87b2b6516a7874ac55145312bd2d55bb inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af027cee8179a876a4879c73820c380d1 inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#af027cee8179a876a4879c73820c380d1">MCFGetRC</a> (void)</td></tr>
<tr class="memdesc:af027cee8179a876a4879c73820c380d1 inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only pointer to an internal data structure containing the reduced costs.  <a href="#af027cee8179a876a4879c73820c380d1">More...</a><br /></td></tr>
<tr class="separator:af027cee8179a876a4879c73820c380d1 inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca66f278ea62640af8e54590c687d715 inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#aca66f278ea62640af8e54590c687d715">MCFGetDFO</a> (void)</td></tr>
<tr class="memdesc:aca66f278ea62640af8e54590c687d715 inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the objective function value of the dual solution currently returned by <a class="el" href="classMCFClass.html#a8f1a95d5c707f83ffc6aecba1e7e0e10" title="Return a read-only pointer to an internal data structure containing the node potentials. ">MCFGetPi()</a> / <a class="el" href="classMCFClass.html#af027cee8179a876a4879c73820c380d1" title="Return a read-only pointer to an internal data structure containing the reduced costs. ">MCFGetRC()</a>.  <a href="#aca66f278ea62640af8e54590c687d715">More...</a><br /></td></tr>
<tr class="separator:aca66f278ea62640af8e54590c687d715 inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30483c3e5699b77f528c2e6f33c80ece inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a30483c3e5699b77f528c2e6f33c80ece">MCFGetUnfCut</a> (<a class="el" href="classMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> Cut)</td></tr>
<tr class="memdesc:a30483c3e5699b77f528c2e6f33c80ece inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an unfeasibility certificate.  <a href="#a30483c3e5699b77f528c2e6f33c80ece">More...</a><br /></td></tr>
<tr class="separator:a30483c3e5699b77f528c2e6f33c80ece inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88fa193007f0bc6ef751664a9f4c75a2 inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a88fa193007f0bc6ef751664a9f4c75a2">MCFGetUnbCycl</a> (<a class="el" href="classMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> Pred, <a class="el" href="classMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a> ArcPred)</td></tr>
<tr class="memdesc:a88fa193007f0bc6ef751664a9f4c75a2 inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an unboundedness certificate.  <a href="#a88fa193007f0bc6ef751664a9f4c75a2">More...</a><br /></td></tr>
<tr class="separator:a88fa193007f0bc6ef751664a9f4c75a2 inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995a05ecaa6ece4be3afbddbb36b2c4e inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#ab547218814e3b90d15f219f5aaf8b937">MCFStatePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a995a05ecaa6ece4be3afbddbb36b2c4e">MCFGetState</a> (void)</td></tr>
<tr class="memdesc:a995a05ecaa6ece4be3afbddbb36b2c4e inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the state of the MCF solver.  <a href="#a995a05ecaa6ece4be3afbddbb36b2c4e">More...</a><br /></td></tr>
<tr class="separator:a995a05ecaa6ece4be3afbddbb36b2c4e inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14589cd80aed231b6fc7da247f50601 inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ac14589cd80aed231b6fc7da247f50601">MCFPutState</a> (<a class="el" href="classMCFClass.html#ab547218814e3b90d15f219f5aaf8b937">MCFStatePtr</a> S)</td></tr>
<tr class="memdesc:ac14589cd80aed231b6fc7da247f50601 inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the solver to the state in which it was when the state `S' was created with <a class="el" href="classMCFClass.html#a995a05ecaa6ece4be3afbddbb36b2c4e" title="Save the state of the MCF solver. ">MCFGetState()</a> [see above].  <a href="#ac14589cd80aed231b6fc7da247f50601">More...</a><br /></td></tr>
<tr class="separator:ac14589cd80aed231b6fc7da247f50601 inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779a8829874de569dc0e09f40b6cd569 inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a779a8829874de569dc0e09f40b6cd569">TimeMCF</a> (double &amp;t_us, double &amp;t_ss)</td></tr>
<tr class="memdesc:a779a8829874de569dc0e09f40b6cd569 inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time the code.  <a href="#a779a8829874de569dc0e09f40b6cd569">More...</a><br /></td></tr>
<tr class="separator:a779a8829874de569dc0e09f40b6cd569 inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ce05b3fabc8d4f80332a02bce2a623 inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a25ce05b3fabc8d4f80332a02bce2a623">TimeMCF</a> (void)</td></tr>
<tr class="memdesc:a25ce05b3fabc8d4f80332a02bce2a623 inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like TimeMCF(double,double) [see above], but returns the total time.  <a href="#a25ce05b3fabc8d4f80332a02bce2a623">More...</a><br /></td></tr>
<tr class="separator:a25ce05b3fabc8d4f80332a02bce2a623 inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b70e84f98f30b408d0ffb191ff4442 inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a41b70e84f98f30b408d0ffb191ff4442">CheckPSol</a> (void)</td></tr>
<tr class="memdesc:a41b70e84f98f30b408d0ffb191ff4442 inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the primal solution returned by the solver is primal feasible.  <a href="#a41b70e84f98f30b408d0ffb191ff4442">More...</a><br /></td></tr>
<tr class="separator:a41b70e84f98f30b408d0ffb191ff4442 inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81bd6bc3b87534b4a67d0d93abedbd93 inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a81bd6bc3b87534b4a67d0d93abedbd93">CheckDSol</a> (void)</td></tr>
<tr class="memdesc:a81bd6bc3b87534b4a67d0d93abedbd93 inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the dual solution returned by the solver is dual feasible.  <a href="#a81bd6bc3b87534b4a67d0d93abedbd93">More...</a><br /></td></tr>
<tr class="separator:a81bd6bc3b87534b4a67d0d93abedbd93 inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb1bca6eb363c912c45c587f4bc214b inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#acfb1bca6eb363c912c45c587f4bc214b">MCFnmax</a> (void)</td></tr>
<tr class="memdesc:acfb1bca6eb363c912c45c587f4bc214b inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of nodes for this instance of <a class="el" href="classMCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a>.  <a href="#acfb1bca6eb363c912c45c587f4bc214b">More...</a><br /></td></tr>
<tr class="separator:acfb1bca6eb363c912c45c587f4bc214b inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63cff04d49de9f84b9ddc8585334690 inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#af63cff04d49de9f84b9ddc8585334690">MCFmmax</a> (void)</td></tr>
<tr class="memdesc:af63cff04d49de9f84b9ddc8585334690 inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of arcs for this instance of <a class="el" href="classMCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a>.  <a href="#af63cff04d49de9f84b9ddc8585334690">More...</a><br /></td></tr>
<tr class="separator:af63cff04d49de9f84b9ddc8585334690 inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6438187f454e795c03a850bfab31be84 inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a6438187f454e795c03a850bfab31be84">MCFn</a> (void)</td></tr>
<tr class="memdesc:a6438187f454e795c03a850bfab31be84 inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of nodes in the current graph.  <a href="#a6438187f454e795c03a850bfab31be84">More...</a><br /></td></tr>
<tr class="separator:a6438187f454e795c03a850bfab31be84 inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d5a0d0fc49882de0b4eb3146f1b7a6 inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ab4d5a0d0fc49882de0b4eb3146f1b7a6">MCFm</a> (void)</td></tr>
<tr class="memdesc:ab4d5a0d0fc49882de0b4eb3146f1b7a6 inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of arcs in the current graph.  <a href="#ab4d5a0d0fc49882de0b4eb3146f1b7a6">More...</a><br /></td></tr>
<tr class="separator:ab4d5a0d0fc49882de0b4eb3146f1b7a6 inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aeea0e6fd59fc54c2d7a0d21099ea21 inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a3aeea0e6fd59fc54c2d7a0d21099ea21">MCFSNdes</a> (void)</td></tr>
<tr class="memdesc:a3aeea0e6fd59fc54c2d7a0d21099ea21 inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only pointer to an internal vector containing the starting (tail) nodes for each arc.  <a href="#a3aeea0e6fd59fc54c2d7a0d21099ea21">More...</a><br /></td></tr>
<tr class="separator:a3aeea0e6fd59fc54c2d7a0d21099ea21 inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5494247213fd86574798bba97a2eb604 inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a5494247213fd86574798bba97a2eb604">MCFENdes</a> (void)</td></tr>
<tr class="memdesc:a5494247213fd86574798bba97a2eb604 inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only pointer to an internal vector containing the ending (head) nodes for each arc.  <a href="#a5494247213fd86574798bba97a2eb604">More...</a><br /></td></tr>
<tr class="separator:a5494247213fd86574798bba97a2eb604 inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75dcdf78883ef28452a4698aaa6bf14b inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a75dcdf78883ef28452a4698aaa6bf14b">MCFCosts</a> (void)</td></tr>
<tr class="memdesc:a75dcdf78883ef28452a4698aaa6bf14b inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only pointer to an internal vector containing the arc costs.  <a href="#a75dcdf78883ef28452a4698aaa6bf14b">More...</a><br /></td></tr>
<tr class="separator:a75dcdf78883ef28452a4698aaa6bf14b inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd08873d1e15db41bf42648226f8feb1 inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#acd08873d1e15db41bf42648226f8feb1">MCFQCoef</a> (<a class="el" href="classMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a> Qv, <a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=Inf&lt; <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())</td></tr>
<tr class="separator:acd08873d1e15db41bf42648226f8feb1 inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9227949082669e0e9ca0c545406f1f4 inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ab9227949082669e0e9ca0c545406f1f4">MCFQCoef</a> (<a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> i)</td></tr>
<tr class="separator:ab9227949082669e0e9ca0c545406f1f4 inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea78552d525e5ce61f3e3887774cc11 inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#aeea78552d525e5ce61f3e3887774cc11">MCFQCoef</a> (void)</td></tr>
<tr class="memdesc:aeea78552d525e5ce61f3e3887774cc11 inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only pointer to an internal vector containing the arc costs.  <a href="#aeea78552d525e5ce61f3e3887774cc11">More...</a><br /></td></tr>
<tr class="separator:aeea78552d525e5ce61f3e3887774cc11 inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae54f2f08242d5fd631eb613d82e4d1c inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#aae54f2f08242d5fd631eb613d82e4d1c">MCFUCaps</a> (void)</td></tr>
<tr class="memdesc:aae54f2f08242d5fd631eb613d82e4d1c inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only pointer to an internal vector containing the arc capacities.  <a href="#aae54f2f08242d5fd631eb613d82e4d1c">More...</a><br /></td></tr>
<tr class="separator:aae54f2f08242d5fd631eb613d82e4d1c inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e8d115e0f2bd90e1b65a573cb46ae4 inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ad7e8d115e0f2bd90e1b65a573cb46ae4">MCFDfcts</a> (void)</td></tr>
<tr class="memdesc:ad7e8d115e0f2bd90e1b65a573cb46ae4 inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only pointer to an internal vector containing the node deficits.  <a href="#ad7e8d115e0f2bd90e1b65a573cb46ae4">More...</a><br /></td></tr>
<tr class="separator:ad7e8d115e0f2bd90e1b65a573cb46ae4 inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd008d9548bf3e1aef1291864171bb2d inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#acd008d9548bf3e1aef1291864171bb2d">WriteMCF</a> (ostream &amp;oStrm, int frmt=0)</td></tr>
<tr class="memdesc:acd008d9548bf3e1aef1291864171bb2d inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the current MCF problem to an ostream.  <a href="#acd008d9548bf3e1aef1291864171bb2d">More...</a><br /></td></tr>
<tr class="separator:acd008d9548bf3e1aef1291864171bb2d inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa1d49c3edafbf4783d579d175070fd inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a4aa1d49c3edafbf4783d579d175070fd">ChgQCoef</a> (<a class="el" href="classMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a> NQCoef=0, <a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> nms=0, <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> stp=Inf&lt; <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> &gt;())</td></tr>
<tr class="separator:a4aa1d49c3edafbf4783d579d175070fd inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df44e18d436b2500e5608d6ab2d58ad inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a4df44e18d436b2500e5608d6ab2d58ad">ChgQCoef</a> (<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> arc, <a class="el" href="classMCFClass.html#a07dbefeeb08c3f63073622411893eb76">cCNumber</a> NQCoef)</td></tr>
<tr class="separator:a4df44e18d436b2500e5608d6ab2d58ad inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c0882740d38b9f8eb05994a01f76b7 inherit pub_methods_classMCFClass"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a93c0882740d38b9f8eb05994a01f76b7">~MCFClass</a> ()</td></tr>
<tr class="memdesc:a93c0882740d38b9f8eb05994a01f76b7 inherit pub_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of the class.  <a href="#a93c0882740d38b9f8eb05994a01f76b7">More...</a><br /></td></tr>
<tr class="separator:a93c0882740d38b9f8eb05994a01f76b7 inherit pub_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classMCFClass"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classMCFClass')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classMCFClass.html">MCFClass</a></td></tr>
<tr class="memitem:ad53d6229d7ec28555a9c9c2fd9abf773 inherit pub_types_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad53d6229d7ec28555a9c9c2fd9abf773"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a></td></tr>
<tr class="memdesc:ad53d6229d7ec28555a9c9c2fd9abf773 inherit pub_types_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">index of a node or arc ( &gt;= 0 ) <br /></td></tr>
<tr class="separator:ad53d6229d7ec28555a9c9c2fd9abf773 inherit pub_types_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3388eb329ff0551a0b86b6c67e33d8 inherit pub_types_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace3388eb329ff0551a0b86b6c67e33d8"></a>
typedef <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a></td></tr>
<tr class="memdesc:ace3388eb329ff0551a0b86b6c67e33d8 inherit pub_types_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">set (array) of indices <br /></td></tr>
<tr class="separator:ace3388eb329ff0551a0b86b6c67e33d8 inherit pub_types_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76aaabb20535c51a2752b93f6c38fe54 inherit pub_types_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76aaabb20535c51a2752b93f6c38fe54"></a>
typedef const <a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a></td></tr>
<tr class="memdesc:a76aaabb20535c51a2752b93f6c38fe54 inherit pub_types_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only index <br /></td></tr>
<tr class="separator:a76aaabb20535c51a2752b93f6c38fe54 inherit pub_types_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81575b2d4e4d5636b17170432150ae69 inherit pub_types_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81575b2d4e4d5636b17170432150ae69"></a>
typedef <a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a></td></tr>
<tr class="memdesc:a81575b2d4e4d5636b17170432150ae69 inherit pub_types_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">read-only index array <br /></td></tr>
<tr class="separator:a81575b2d4e4d5636b17170432150ae69 inherit pub_types_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea3e5951d222b2a8e57de1b4246a909 inherit pub_types_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeea3e5951d222b2a8e57de1b4246a909"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a></td></tr>
<tr class="memdesc:aeea3e5951d222b2a8e57de1b4246a909 inherit pub_types_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of arc flow <br /></td></tr>
<tr class="separator:aeea3e5951d222b2a8e57de1b4246a909 inherit pub_types_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dae1f1a39c208ce3c2b337cd5bb3d00 inherit pub_types_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dae1f1a39c208ce3c2b337cd5bb3d00"></a>
typedef <a class="el" href="classMCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a></td></tr>
<tr class="memdesc:a9dae1f1a39c208ce3c2b337cd5bb3d00 inherit pub_types_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of flows <br /></td></tr>
<tr class="separator:a9dae1f1a39c208ce3c2b337cd5bb3d00 inherit pub_types_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f747fbdff346237c8db4469d569994 inherit pub_types_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11f747fbdff346237c8db4469d569994"></a>
typedef const <a class="el" href="classMCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a11f747fbdff346237c8db4469d569994">cFNumber</a></td></tr>
<tr class="memdesc:a11f747fbdff346237c8db4469d569994 inherit pub_types_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only flow <br /></td></tr>
<tr class="separator:a11f747fbdff346237c8db4469d569994 inherit pub_types_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad325f3193dbba0ddef1da4e72d29eda6 inherit pub_types_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad325f3193dbba0ddef1da4e72d29eda6"></a>
typedef <a class="el" href="classMCFClass.html#a11f747fbdff346237c8db4469d569994">cFNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a></td></tr>
<tr class="memdesc:ad325f3193dbba0ddef1da4e72d29eda6 inherit pub_types_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">read-only flow array <br /></td></tr>
<tr class="separator:ad325f3193dbba0ddef1da4e72d29eda6 inherit pub_types_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d0627ba8213afe1ec4ebeb4508e8f1 inherit pub_types_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24d0627ba8213afe1ec4ebeb4508e8f1"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a></td></tr>
<tr class="memdesc:a24d0627ba8213afe1ec4ebeb4508e8f1 inherit pub_types_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of arc flow cost <br /></td></tr>
<tr class="separator:a24d0627ba8213afe1ec4ebeb4508e8f1 inherit pub_types_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62409402be4e4b301e1a568f99f877be inherit pub_types_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62409402be4e4b301e1a568f99f877be"></a>
typedef <a class="el" href="classMCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a62409402be4e4b301e1a568f99f877be">CRow</a></td></tr>
<tr class="memdesc:a62409402be4e4b301e1a568f99f877be inherit pub_types_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of costs <br /></td></tr>
<tr class="separator:a62409402be4e4b301e1a568f99f877be inherit pub_types_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07dbefeeb08c3f63073622411893eb76 inherit pub_types_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07dbefeeb08c3f63073622411893eb76"></a>
typedef const <a class="el" href="classMCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a07dbefeeb08c3f63073622411893eb76">cCNumber</a></td></tr>
<tr class="memdesc:a07dbefeeb08c3f63073622411893eb76 inherit pub_types_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only cost <br /></td></tr>
<tr class="separator:a07dbefeeb08c3f63073622411893eb76 inherit pub_types_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab700102e9ba8bb6015be6818d4e99097 inherit pub_types_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab700102e9ba8bb6015be6818d4e99097"></a>
typedef <a class="el" href="classMCFClass.html#a07dbefeeb08c3f63073622411893eb76">cCNumber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a></td></tr>
<tr class="memdesc:ab700102e9ba8bb6015be6818d4e99097 inherit pub_types_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">read-only cost array <br /></td></tr>
<tr class="separator:ab700102e9ba8bb6015be6818d4e99097 inherit pub_types_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ee7b3099b0bc780a6a4b43629488fa inherit pub_types_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5ee7b3099b0bc780a6a4b43629488fa"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a></td></tr>
<tr class="memdesc:af5ee7b3099b0bc780a6a4b43629488fa inherit pub_types_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of the objective function: has to hold sums of products of FNumber(s) by CNumber(s) <br /></td></tr>
<tr class="separator:af5ee7b3099b0bc780a6a4b43629488fa inherit pub_types_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7942d00ff59c58e29834ecb27d8efe0 inherit pub_types_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7942d00ff59c58e29834ecb27d8efe0"></a>
typedef const <a class="el" href="classMCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">FONumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ac7942d00ff59c58e29834ecb27d8efe0">cFONumber</a></td></tr>
<tr class="memdesc:ac7942d00ff59c58e29834ecb27d8efe0 inherit pub_types_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">a read-only o.f. value <br /></td></tr>
<tr class="separator:ac7942d00ff59c58e29834ecb27d8efe0 inherit pub_types_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab547218814e3b90d15f219f5aaf8b937 inherit pub_types_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab547218814e3b90d15f219f5aaf8b937"></a>
typedef <a class="el" href="classMCFClass_1_1MCFState.html">MCFState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ab547218814e3b90d15f219f5aaf8b937">MCFStatePtr</a></td></tr>
<tr class="memdesc:ab547218814e3b90d15f219f5aaf8b937 inherit pub_types_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to a <a class="el" href="classMCFClass_1_1MCFState.html" title="Base class for representing the internal state of the MCF algorithm. ">MCFState</a> <br /></td></tr>
<tr class="separator:ab547218814e3b90d15f219f5aaf8b937 inherit pub_types_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classMCFClass"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classMCFClass')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classMCFClass.html">MCFClass</a></td></tr>
<tr class="memitem:aadaea79b7a516a86d9e318c31ce3d489 inherit pro_methods_classMCFClass"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aadaea79b7a516a86d9e318c31ce3d489 inherit pro_methods_classMCFClass"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMCFClass.html#aadaea79b7a516a86d9e318c31ce3d489">ETZ</a> (T x, const T eps)</td></tr>
<tr class="memdesc:aadaea79b7a516a86d9e318c31ce3d489 inherit pro_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is equal to zero (possibly considering tolerances).  <a href="#aadaea79b7a516a86d9e318c31ce3d489">More...</a><br /></td></tr>
<tr class="separator:aadaea79b7a516a86d9e318c31ce3d489 inherit pro_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af314a8df7e38143854b9bf17c8eb25fc inherit pro_methods_classMCFClass"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af314a8df7e38143854b9bf17c8eb25fc inherit pro_methods_classMCFClass"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMCFClass.html#af314a8df7e38143854b9bf17c8eb25fc">GTZ</a> (T x, const T eps)</td></tr>
<tr class="memdesc:af314a8df7e38143854b9bf17c8eb25fc inherit pro_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is greater than zero (possibly considering tolerances).  <a href="#af314a8df7e38143854b9bf17c8eb25fc">More...</a><br /></td></tr>
<tr class="separator:af314a8df7e38143854b9bf17c8eb25fc inherit pro_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae414baaa6f224ce576574baa1e71650a inherit pro_methods_classMCFClass"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae414baaa6f224ce576574baa1e71650a inherit pro_methods_classMCFClass"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ae414baaa6f224ce576574baa1e71650a">GEZ</a> (T x, const T eps)</td></tr>
<tr class="memdesc:ae414baaa6f224ce576574baa1e71650a inherit pro_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is greater than or equal to zero (possibly considering tolerances).  <a href="#ae414baaa6f224ce576574baa1e71650a">More...</a><br /></td></tr>
<tr class="separator:ae414baaa6f224ce576574baa1e71650a inherit pro_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab355a057db64a4b3da5209f747c01eae inherit pro_methods_classMCFClass"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab355a057db64a4b3da5209f747c01eae inherit pro_methods_classMCFClass"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ab355a057db64a4b3da5209f747c01eae">LTZ</a> (T x, const T eps)</td></tr>
<tr class="memdesc:ab355a057db64a4b3da5209f747c01eae inherit pro_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is less than zero (possibly considering tolerances).  <a href="#ab355a057db64a4b3da5209f747c01eae">More...</a><br /></td></tr>
<tr class="separator:ab355a057db64a4b3da5209f747c01eae inherit pro_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1dfab25fba0d9badd0cce4dc99933b inherit pro_methods_classMCFClass"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adc1dfab25fba0d9badd0cce4dc99933b inherit pro_methods_classMCFClass"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMCFClass.html#adc1dfab25fba0d9badd0cce4dc99933b">LEZ</a> (T x, const T eps)</td></tr>
<tr class="memdesc:adc1dfab25fba0d9badd0cce4dc99933b inherit pro_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is less than or equal to zero (possibly considering tolerances).  <a href="#adc1dfab25fba0d9badd0cce4dc99933b">More...</a><br /></td></tr>
<tr class="separator:adc1dfab25fba0d9badd0cce4dc99933b inherit pro_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945c3a54be501ad68f71adaf7771d457 inherit pro_methods_classMCFClass"><td class="memTemplParams" colspan="2"><a class="anchor" id="a945c3a54be501ad68f71adaf7771d457"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a945c3a54be501ad68f71adaf7771d457 inherit pro_methods_classMCFClass"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a945c3a54be501ad68f71adaf7771d457">GT</a> (T x, T y, const T eps)</td></tr>
<tr class="memdesc:a945c3a54be501ad68f71adaf7771d457 inherit pro_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is greater than flow y (possibly considering tolerances). <br /></td></tr>
<tr class="separator:a945c3a54be501ad68f71adaf7771d457 inherit pro_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0374fafa5efdfe1d78c22efaa9f9d6 inherit pro_methods_classMCFClass"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7c0374fafa5efdfe1d78c22efaa9f9d6 inherit pro_methods_classMCFClass"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a7c0374fafa5efdfe1d78c22efaa9f9d6">LT</a> (T x, T y, const T eps)</td></tr>
<tr class="memdesc:a7c0374fafa5efdfe1d78c22efaa9f9d6 inherit pro_methods_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if flow x is less than flow y (possibly considering tolerances).  <a href="#a7c0374fafa5efdfe1d78c22efaa9f9d6">More...</a><br /></td></tr>
<tr class="separator:a7c0374fafa5efdfe1d78c22efaa9f9d6 inherit pro_methods_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classMCFClass"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classMCFClass')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classMCFClass.html">MCFClass</a></td></tr>
<tr class="memitem:a7f0f8bcc88c30609d766a4e723a53dac inherit pro_attribs_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f0f8bcc88c30609d766a4e723a53dac"></a>
<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a7f0f8bcc88c30609d766a4e723a53dac">n</a></td></tr>
<tr class="memdesc:a7f0f8bcc88c30609d766a4e723a53dac inherit pro_attribs_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of nodes <br /></td></tr>
<tr class="separator:a7f0f8bcc88c30609d766a4e723a53dac inherit pro_attribs_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02366e13d56b1124db9bf8281b73ca9a inherit pro_attribs_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02366e13d56b1124db9bf8281b73ca9a"></a>
<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a02366e13d56b1124db9bf8281b73ca9a">nmax</a></td></tr>
<tr class="memdesc:a02366e13d56b1124db9bf8281b73ca9a inherit pro_attribs_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of nodes <br /></td></tr>
<tr class="separator:a02366e13d56b1124db9bf8281b73ca9a inherit pro_attribs_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d50257929003fb000e6bcc1db02fd6 inherit pro_attribs_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61d50257929003fb000e6bcc1db02fd6"></a>
<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a61d50257929003fb000e6bcc1db02fd6">m</a></td></tr>
<tr class="memdesc:a61d50257929003fb000e6bcc1db02fd6 inherit pro_attribs_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of arcs <br /></td></tr>
<tr class="separator:a61d50257929003fb000e6bcc1db02fd6 inherit pro_attribs_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e7022437bc38dc11cffe32d4b2332c inherit pro_attribs_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93e7022437bc38dc11cffe32d4b2332c"></a>
<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a93e7022437bc38dc11cffe32d4b2332c">mmax</a></td></tr>
<tr class="memdesc:a93e7022437bc38dc11cffe32d4b2332c inherit pro_attribs_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of arcs <br /></td></tr>
<tr class="separator:a93e7022437bc38dc11cffe32d4b2332c inherit pro_attribs_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e27f49150e9a14580fb313cc2777e00 inherit pro_attribs_classMCFClass"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a6e27f49150e9a14580fb313cc2777e00">status</a></td></tr>
<tr class="memdesc:a6e27f49150e9a14580fb313cc2777e00 inherit pro_attribs_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">return status, see the comments to <a class="el" href="classMCFClass.html#a333e27ad7a73779b096cb70829cbe8be" title="Returns an int describing the current status of the MCF solver. ">MCFGetStatus()</a> above.  <a href="#a6e27f49150e9a14580fb313cc2777e00">More...</a><br /></td></tr>
<tr class="separator:a6e27f49150e9a14580fb313cc2777e00 inherit pro_attribs_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b691e0b125c33ab526888ab754e461 inherit pro_attribs_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89b691e0b125c33ab526888ab754e461"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a89b691e0b125c33ab526888ab754e461">Senstv</a></td></tr>
<tr class="memdesc:a89b691e0b125c33ab526888ab754e461 inherit pro_attribs_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">true &lt;=&gt; the latest optimal solution should be exploited <br /></td></tr>
<tr class="separator:a89b691e0b125c33ab526888ab754e461 inherit pro_attribs_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7624a057d988dd8f61b038ff459cd0b inherit pro_attribs_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7624a057d988dd8f61b038ff459cd0b"></a>
OPTtimers *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ab7624a057d988dd8f61b038ff459cd0b">MCFt</a></td></tr>
<tr class="memdesc:ab7624a057d988dd8f61b038ff459cd0b inherit pro_attribs_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">timer for performances evaluation <br /></td></tr>
<tr class="separator:ab7624a057d988dd8f61b038ff459cd0b inherit pro_attribs_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b1c456efbc2e544b82cb6553f6df8d inherit pro_attribs_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65b1c456efbc2e544b82cb6553f6df8d"></a>
<a class="el" href="classMCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a65b1c456efbc2e544b82cb6553f6df8d">EpsFlw</a></td></tr>
<tr class="memdesc:a65b1c456efbc2e544b82cb6553f6df8d inherit pro_attribs_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">precision for comparing arc flows / capacities <br /></td></tr>
<tr class="separator:a65b1c456efbc2e544b82cb6553f6df8d inherit pro_attribs_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9159ee7ca50477fd57f6854ff73b2874 inherit pro_attribs_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9159ee7ca50477fd57f6854ff73b2874"></a>
<a class="el" href="classMCFClass.html#aeea3e5951d222b2a8e57de1b4246a909">FNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a9159ee7ca50477fd57f6854ff73b2874">EpsDfct</a></td></tr>
<tr class="memdesc:a9159ee7ca50477fd57f6854ff73b2874 inherit pro_attribs_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">precision for comparing node deficits <br /></td></tr>
<tr class="separator:a9159ee7ca50477fd57f6854ff73b2874 inherit pro_attribs_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8c11b8ba9065dd3bc0f7b5ec423869 inherit pro_attribs_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad8c11b8ba9065dd3bc0f7b5ec423869"></a>
<a class="el" href="classMCFClass.html#a24d0627ba8213afe1ec4ebeb4508e8f1">CNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#aad8c11b8ba9065dd3bc0f7b5ec423869">EpsCst</a></td></tr>
<tr class="memdesc:aad8c11b8ba9065dd3bc0f7b5ec423869 inherit pro_attribs_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">precision for comparing arc costs <br /></td></tr>
<tr class="separator:aad8c11b8ba9065dd3bc0f7b5ec423869 inherit pro_attribs_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bad127f3e412819d99baff0c51e5be8 inherit pro_attribs_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bad127f3e412819d99baff0c51e5be8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a8bad127f3e412819d99baff0c51e5be8">MaxTime</a></td></tr>
<tr class="memdesc:a8bad127f3e412819d99baff0c51e5be8 inherit pro_attribs_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">max time (in seconds) in which MCF Solver can find an optimal solution (0 = no limits) <br /></td></tr>
<tr class="separator:a8bad127f3e412819d99baff0c51e5be8 inherit pro_attribs_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259eaddd4d91ec0a7d00ff6db0a3f40a inherit pro_attribs_classMCFClass"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a259eaddd4d91ec0a7d00ff6db0a3f40a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a259eaddd4d91ec0a7d00ff6db0a3f40a">MaxIter</a></td></tr>
<tr class="memdesc:a259eaddd4d91ec0a7d00ff6db0a3f40a inherit pro_attribs_classMCFClass"><td class="mdescLeft">&#160;</td><td class="mdescRight">max number of iterations in which MCF Solver can find an optimal solution (0 = no limits) <br /></td></tr>
<tr class="separator:a259eaddd4d91ec0a7d00ff6db0a3f40a inherit pro_attribs_classMCFClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classSPTree.html" title="The SPTree class derives from the abstract base class MCFClass, thus sharing its (standard) interface...">SPTree</a> class derives from the abstract base class <a class="el" href="classMCFClass.html" title="This abstract base class defines a standard interface for (linear or convex quadartic separable) Min ...">MCFClass</a>, thus sharing its (standard) interface, and implements Shortest Path Tree algorithms for solving "uncapacitated" (Linear) Min Cost Flow problems with one source node. </p>
<dl class="section warning"><dt>Warning</dt><dd>The SPT algorithm will enter in an infinite loop if a directed cycle of negative cost exists in the graph: there is no check about this in the code. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aaeb17eda40b01161160b996e7e0f7f23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSPTree.html">SPTree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>nmx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>mmx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>Drctd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor of the class. </p>
<p>For the meaning of nmx and mmx see <a class="el" href="classMCFClass.html#ac598fb1a423b3b722414a53c8549953c" title="Constructor of the class. ">MCFClass::MCFClass()</a>.</p>
<p>The parameter `Drctd' tells if the given graph has really to be understood as directed (default), i.e., if the i-th arc is Sn[ i ] &ndash;&gt; En[ i ], or undirected, i.e., the i-th arc is Sn[ i ] &lt;&ndash;&gt; En[ i ]. Undirected graphs are internally implemented by doubling each arc, but this is completely hidden by the interface. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="afee7fae5fcb2871d38e1195c17580453"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoadNet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>nmx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>mmx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>pn</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>pm</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td>
          <td class="paramname"><em>pU</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a>&#160;</td>
          <td class="paramname"><em>pC</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ad325f3193dbba0ddef1da4e72d29eda6">cFRow</a>&#160;</td>
          <td class="paramname"><em>pDfct</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>pSn</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>pEn</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inputs a new network, as in <a class="el" href="classMCFClass.html#a8d82d26f7845eb69081c860e14c3dc4c" title="Inputs a new network. ">MCFClass::LoadNet()</a>. </p>
<p>Arcs with pC[ i ] == Inf&lt;CNumber&gt;() do not "exist". If DYNMC_MCF_SPT &gt; 0, these arcs are "closed".</p>
<p>If DYNMC_MCF_SPT == 0 but SAME_GRPH_SPT &gt; 0, these arcs are dealt with explicitly, and can be put back into the formulation by simply changing their cost. Note that, however, this is less efficient than eliminating them explicitly from the problem.</p>
<p>If DYNMC_MCF_SPT == 0 and SAME_GRPH_SPT == 0, these arcs are just removed from the formulation. However, they have some sort of a "special status" (after all, if the user wants to remove them completely he/she can just change the data), in that they are still counted into the number of arcs of the graph and they will always have 0 flow and Inf&lt;CNumber&gt;() reduced cost as "closed" or "deleted" arcs. </p>

<p>Implements <a class="el" href="classMCFClass.html#a8d82d26f7845eb69081c860e14c3dc4c">MCFClass</a>.</p>

</div>
</div>
<a class="anchor" id="a07861fb1e1053c6a1ff21ba680f2810c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMCFClass.html#ab700102e9ba8bb6015be6818d4e99097">cCRow</a> MCFGetPi </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same meaning as <a class="el" href="classMCFClass.html#a8f1a95d5c707f83ffc6aecba1e7e0e10" title="Return a read-only pointer to an internal data structure containing the node potentials. ">MCFClass::MCFGetPi()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Some of the potentials may be + Inf&lt;CNumber&gt;(): this means that</dd></dl>
<ul>
<li>the node is <em>not</em> a destination and it cannot be reached from the Origin (however, this does <em>not</em> mean that the problem is unfeasible);</li>
<li>if LABEL_SETTING == 1, the node is <em>not</em> a destination and it has not been reached during the algorithm. </li>
</ul>

<p>Reimplemented from <a class="el" href="classMCFClass.html#a8f1a95d5c707f83ffc6aecba1e7e0e10">MCFClass</a>.</p>

</div>
</div>
<a class="anchor" id="ad58a51dc42bfec6c9776cc2ebbd98842"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">SPTree::FONumber</a> MCFGetFO </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same meaning as <a class="el" href="classMCFClass.html#a109d7c021feda837d8ca5051fc24b6ea" title="Return the objective function value of the primal solution currently returned by MCFGetX(). ">MCFClass::MCFGetFO()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>if not all the specified destinations can be reached from the Origin, returns Inf&lt;FONumber&gt;(). </dd></dl>

<p>Implements <a class="el" href="classMCFClass.html#a109d7c021feda837d8ca5051fc24b6ea">MCFClass</a>.</p>

</div>
</div>
<a class="anchor" id="a76e377a946e5a08dba5172117eaf68a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShortestPathTree </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solver of the Shortest Path Tree Problem from the current Origin. </p>
<p>(specified in the constructor or by <a class="el" href="classSPTree.html#a90071ff5bdcd7e73fe156180fe7ffcee" title="Changes the Origin from which Shortest Paths are computed. ">SetOrigin()</a>, see below)</p>
<p>If LABEL_SETTING == 0, or if no Destination is speficied (Dst == Inf&lt;Index&gt;() in <a class="el" href="classSPTree.html#a1fad8461dbf04f0981f698a4d1b9fbd9" title="Changes the Destination node of Shotest Paths. ">SetDest()</a> [see below]), the whole Shortest Path Tree (at least, the SPT of the component of the graph connected with Origin) is computed, otherwise the code stops as soon as the shortest path between Origin and Dest is computed.</p>
<p>Note that methods such as <a class="el" href="classMCFClass.html#a4eb307e0707adaef99bb0e08c9e10eb8" title="Return a read-only pointer to an internal data structure containing the flow solution in &quot;dense&quot; form...">MCFGetX()</a>, <a class="el" href="classMCFClass.html#af027cee8179a876a4879c73820c380d1" title="Return a read-only pointer to an internal data structure containing the reduced costs. ">MCFGetRC()</a> and <a class="el" href="classSPTree.html#ad58a51dc42bfec6c9776cc2ebbd98842" title="Same meaning as MCFClass::MCFGetFO(). ">MCFGetFO()</a> may need some complicate calculations in order to put the solution of the Shortest Path in the correct format; since these calculations change some of the internal data structures, it is not permitted to call again <a class="el" href="classSPTree.html#a76e377a946e5a08dba5172117eaf68a8" title="Solver of the Shortest Path Tree Problem from the current Origin. ">ShortestPathTree()</a> after that any of these methods have been called. </p>

</div>
</div>
<a class="anchor" id="a90071ff5bdcd7e73fe156180fe7ffcee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetOrigin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>NewOrg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the Origin from which Shortest Paths are computed. </p>

<p>References <a class="el" href="classMCFClass.html#a15ef269c5dd98eea5274eb03a3feb5fbac006c8f6dc4fcd4f51ee3c8ad8aca9d1">MCFClass::kUnSolved</a>, and <a class="el" href="group__MCFCLASS__MACROS.html#ga74cc96ffa32533b7eff040b5ffee5e06">USENAME0</a>.</p>

</div>
</div>
<a class="anchor" id="a1fad8461dbf04f0981f698a4d1b9fbd9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetDest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>NewDst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the Destination node of Shotest Paths. </p>
<p>If LABEL_SETTING == 0, it has no influence since label correcting methods cannot stop before the whole SPT has been computed. Conversely, label setting algorithms can solve Origin-Dest Shortest Path Problems; therefore, it is possible to obtain shortest paths between Origin and a subset of the nodes, by calling <a class="el" href="classSPTree.html#a76e377a946e5a08dba5172117eaf68a8" title="Solver of the Shortest Path Tree Problem from the current Origin. ">ShortestPathTree()</a> with one of the destinations, and controlling upon completion that all the desidered nodes have been visited (see <a class="el" href="classSPTree.html#a451041eba0632676692f2de798bea4d7" title="Return true if a shortest path from Origin to i have already been computed; this can be used when LAB...">Reached()</a> below). If this is not the case, <a class="el" href="classSPTree.html#a76e377a946e5a08dba5172117eaf68a8" title="Solver of the Shortest Path Tree Problem from the current Origin. ">ShortestPathTree()</a> can be invoked again with one of the unreached nodes, until they are all visited.</p>
<p>If no Dest is given, or if Dest is set to Inf&lt;Index&gt;(), the whole Shortest Path Tree (at least, the SPT of the component of the graph connected with Origin) is computed. </p>

<p>References <a class="el" href="classMCFClass.html#a15ef269c5dd98eea5274eb03a3feb5fbac006c8f6dc4fcd4f51ee3c8ad8aca9d1">MCFClass::kUnSolved</a>, and <a class="el" href="group__MCFCLASS__MACROS.html#ga74cc96ffa32533b7eff040b5ffee5e06">USENAME0</a>.</p>

</div>
</div>
<a class="anchor" id="afe1dba1878b1ac62056bbba3368e23f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCFGetX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>ND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>DB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a9dae1f1a39c208ce3c2b337cd5bb3d00">FRow</a>&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ace3388eb329ff0551a0b86b6c67e33d8">Index_Set</a>&#160;</td>
          <td class="paramname"><em>nms</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>stp</em> = <code>Inf&lt;&#160;<a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like SPTree::MCFGetX( FRow , Index_Set , cIndex , Index ), except that the primal solution that is returned is relative only to the subset of destinations whose names are contained in the first ND entries of the vector DB. </p>
<p>Note: node names in ND must be in 1 ... n irrespective of USENAME0. </p>

</div>
</div>
<a class="anchor" id="a412b2a0ccb6e2faacb7c2e5081d4e016"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMCFClass.html#af5ee7b3099b0bc780a6a4b43629488fa">SPTree::FONumber</a> MCFGetFO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">Index</a>&#160;</td>
          <td class="paramname"><em>ND</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a>&#160;</td>
          <td class="paramname"><em>DB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="classSPTree.html#ad58a51dc42bfec6c9776cc2ebbd98842" title="Same meaning as MCFClass::MCFGetFO(). ">SPTree::MCFGetFO( void )</a>, except that the cost that is returned is that of the primal solution relative only to the subset of destinations whose names are contained in the first ND entries of the vector DB. </p>
<p>Note: node names in ND must be in 1 ... n irrespective of USENAME0. </p>

</div>
</div>
<a class="anchor" id="a451041eba0632676692f2de798bea4d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Reached </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if a shortest path from Origin to i have already been computed; this can be used when LABEL_SETTING == 1 to determine if a shortest from Origin to i have been obtained as a by-product of the calculation of the shortest path between Origin and some other Dest. </p>

</div>
</div>
<a class="anchor" id="af95a85d44e57ab53fe2b565355f6c054"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">MCFClass::cIndex_Set</a> Predecessors </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a cIndex* vector p[] such that p[ i ] is the predecessor of node i in the shortest path tree. </p>
<p>If a node i has no predecessor, i.e., i == Origin, i does not belong to the connected component of the origin or the computation have been stopped before reaching i, then p[ i ] == 0.</p>
<dl class="section note"><dt>Note</dt><dd>if the name "0" is used for nodes, (USENAME0 == 1) then node names are internally "translated" of +1 to avoid it being used - the the names reported in this vector will follow the same rule.</dd></dl>
<p>For this reason, the first entry of p (*p) is not significative. </p>

</div>
</div>
<a class="anchor" id="aaccf9d3766b10881f0b92387e3a9f914"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">cIndex_Set</a> ArcPredecessors </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a cIndex* vector a[] such that a[ i ] is the index of the arc ( p[ i ] , i ), being p[] the vector returned by the above method, and with the same structure. </p>
<p>If p[ i ] == 0, then a[ i ] is not significative: for the Origin (that has p[ Origin ] == 0), however, it is guaranteed that a[ Origin ] == Inf&lt;Index&gt;(). </p>

</div>
</div>
<a class="anchor" id="ae75a8a94d994b6a98934b241c969bdc6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">MCFClass::Index</a> Orig </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the root of the SPT problem. </p>

</div>
</div>
<a class="anchor" id="adfad352a13e6be066a344f09b34148da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">MCFClass::Index</a> DestN </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of destination nodes in the SPT problem. </p>

</div>
</div>
<a class="anchor" id="a0c4139e9f19c46099f798ec496faca2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMCFClass.html#a81575b2d4e4d5636b17170432150ae69">MCFClass::cIndex_Set</a> Dests </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the <a class="el" href="classSPTree.html#adfad352a13e6be066a344f09b34148da" title="Return the number of destination nodes in the SPT problem. ">DestN()</a>-vector containig the names of destination nodes in the SPT problem; the names are in increasing order and INF-terminated. </p>

</div>
</div>
<a class="anchor" id="ae131faa3f8901f33f24617a4e61f601b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">MCFClass::Index</a> LenFS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the size of the Forward Star of node i. </p>

</div>
</div>
<a class="anchor" id="afd79f2ffc8ffb4e444fa60a6bb4ebbe1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMCFClass.html#ad53d6229d7ec28555a9c9c2fd9abf773">MCFClass::Index</a> ReadFS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a76aaabb20535c51a2752b93f6c38fe54">cIndex</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the h-th arc in FS( i ) for h = 0, ... </p>
<p>, LenFS( i ) - 1. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classSPTree.html">SPTree</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
